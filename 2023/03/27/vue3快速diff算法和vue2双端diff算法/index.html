<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>vue3快速diff算法和vue2双端diff算法 - Enoch&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Enoch&#039;s Blog"><meta name="msapplication-TileImage" content="/images/avator.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Enoch&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="认识虚拟 DOM因为 Diff 算法的工作就是为了计算虚拟dom的差异，并将差异应用到真实DOM上，以实现高效的更新。Diff算法主要包括三个步骤：树的遍历、节点的比较和差异的应用。 在树的遍历过程中，Diff算法会递归地遍历虚拟DOM树和真实DOM树，并比较它们的节点。这个过程是从根节点开始，逐层向下遍历，通过比较节点的标签、属性、子节点等信息，来确定是否有差异存在。 节点的比较是Diff"><meta property="og:type" content="blog"><meta property="og:title" content="Enoch&#039;s Blog"><meta property="og:url" content="http://example.com/2023/03/27/vue3%E5%BF%AB%E9%80%9Fdiff%E7%AE%97%E6%B3%95%E5%92%8Cvue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="Enoch&#039;s Blog"><meta property="og:description" content="认识虚拟 DOM因为 Diff 算法的工作就是为了计算虚拟dom的差异，并将差异应用到真实DOM上，以实现高效的更新。Diff算法主要包括三个步骤：树的遍历、节点的比较和差异的应用。 在树的遍历过程中，Diff算法会递归地遍历虚拟DOM树和真实DOM树，并比较它们的节点。这个过程是从根节点开始，逐层向下遍历，通过比较节点的标签、属性、子节点等信息，来确定是否有差异存在。 节点的比较是Diff"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711159517219-12e245d1-d09e-4658-adde-2e340f49ccdd.webp#averageHue=%23eaeaea&amp;clientId=u5519c52d-4802-4&amp;from=paste&amp;id=udcd69b53&amp;originHeight=435&amp;originWidth=1357&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u16ecfbfb-22bd-41a4-82aa-52473224b96&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711161146980-76fe297a-1c95-4fc7-ae62-3a409d887f43.webp#averageHue=%23edf8f9&amp;clientId=u5519c52d-4802-4&amp;from=paste&amp;id=u7ce1ca94&amp;originHeight=700&amp;originWidth=1611&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90aaca1d-a922-45c8-b706-b49831a0516&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711162116910-c7eb6e15-d0d3-486a-97fe-4839e6fd2fa0.webp#averageHue=%23fbfdfd&amp;clientId=u8caaa644-94b8-4&amp;from=paste&amp;id=ua2d0d784&amp;originHeight=900&amp;originWidth=1386&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u574fe19b-d7e3-43f1-8afb-ce4db29af1d&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711162315239-929e5ba0-7163-4c71-a04f-92cad9b06ff7.webp#averageHue=%23fafcfc&amp;clientId=u8caaa644-94b8-4&amp;from=paste&amp;id=ua3de4026&amp;originHeight=454&amp;originWidth=857&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1bdaf28f-a849-408e-9912-13b735dfd5e&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711163579198-98ac3a5f-7d6b-477b-af44-2e822bfd003e.webp#averageHue=%23fafcfc&amp;clientId=u8caaa644-94b8-4&amp;from=paste&amp;id=u4ed57463&amp;originHeight=414&amp;originWidth=700&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u32e8e35a-3020-49c0-8da5-3187a60dd12&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711247879852-2e1ca629-f941-45bc-a837-1fe1fe83f295.webp#averageHue=%23fafcfc&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=uc0eba0d0&amp;originHeight=429&amp;originWidth=776&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc68c3b2a-3c91-42f7-b29d-e4af3a6ad26&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711248107967-e9424b5e-92df-44d5-afcc-5266a21bcf9e.webp#averageHue=%23fafcfc&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=uba3e493f&amp;originHeight=412&amp;originWidth=813&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5843057e-dd35-4a26-b69b-bfb7ce64bdb&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711249080043-bfca8cd0-418b-4b8b-8e82-58b4bdc95b61.webp#averageHue=%23fcfefe&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=u68fd7f91&amp;originHeight=852&amp;originWidth=2028&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u676f036c-a550-46d3-ba01-acf3bd4d18d&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711249217803-a4a56829-caba-48b4-b518-cefa6641d843.webp#averageHue=%23fbfdfd&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=u2b513d5d&amp;originHeight=352&amp;originWidth=718&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud16ae429-a24b-4bb9-8def-db7d7030532&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711249291435-4785bb1a-4313-4254-b72b-20099f2a3ed0.webp#averageHue=%23fafcfc&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=ue159cdb3&amp;originHeight=409&amp;originWidth=942&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4ec1d699-0369-42dd-8f99-f510b52cb04&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711251127487-161b885a-0f19-4de4-8a8c-ee6cc6be72db.webp#averageHue=%23fbfdfd&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=u11c28e05&amp;originHeight=480&amp;originWidth=878&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u9817ca27-d1e8-4af7-a4ff-274c67c2397&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711251336444-ce954c12-fc4f-427c-b505-aa04aa6846b7.webp#averageHue=%23fbfdfd&amp;clientId=u1fe01095-44f2-4&amp;from=paste&amp;id=u70eee435&amp;originHeight=453&amp;originWidth=820&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub515fa9d-c211-4ddb-84b0-cd30bd193a7&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366504873-9f69469f-3948-4da6-97b4-7dec09de8c7b.webp#averageHue=%23fbfbfb&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=HNHIG&amp;originHeight=423&amp;originWidth=700&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufeffeed7-ae52-4a42-8dd6-88160c25e77&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366711308-50caf337-77aa-4efe-8d77-f339300205f1.webp#averageHue=%23f8f8f7&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=udeaa8578&amp;originHeight=378&amp;originWidth=661&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u92e7126e-0328-4bd1-90e4-9f1db930da3&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366947781-1f4bb869-5c43-4152-9e8f-b0cce6e40ed0.webp#averageHue=%23f9f9f9&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=udfe49980&amp;originHeight=431&amp;originWidth=593&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7767f579-3ff0-4cab-9991-a088301cea2&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366988576-9c2a353b-1c15-4da7-b1c1-6f388c3d017d.webp#averageHue=%23f8f8f8&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=ueb116dec&amp;originHeight=381&amp;originWidth=662&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u76959916-53fe-47b9-b30a-2fc21328320&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367012773-7d60f3be-2c54-4d89-9121-c29ceb67e507.webp#averageHue=%23f8f8f8&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=ua396e169&amp;originHeight=414&amp;originWidth=676&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u34d040e9-457d-465d-8710-46bcf7b706a&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367196570-674d9870-487d-40c2-8e78-5d1b344a326c.webp#averageHue=%23faf6ec&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=ua02f08a5&amp;originHeight=429&amp;originWidth=613&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufc154651-e494-4b79-964d-8461c3d3351&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367223091-a096cf79-0f47-418a-a3e1-11d10f149ae1.webp#averageHue=%23faf5ec&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=u9fec563b&amp;originHeight=416&amp;originWidth=583&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc51df7f5-4f85-4f39-8540-0fa090cdf73&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367523261-8fe78515-3c41-4f7e-a121-65d889d64523.webp#averageHue=%23f9f4ea&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=u89fd8150&amp;originHeight=410&amp;originWidth=574&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u903abd0e-0f03-430d-a09f-fdc180b6579&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367567687-77ca73c4-95f9-4854-8a20-243a6bf7f79f.webp#averageHue=%23faf5ed&amp;clientId=ucaab1cbc-703a-4&amp;from=paste&amp;id=u55c4f36b&amp;originHeight=425&amp;originWidth=642&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc6c7edf9-9cce-4962-9bb7-02d9159856f&amp;title="><meta property="article:published_time" content="2023-03-27T03:28:08.000Z"><meta property="article:modified_time" content="2024-05-27T03:30:29.127Z"><meta property="article:author" content="Enoch"><meta property="article:tag" content="vue3"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711159517219-12e245d1-d09e-4658-adde-2e340f49ccdd.webp#averageHue=%23eaeaea&amp;clientId=u5519c52d-4802-4&amp;from=paste&amp;id=udcd69b53&amp;originHeight=435&amp;originWidth=1357&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u16ecfbfb-22bd-41a4-82aa-52473224b96&amp;title="><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"blog"},"headline":"vue3快速diff算法和vue2双端diff算法","image":[],"datePublished":"2023-03-27T03:28:08.000Z","dateModified":"2024-05-27T03:30:29.127Z","author":{"@type":"Person","name":"Enoch"},"publisher":{"@type":"Organization","name":"Enoch's Blog","logo":{"@type":"ImageObject","url":"/images/avator.jpg"}},"description":"认识虚拟 DOM因为 Diff 算法的工作就是为了计算虚拟dom的差异，并将差异应用到真实DOM上，以实现高效的更新。Diff算法主要包括三个步骤：树的遍历、节点的比较和差异的应用。 在树的遍历过程中，Diff算法会递归地遍历虚拟DOM树和真实DOM树，并比较它们的节点。这个过程是从根节点开始，逐层向下遍历，通过比较节点的标签、属性、子节点等信息，来确定是否有差异存在。 节点的比较是Diff"}</script><link rel="canonical" href="http://example.com/2023/03/27/vue3%E5%BF%AB%E9%80%9Fdiff%E7%AE%97%E6%B3%95%E5%92%8Cvue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95/"><link rel="icon" href="/images/avator.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/avator.jpg" alt="Enoch&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-27T03:28:08.000Z" title="2023/3/27 11:28:08">2023-03-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T03:30:29.127Z" title="2024/5/27 11:30:29">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/vue/">vue</a></span><span class="level-item">an hour read (About 9942 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">vue3快速diff算法和vue2双端diff算法</h1><div class="content"><meta name="referrer" content="no-referrer">
<a name="y89b1"></a>

<h2 id="认识虚拟-DOM"><a href="#认识虚拟-DOM" class="headerlink" title="认识虚拟 DOM"></a>认识虚拟 DOM</h2><p>因为 Diff 算法的工作就是为了计算虚拟dom的差异，并将差异应用到真实DOM上，以实现高效的更新。Diff算法主要包括三个步骤：树的遍历、节点的比较和差异的应用。</p>
<p>在树的遍历过程中，Diff算法会递归地遍历虚拟DOM树和真实DOM树，并比较它们的节点。这个过程是从根节点开始，逐层向下遍历，通过比较节点的标签、属性、子节点等信息，来确定是否有差异存在。</p>
<p>节点的比较是Diff算法的核心部分，它会对虚拟DOM和真实DOM的节点进行详细的比较。在比较过程中，会考虑节点的类型、标签、属性等方面的差异，并将这些差异记录下来。</p>
<p>差异的应用是将记录下来的差异应用到真实DOM上，以实现对DOM的更新。这个过程是通过操作真实DOM的API来实现的，比如添加、删除、修改节点等操作。</p>
<p>虚拟 DOM 简单说就是 <strong>用JS对象来模拟 DOM 结构</strong><br>怎么用 JS 对象模拟 DOM 结构的呢？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span> <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot;&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">h1</span>&gt;沐华&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">template</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>上面的模板转在虚拟 DOM 就是下面这样的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  props:&#123; id:<span class="string">&#x27;app&#x27;</span>, <span class="class"><span class="keyword">class</span>:&#x27;<span class="title">container</span>&#x27; &#125;,</span></span><br><span class="line"><span class="class">  <span class="title">children</span>: [</span></span><br><span class="line"><span class="class">    </span>&#123; tag: <span class="string">&#x27;h1&#x27;</span>, children:<span class="string">&#x27;沐华&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这样的 DOM 结构就称之为 <strong>虚拟 DOM</strong> (Virtual Node)，简称 vnode。</p>
<ul>
<li><strong>tag</strong>：必选。就是标签。也可以是组件，或者函数</li>
<li><strong>props</strong>：非必选。就是这个标签上的属性和方法</li>
<li><strong>children</strong>：非必选。就是这个标签的内容或者子节点，如果是文本节点就是字符串，如果有子节点就是数组。换句话说 如果判断 children 是字符串的话，就表示一定是文本节点，这个节点肯定没有子元素</li>
</ul>
<p><strong>为什么要使用虚拟 DOM 呢？</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711159517219-12e245d1-d09e-4658-adde-2e340f49ccdd.webp#averageHue=%23eaeaea&clientId=u5519c52d-4802-4&from=paste&id=udcd69b53&originHeight=435&originWidth=1357&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u16ecfbfb-22bd-41a4-82aa-52473224b96&title="><br>如图可以看出原生 DOM 有非常多的属性和事件，就算是创建一个空div也要付出不小的代价。 如果我们去全量更新那，性能可想而知， diff 算法和数据改变前的 DOM 对比，计算出需要更改的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图，这样就有很大的性能提升</p>
<p><a name="TD1oV"></a></p>
<h2 id="Vue3快速diff算法"><a href="#Vue3快速diff算法" class="headerlink" title="Vue3快速diff算法"></a>Vue3快速diff算法</h2><p><a name="NzsUL"></a></p>
<h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711161146980-76fe297a-1c95-4fc7-ae62-3a409d887f43.webp#averageHue=%23edf8f9&clientId=u5519c52d-4802-4&from=paste&id=u7ce1ca94&originHeight=700&originWidth=1611&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u90aaca1d-a922-45c8-b706-b49831a0516&title="><br>这里需要注意的一点是，vue在进行diff算法对比的时候，对有key的组件和没key的组件采用的是两个函数去分别处理<br><a name="VHJXd"></a></p>
<h3 id="对比详解"><a href="#对比详解" class="headerlink" title="对比详解"></a>对比详解</h3><p><a name="TBOEM"></a></p>
<h4 id="patchChildren函数"><a href="#patchChildren函数" class="headerlink" title="patchChildren函数"></a>patchChildren函数</h4><p><a name="F863X"></a></p>
<h4 id="当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现"><a href="#当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现" class="headerlink" title="当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现"></a>当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patchChildren: PatchChildrenFn = (...) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 取一哈新旧虚拟节点的子节点</span></span><br><span class="line">    <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.children</span><br><span class="line">    <span class="keyword">const</span> prevShapeFlag = n1 ? n1.shapeFlag : <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> c2 = n2.children</span><br><span class="line">    <span class="keyword">const</span> &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class="line">    <span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// patchFlag &gt; 0 就表示子节点含有动态属性，如：动态style、动态class、动态文案等</span></span><br><span class="line">      <span class="keyword">if</span> (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) &#123;</span><br><span class="line">        <span class="comment">// 子节点带 key</span></span><br><span class="line">        patchKeyedChildren(...)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) &#123;</span><br><span class="line">        <span class="comment">// 子节点不带 key</span></span><br><span class="line">        patchUnkeyedChildren(...)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点存在3种可能的情况：文本、数组、没有子节点</span></span><br><span class="line">    <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      <span class="comment">// 新虚拟节点的子节点是文本</span></span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">        <span class="comment">// 对应的旧虚拟节点的子节点是数组</span></span><br><span class="line">        <span class="comment">// 卸载旧虚拟节点的数组子节点</span></span><br><span class="line">        unmountChildren(c1 <span class="keyword">as</span> VNode[], parentComponent, parentSuspense)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 再挂载新虚拟节点的文本子节点</span></span><br><span class="line">      <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">        hostSetElementText(container, c2 <span class="keyword">as</span> string)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">        <span class="comment">// 旧虚拟节点的子节点是数组</span></span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">          <span class="comment">// 新虚拟节点的子节点也是数组，做全量diff</span></span><br><span class="line">          patchKeyedChildren(...)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 能走到这就说明新虚拟节点没有子节点，这里只需要卸载久虚拟节点的子节点</span></span><br><span class="line">          unmountChildren(c1 <span class="keyword">as</span> VNode[], parentComponent, parentSuspense, <span class="keyword">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 走到这就说明</span></span><br><span class="line">        <span class="comment">// 旧虚拟节点的子节点要么是文本要么也没有子节点</span></span><br><span class="line">        <span class="comment">// 新虚拟节点的子节点要么是数组要么就没有子节点</span></span><br><span class="line">        <span class="keyword">if</span> (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">          <span class="comment">// 旧虚拟节点的子节点是文本，更新</span></span><br><span class="line">          hostSetElementText(container, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">          <span class="comment">// 新虚拟节点的子节点是数组，挂载</span></span><br><span class="line">          mountChildren(...)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从patchChildren函数的源码中我们可以知道，Vue3在比较新旧两组子节点的时候会采用以下两种方法处理：</p>
<ul>
<li>如果新的子节点没有key属性，那么就会调用patchUnkeyedChildren函数来对新旧两组子节点进行Diff比较；</li>
<li>如果新的子节点没有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较；</li>
</ul>
<p>这两种函数的对比是有区别的<br><a name="P81Vk"></a></p>
<h4 id="patchUnkeyedChildren函数"><a href="#patchUnkeyedChildren函数" class="headerlink" title="patchUnkeyedChildren函数"></a>patchUnkeyedChildren函数</h4><p>如果新的子节点没有key属性，那么就会调用patchUnkeyedChildren函数来对新旧两组子节点进行Diff比较。该函数的代码如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有 key 标识的子节点的 patch 过程，即 diff 过程</span></span><br><span class="line">  <span class="keyword">const</span> patchUnkeyedChildren = (</span><br><span class="line">    c1: VNode[],</span><br><span class="line">    c2: VNodeArrayChildren,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | <span class="keyword">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="keyword">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="keyword">null</span>,</span><br><span class="line">    isSVG: boolean,</span><br><span class="line">    slotScopeIds: string[] | <span class="keyword">null</span>,</span><br><span class="line">    optimized: boolean</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 旧子节点</span></span><br><span class="line">    c1 = c1 || EMPTY_ARR</span><br><span class="line">    <span class="comment">// 新子节点</span></span><br><span class="line">    c2 = c2 || EMPTY_ARR</span><br><span class="line">    <span class="comment">// 旧的一组子节点的长度</span></span><br><span class="line">    <span class="keyword">const</span> oldLength = c1.length</span><br><span class="line">    <span class="comment">// 新的一组子节点的长度</span></span><br><span class="line">    <span class="keyword">const</span> newLength = c2.length</span><br><span class="line">    <span class="comment">// 两组子节点的公共长度，即两者中较短的那一组子节点的长度</span></span><br><span class="line">    <span class="keyword">const</span> commonLength = Math.min(oldLength, newLength)</span><br><span class="line">    let i</span><br><span class="line">    <span class="comment">// 遍历commonLength，调用patch函数进行更新</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">        ? cloneIfMounted(c2[i] <span class="keyword">as</span> VNode)</span><br><span class="line">        : normalizeVNode(c2[i]))</span><br><span class="line">      patch(</span><br><span class="line">        c1[i],</span><br><span class="line">        nextChild,</span><br><span class="line">        container,</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果旧的一组子节点的长度大于新的一组子节点的长度，说明有旧的子节点需要卸载</span></span><br><span class="line">    <span class="keyword">if</span> (oldLength &gt; newLength) &#123;</span><br><span class="line">      <span class="comment">// remove old</span></span><br><span class="line">      unmountChildren(</span><br><span class="line">        c1,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        <span class="keyword">true</span>,</span><br><span class="line">        <span class="keyword">false</span>,</span><br><span class="line">        commonLength</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 说明是有新子节点需要挂载</span></span><br><span class="line">      <span class="comment">// mount new</span></span><br><span class="line">      mountChildren(</span><br><span class="line">        c2,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized,</span><br><span class="line">        commonLength</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码所示，处理步骤如下：</p>
<ol>
<li>求新旧两组子节点各自的长度，然后求出两组子节点的公共长度commonLength；</li>
<li>遍历commonLength，调用patch函数进行更新；</li>
<li>公共长度内的子节点更新完毕，进行以下操作：<ol>
<li>如果新的一组子节点的长度更长，说明新的子节点需要挂载，调用mountChildren函数进行挂载；</li>
<li>否则说明旧子节点需要卸载，调用unmount函数卸载旧节点；</li>
</ol>
</li>
</ol>
<p>这个函数的对比过程是十分简单的，比较关键的是下面的这个函数！<br><a name="rVoNf"></a></p>
<h4 id="patchKeyedChildren函数"><a href="#patchKeyedChildren函数" class="headerlink" title="patchKeyedChildren函数"></a>patchKeyedChildren函数</h4><p><a name="SVI6R"></a></p>
<h4 id="如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。"><a href="#如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。" class="headerlink" title="如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。"></a>如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。</h4><p><a name="o9r4f"></a></p>
<h5 id="快速diff算法预处理步骤"><a href="#快速diff算法预处理步骤" class="headerlink" title="快速diff算法预处理步骤"></a>快速diff算法预处理步骤</h5><p>快速 Diff 算法包含预处理步骤，这其实是借鉴了纯文本 Diff 算法的思路。快速diff算法的预处理是分别处理新旧节点中的前置节点和后置节点。预处理达成的目的实际上就是<strong>把key相同的节点位置相同的节点找出来，这部分节点直接用patch进行更新，不参与后续循环</strong></p>
<p><a name="V8fkO"></a></p>
<h5 id="处理前置节点"><a href="#处理前置节点" class="headerlink" title="处理前置节点"></a>处理前置节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="comment">// 新的一组子节点的长度</span></span><br><span class="line"><span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line"><span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line"><span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span> <span class="comment">// prev ending index</span></span><br><span class="line"><span class="comment">// 新子节点的尾部索引</span></span><br><span class="line"><span class="keyword">let</span> e2 = l2 - <span class="number">1</span> <span class="comment">// next ending index</span></span><br><span class="line"><span class="comment">// 从头部开始同步，处理相同的同步节点</span></span><br><span class="line"><span class="comment">// 1. sync from start</span></span><br><span class="line"><span class="comment">// (a b) c</span></span><br><span class="line"><span class="comment">// (a b) d e</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">  <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">  <span class="keyword">const</span> n2 = (c2[i] = optimized</span><br><span class="line">              ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">              : <span class="title function_">normalizeVNode</span>(c2[i]))</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    <span class="comment">// 相同的节点，递归执行patch更新节点</span></span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      n1,</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遇到了 key 不同的节点，那就直接退出循环，相同前置节点(a b)的更新处理完成</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用while循环查找所有相同的前置节点，并调用patch函数进行打补丁，直到遇到key值不同的节点为止。这样就完成了前置节点的更新。（很简单，就是在两组新旧节点定一个指针从头部开始移动遇到key值不同的节点为止停止移动）<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711162116910-c7eb6e15-d0d3-486a-97fe-4839e6fd2fa0.webp#averageHue=%23fbfdfd&clientId=u8caaa644-94b8-4&from=paste&id=ua2d0d784&originHeight=900&originWidth=1386&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u574fe19b-d7e3-43f1-8afb-ce4db29af1d&title="><br><a name="OlbdF"></a></p>
<h5 id="处理后置节点"><a href="#处理后置节点" class="headerlink" title="处理后置节点"></a>处理后置节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. sync from end</span></span><br><span class="line"><span class="comment">// a (b c)</span></span><br><span class="line"><span class="comment">// d e (b c)</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">  <span class="comment">// 旧的后置节点</span></span><br><span class="line">  <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">  <span class="comment">// 新的后置节点</span></span><br><span class="line">  <span class="keyword">const</span> n2 = (c2[e2] = optimized</span><br><span class="line">    ? <span class="title function_">cloneIfMounted</span>(c2[e2] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">    : <span class="title function_">normalizeVNode</span>(c2[e2]))</span><br><span class="line">  <span class="comment">// 新旧后置节点相同，调用 patch 函数打补丁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      n1,</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遇到了 key 不同的节点，退出循环，相同后置节(b c)点的更新处理完成</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新旧后置节点索引递减，即从后往前遍历两组子节点</span></span><br><span class="line">  e1--</span><br><span class="line">  e2--</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711162315239-929e5ba0-7163-4c71-a04f-92cad9b06ff7.webp#averageHue=%23fafcfc&clientId=u8caaa644-94b8-4&from=paste&id=ua3de4026&originHeight=454&originWidth=857&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1bdaf28f-a849-408e-9912-13b735dfd5e&title="><br>与处理前置节点一样，在while循环内，需要调用patch函数进行打补丁，然后递减两个索引e1、e2，直到遇到类型不同且key值不同的节点为止，这样就完成了后置节点的更新。<br><a name="RcpFc"></a></p>
<h5 id="处理新增节点"><a href="#处理新增节点" class="headerlink" title="处理新增节点"></a>处理新增节点</h5><p>当前置节点和后置节点处理完毕后，旧的一组子节点已经全部被处理了，但是在新的一组子节点中，还遗留了一个未被处理的节点p-4，这个节点是新增的节点。怎么判断出p-4是一个新增的节点的呢？ 我们可以根据索引i、e1、e2之间的关系：</p>
<ul>
<li>条件一：e1 &lt; i：说明在预处理过程中，所有的旧节点都处理完毕了，因为旧子节点指针e1 处理完毕后在 i 的前面；</li>
<li>条件二：e2 ≥ i：说明在预处理过程中，在新的一组子节点中，仍然有未被处理的节点，因为新节点的指针e2还在i指针的后面，而这些遗留的节点江北视为<strong>新增节点</strong>。</li>
</ul>
<p>如果条件一和条件二同时成立，说明在新的一组子节点中，存在遗留节点，且这些节点都是新增节点。因此，我们需要将它们挂载到正确的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. common sequence + mount</span></span><br><span class="line"><span class="comment">// (a b)</span></span><br><span class="line"><span class="comment">// (a b) c</span></span><br><span class="line"><span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line"><span class="comment">// (a b)</span></span><br><span class="line"><span class="comment">// c (a b)</span></span><br><span class="line"><span class="comment">// i = 0, e1 = -1, e2 = 0</span></span><br><span class="line"><span class="comment">// i &gt; e1 说明在预处理的过程中，所有的旧子节点处理完毕额</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  <span class="comment">// i &lt;= e2 说明在预处理过后，在新的一组子节点中，仍然有未被处理的节点，这些遗留的节点将被视作新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">    <span class="comment">// 锚点的索引</span></span><br><span class="line">    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 锚点元素</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextPos &lt; l2 ? (c2[nextPos] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor</span><br><span class="line">    <span class="comment">// 采用 while 循环，调用 patch 函数逐个挂载新增节点</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        (c2[i] = optimized</span><br><span class="line">          ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">          : <span class="title function_">normalizeVNode</span>(c2[i])),</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这段代码中：</p>
<ul>
<li>计算锚点的索引值（nextPos）为e2 + 1;</li>
<li>如果小于新的一组子节点的数量，则说明锚点元素在新的一组子节点中，直接使用(c2[nextPos] as VNode).el，否则说明索引c2对应的节点已经是尾部节点了，这时锚点元素是parentAnchor；</li>
<li>找到锚点元素后，使用一个while循环，将i和e2之间的节点作为新节点挂载；</li>
</ul>
<p>像这样 找到 新节点数组中的 e2 - i之间的所有节点，当作新节点进行挂载<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711163579198-98ac3a5f-7d6b-477b-af44-2e822bfd003e.webp#averageHue=%23fafcfc&clientId=u8caaa644-94b8-4&from=paste&id=u4ed57463&originHeight=414&originWidth=700&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u32e8e35a-3020-49c0-8da5-3187a60dd12&title="><br><a name="nobFb"></a></p>
<h5 id="处理删除节点"><a href="#处理删除节点" class="headerlink" title="处理删除节点"></a>处理删除节点</h5><p><a name="jFZib"></a></p>
<h5 id><a href="#" class="headerlink" title></a><br></h5><p>当相同的前置节点和后置节点全部被处理完毕后，新的一组子节点已经全部被处理完毕，而就得一组子节点中遗留了一个节点p-2，实际上，遗留的节点可能有多个，如下图所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. common sequence + unmount</span></span><br><span class="line"><span class="comment">// (a b) c</span></span><br><span class="line"><span class="comment">// (a b)</span></span><br><span class="line"><span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line"><span class="comment">// a (b c)</span></span><br><span class="line"><span class="comment">// (b c)</span></span><br><span class="line"><span class="comment">// i = 0, e1 = 0, e2 = -1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的源码中，当满足i &gt; e2 &amp;&amp; i ≤ e1时，则开启一个while循环，并调用unmount函数将i到e1之间的节点全部删除。 到这里，基于理想情况下，处理完前置节点和后置节点后，新旧两组子节点总有一组的子节点全部被处理完毕。所有的操作只需要简单地更新、挂载、卸载节点即可。<br>判断新子节点便利完的情况，并且旧子节点有遗漏的情况的条件</p>
<ul>
<li>条件一： i &lt;&#x3D;e1：说明在预处理过程中，旧子节点有遗漏没遍历完全</li>
<li>条件二：i &gt; e2：说明在预处理过程中，新子节点已经遍历完</li>
</ul>
<p>注意：现在预处理过程中的新增节点和删除节点是举的最理想状况的例子，还有个别极端情况，比如，预处理结束后，新旧节点剩下的数量一样，其中新节点有新增元素，有旧节点中存在，新节点中不存在的已经被删除的元素，也有新旧节点都存在的元素但是顺序不一样的元素，<strong>接下来的处理方式才是重中之重！</strong><br><a name="mZlXY"></a></p>
<h5 id="非理想情况下的未处理节点"><a href="#非理想情况下的未处理节点" class="headerlink" title="非理想情况下的未处理节点"></a>非理想情况下的未处理节点</h5><p>上面的例子都比较理想化，当完成前置和后置节点的处理后，新旧两组子节点总会有一组子节点全部被处理完毕，但有的情况比较复杂。<br>下面我们给出非理想情况下的例子，经过上面的前置和后置处理后，新子节点和旧子节点都有未被处理的节点，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711247879852-2e1ca629-f941-45bc-a837-1fe1fe83f295.webp#averageHue=%23fafcfc&clientId=u1fe01095-44f2-4&from=paste&id=uc0eba0d0&originHeight=429&originWidth=776&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc68c3b2a-3c91-42f7-b29d-e4af3a6ad26&title="><br>在这种非理想情况下，索引i、e1、e2不满足下面两个条件中的任何一个：</p>
<ul>
<li>i &gt; e1 &amp;&amp; i &lt; e2(新增节点的情况)</li>
<li>i &gt; e2 &amp;&amp; i &lt; e1(卸载旧节点的情况)</li>
</ul>
<p>怎么来处理这种情况呢？这里的内容是vue算法的重大更新，也是性能优化的一个点！<br><a name="lpebb"></a></p>
<h6 id="第1步：构建索引表keyToNewIndexMap"><a href="#第1步：构建索引表keyToNewIndexMap" class="headerlink" title="第1步：构建索引表keyToNewIndexMap"></a><strong>第1步：构建索引表keyToNewIndexMap</strong></h6><p>给新子节点构建一张索引表keyToNewIndexMap，目的是用来<strong>存储节点key和在新子节点位置的索引</strong>，可以在O(n)时间复杂度下获取到旧节点，提高查找性能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理完后，未处理节点的第一个未处理节点的索引位置</span></span><br><span class="line"><span class="keyword">const</span> s1 = i <span class="comment">// prev starting index</span></span><br><span class="line"><span class="keyword">const</span> s2 = i <span class="comment">// next starting index</span></span><br><span class="line"><span class="comment">// 构建新的一组子节点中未处理的key和索引位置的映射，是为了解决性能问题</span></span><br><span class="line"><span class="comment">// 5.1 build key:index map for newChildren</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">keyToNewIndexMap</span>: <span class="title class_">Map</span>&lt;string | number | symbol, number&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">    ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">    : <span class="title function_">normalizeVNode</span>(c2[i]))</span><br><span class="line">  <span class="keyword">if</span> (nextChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; keyToNewIndexMap.<span class="title function_">has</span>(nextChild.<span class="property">key</span>)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`Duplicate keys found during update:`</span>,</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(nextChild.<span class="property">key</span>),</span><br><span class="line">        <span class="string">`Make sure keys are unique.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新节点的key和索引位置添加到map集合中</span></span><br><span class="line">    keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们得到了keyToNewIndexMap索引表<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711248107967-e9424b5e-92df-44d5-afcc-5266a21bcf9e.webp#averageHue=%23fafcfc&clientId=u1fe01095-44f2-4&from=paste&id=uba3e493f&originHeight=412&originWidth=813&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u5843057e-dd35-4a26-b69b-bfb7ce64bdb&title="></p>
<p><a name="EyCt1"></a></p>
<h6 id="第2步：构建newIndexToOldIndexMap数组"><a href="#第2步：构建newIndexToOldIndexMap数组" class="headerlink" title="第2步：构建newIndexToOldIndexMap数组"></a><strong>第2步：构建newIndexToOldIndexMap数组</strong></h6><p>为了在后面快速找到需要移动的节点，需要构建newIndexToOldIndexMap数组，它的长度等于经过预处理后未处理的新子点数量，并且初始值都是0。其源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j</span><br><span class="line"><span class="comment">// 代表更新过节点数量</span></span><br><span class="line"><span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line"><span class="comment">// 新的一组节点中剩余未处理节点的数量</span></span><br><span class="line"><span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span></span><br><span class="line"><span class="comment">// 标识节点是否需要移动节点</span></span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 代表遍历旧的一组子节点的过程中遇到的最大索引值</span></span><br><span class="line"><span class="comment">// used to track whether any node has moved</span></span><br><span class="line"><span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line"><span class="comment">// 构建一个索引映射数组，存储新的一组子节点在旧的一组子节点的位置索引（存储的是新的一组子节点中的节点在旧的一组子节点中的位置索引）</span></span><br><span class="line"><span class="comment">// works as Map&lt;newIndex, oldIndex&gt;</span></span><br><span class="line"><span class="comment">// Note that oldIndex is offset by +1</span></span><br><span class="line"><span class="comment">// and oldIndex = 0 is a special value indicating the new node has</span></span><br><span class="line"><span class="comment">// no corresponding old node.</span></span><br><span class="line"><span class="comment">// used for determining longest stable subsequence</span></span><br><span class="line"><span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="pwGOD"></a></p>
<h6 id="第3步：填充newIndexToOldIndexMap数组"><a href="#第3步：填充newIndexToOldIndexMap数组" class="headerlink" title="第3步：填充newIndexToOldIndexMap数组"></a><strong>第3步：填充newIndexToOldIndexMap数组</strong></h6><p>填充的目的是将newIndexToOldIndexMap数组中的元素存储的是新的一组子节点中的节点在旧的一组子节点中的位置索引。如果旧的一组子节点中没有新的一组的子节点元素那么将新的子节点元素的索引值设为 -1 （其实这段代码，我并没有找到对应的源码进行正式，但是这种情况一定是给了一个比较特殊的值，反正有待自己考证）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历旧的一组子节点中剩余未处理的节点</span></span><br><span class="line"><span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">  <span class="comment">// 旧数组中剩余未处理的节点</span></span><br><span class="line">  <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line">  <span class="comment">// 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点</span></span><br><span class="line">  <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">    <span class="comment">// all new children have been patched so this can only be a removal</span></span><br><span class="line">    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新的一组子节点中未被处理节点在新子节点中的位置索引</span></span><br><span class="line">  <span class="keyword">let</span> newIndex</span><br><span class="line">  <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 从索引表中获取与旧节点具有相同key的新节点在新的一组子节点中的位置索引</span></span><br><span class="line">    newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 旧子节点没有 key ，那么尝试在新的一组子节点中查找具有相同类型的没有key的新子节点</span></span><br><span class="line">    <span class="comment">// key-less node, try to locate a key-less node of the same type</span></span><br><span class="line">    <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">isSameVNodeType</span>(prevChild, c2[j] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        newIndex = j</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果在新的一组子节点中没有找到与旧的一组子节点中具有相同key 或相同类型的子节点，</span></span><br><span class="line">  <span class="comment">// 说明该旧子节点在新的一组子节点中已经不存在了，需要将其卸载</span></span><br><span class="line">  <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 填充 索引映射数组</span></span><br><span class="line">    newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 通过比较 newIndex 和 maxNewIndexSoFar 的值来判断节点是否需要移动</span></span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">      <span class="comment">// 如果在遍历过程中遇到的索引值呈现递增趋势，则说明不需要移动节点</span></span><br><span class="line">      maxNewIndexSoFar = newIndex</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则需要移动</span></span><br><span class="line">      moved = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用patch函数完成更新</span></span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      prevChild,</span><br><span class="line">      c2[newIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 每更新一个节点，都将patched变量+1</span></span><br><span class="line">    patched++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的源码解析如下：</p>
<ol>
<li>使用for循环遍历旧子节点，在遍历过程如果发现已经更新的节点数量patched大于需要更新的节点数量toBePatched，则调用unmount将剩余的旧节点全部卸载掉；</li>
<li>拿旧节点的key值去索引表keyToNewIndexMap去查找该节点在新节点中的位置newIndex;</li>
<li>如果newIndex不存在，则说明该节点在新节点已经不存在，则调用unmount函数卸载它；</li>
<li>如果newIndex存在，则说明该节点在新节点中存在，则调用patch函数更新打补丁，并填充newIndexToOldIndexMap数组；(注意：现在的newIndexToOldIndexMap中的索引值是未处理的新节点在全部旧子节点中的索引位置，p3在旧子节点中的索引是2)</li>
</ol>
<p>在这段代码中， 增加了两个变量moved和maxNewIndexSoFar变量，其中，moved的初始值是false，代表是否需要移动节点，maxNewIndexSoFar初始值为0，代表遍历旧节点过程中遇到的最大索引值。如果在遍历过程中遇到的索引值呈递增趋势，则不需要移动节点，否则就需要移动节点。<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711249080043-bfca8cd0-418b-4b8b-8e82-58b4bdc95b61.webp#averageHue=%23fcfefe&clientId=u1fe01095-44f2-4&from=paste&id=u68fd7f91&originHeight=852&originWidth=2028&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u676f036c-a550-46d3-ba01-acf3bd4d18d&title="><br><a name="s119g"></a></p>
<h6 id="第4步：判断节点是否需要移动"><a href="#第4步：判断节点是否需要移动" class="headerlink" title="第4步：判断节点是否需要移动"></a><strong>第4步：判断节点是否需要移动</strong></h6><p><strong>计算最长递增序列</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">  ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap) <span class="comment">// [0, 1]</span></span><br><span class="line">  : <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getSequence函数返回的是最长递增序列中的元素在newIndexToOldIndexMap数组的位置索引。<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711249217803-a4a56829-caba-48b4-b518-cefa6641d843.webp#averageHue=%23fbfdfd&clientId=u1fe01095-44f2-4&from=paste&id=u2b513d5d&originHeight=352&originWidth=718&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud16ae429-a24b-4bb9-8def-db7d7030532&title="><br><strong>重新编号</strong><br>本步骤忽略掉经过预处理的前置节点和后置节点，对新旧未处理的节点索引值进行重新编号。<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711249291435-4785bb1a-4313-4254-b72b-20099f2a3ed0.webp#averageHue=%23fafcfc&clientId=u1fe01095-44f2-4&from=paste&id=ue159cdb3&originHeight=409&originWidth=942&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u4ec1d699-0369-42dd-8f99-f510b52cb04&title="><br><strong>重置索引i,j的指向，辅助节点移动</strong><br>索引j指向最长递增序列中最后一个节点的位置，索引i指向新子节点最后一个位置。<br>然后开启一个for循环，让索引i、j按照箭头的方向移动，见第5步。</p>
<p><strong>newIndexToOldIndexMap[i]的值为0：挂载节点</strong><br>如果newIndexToOldIndexMap[i]的值为0，则说明索引为i的节点是全新的节点，使用patch函数将其挂载到容器中。(这里就是处理的新增节点，反正在<strong>newIndexToOldIndexMap数组里面是具有特殊标识的</strong>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// mount new</span></span><br><span class="line">  <span class="title function_">patch</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    nextChild,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    slotScopeIds,</span><br><span class="line">    optimized</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>i ≠ seq[j]时，移动节点</strong><br>当索引i和索引j指向的子序列元素时，该节点对应的真实DOM需要移动。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">  <span class="comment">// 当指向新的一组子节点的元素索引 i 不等于索引 j指向的子序列的元素时，</span></span><br><span class="line">  <span class="comment">// 该节点对应的真实DOM元素需要移动</span></span><br><span class="line">  <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711251127487-161b885a-0f19-4de4-8a8c-ee6cc6be72db.webp#averageHue=%23fbfdfd&clientId=u1fe01095-44f2-4&from=paste&id=u11c28e05&originHeight=480&originWidth=878&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u9817ca27-d1e8-4af7-a4ff-274c67c2397&title="><br>如上图所示，此时索引 i 的值为 2 ，索引 j 的值为 1 ，因此 2 !&#x3D;&#x3D; seq[1] 成立，因此，节点 p-2 对应的真实节点需要移动。</p>
<p><strong>i &#x3D;&#x3D; seq[j]时，无需移动节点</strong><br>当i &#x3D;&#x3D; seq[j]时，说明该位置的节点不需要移动，此时只需要让索引 j 按照图中箭头方向移动即可，即让变量 j 递减，进入下一次的循环比较。<strong>i &#x3D;&#x3D; seq[j]时，同时代表着索引i对应的新的节点在旧子节点中的相对位置是正确的，不需要进行移动</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711251336444-ce954c12-fc4f-427c-b505-aa04aa6846b7.webp#averageHue=%23fbfdfd&clientId=u1fe01095-44f2-4&from=paste&id=u70eee435&originHeight=453&originWidth=820&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ub515fa9d-c211-4ddb-84b0-cd30bd193a7&title="><br>如上图所示，此时索引 i 的值为 1 ，索引 j 的值也为 1 ，因此 1 &#x3D;&#x3D;&#x3D; seq[1] 成立，节点 p-4 对应的真实节点不需要移动，只需要让变量 j 递减即可。移动挂载节点操作的完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// looping backwards so that we can use last patched node as anchor</span></span><br><span class="line"><span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> <span class="title class_">VNode</span></span><br><span class="line">  <span class="comment">// 锚点</span></span><br><span class="line">  <span class="keyword">const</span> anchor =</span><br><span class="line">    nextIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor</span><br><span class="line">  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// mount new</span></span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChild,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">    <span class="comment">// 这里是需要移动节点的情况</span></span><br><span class="line">    <span class="comment">// i 指向的是新的一组子节点中元素的位置索引</span></span><br><span class="line">    <span class="comment">// j 指向的是最长递增序列中元素的位置索引</span></span><br><span class="line">    <span class="comment">// move if:</span></span><br><span class="line">    <span class="comment">// There is no stable subsequence (e.g. a reverse)</span></span><br><span class="line">    <span class="comment">// OR current node is not among the stable sequence</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">      <span class="comment">// 当指向新的一组子节点的元素索引 i 不等于索引 j指向的子序列的元素时，</span></span><br><span class="line">      <span class="comment">// 该节点对应的真实DOM元素需要移动</span></span><br><span class="line">      <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当i === seq[j]时，说明该位置的节点不需要移动，即让索引j递减</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="d0Top"></a></p>
<h2 id="Vue2双端diff算法"><a href="#Vue2双端diff算法" class="headerlink" title="Vue2双端diff算法"></a>Vue2双端diff算法</h2><p><a name="BkzVt"></a></p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch()"></a>patch()</h3><p>Diff 算法，在 Vue2 里面就是 patch，其实 patch 就是一个函数，我们先介绍一下源码里的核心流程，再来看一下 patch 的源码，源码里每一行也有注释<br>它可以接收四个参数，主要还是前两个</p>
<ul>
<li><strong>oldVnode</strong>：老的虚拟 DOM 节点</li>
<li><strong>vnode</strong>：新的虚拟 DOM 节点</li>
<li><strong>hydrating</strong>：是不是要和真实 DOM 混合，服务端渲染的话会用到，这里不过多说明</li>
<li><strong>removeOnly</strong>：transition-group 会用到，这里不过多说明</li>
</ul>
<p>主要流程是这样的：</p>
<ul>
<li>vnode 不存在，oldVnode 存在，就删掉 oldVnode</li>
<li>vnode 存在，oldVnode 不存在，就创建 vnode</li>
<li>两个都存在的话，通过 sameVnode 函数(后面有详解)对比是不是同一节点<ul>
<li>如果是同一节点的话，通过 patchVnode 进行后续对比节点文本变化或子节点变化</li>
<li>如果不是同一节点，就把 vnode 挂载到 oldVnode 的父元素下</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个判断函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUndef</span> (<span class="attr">v</span>: any): boolean %checks &#123;</span><br><span class="line">  <span class="keyword">return</span> v === <span class="literal">undefined</span> || v === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDef</span> (<span class="attr">v</span>: any): boolean %checks &#123;</span><br><span class="line">  <span class="keyword">return</span> v !== <span class="literal">undefined</span> &amp;&amp; v !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    <span class="comment">// 如果新的 vnode 不存在，但是 oldVnode 存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 存在，调用 oldVnode 的组件卸载钩子 destroy</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) <span class="title function_">invokeDestroyHook</span>(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 oldVnode 不存在的话，新的 vnode 是肯定存在的，比如首次渲染的时候</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 就创建新的 vnode</span></span><br><span class="line">      <span class="title function_">createElm</span>(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 剩下的都是新的 vnode 和 oldVnode 都存在的话</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 是不是元素节点</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">      <span class="comment">// 是元素节点 &amp;&amp; 通过 sameVnode 对比是不是同一个节点 (函数后面有详解)</span></span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 如果是 就用 patchVnode 进行后续对比 (函数后面有详解)</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是同一元素节点的话</span></span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// const SSR_ATTR = &#x27;data-server-rendered&#x27;</span></span><br><span class="line">          <span class="comment">// 如果是元素节点 并且有 &#x27;data-server-rendered&#x27; 这个属性</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; oldVnode.<span class="title function_">hasAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)) &#123;</span><br><span class="line">            <span class="comment">// 就是服务端渲染的，删掉这个属性</span></span><br><span class="line">            oldVnode.<span class="title function_">removeAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 这个判断里是服务端渲染的处理逻辑，就是混合</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isTrue</span>(hydrating)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">              <span class="title function_">warn</span>(<span class="string">&#x27;这是一段很长的警告信息&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// function emptyNodeAt (elm) &#123;</span></span><br><span class="line">          <span class="comment">//    return new VNode(nodeOps.tagName(elm).toLowerCase(), &#123;&#125;, [], undefined, elm)</span></span><br><span class="line">          <span class="comment">//  &#125;</span></span><br><span class="line">          <span class="comment">// 如果不是服务端渲染的，或者混合失败，就创建一个空的注释节点替换 oldVnode</span></span><br><span class="line">          oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拿到 oldVnode 的父节点</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.<span class="property">elm</span></span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.<span class="title function_">parentNode</span>(oldElm)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据新的 vnode 创建一个 DOM 节点，挂载到父节点上</span></span><br><span class="line">        <span class="title function_">createElm</span>(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          oldElm.<span class="property">_leaveCb</span> ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.<span class="title function_">nextSibling</span>(oldElm)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果新的 vnode 的根节点存在，就是说根节点被修改了，就需要遍历更新父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">parent</span>)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.<span class="property">parent</span></span><br><span class="line">          <span class="keyword">const</span> patchable = <span class="title function_">isPatchable</span>(vnode)</span><br><span class="line">          <span class="comment">// 递归更新父节点下的元素</span></span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="comment">// 卸载老根节点下的全部组件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.<span class="property">destroy</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">              cbs.<span class="property">destroy</span>[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 替换现有元素</span></span><br><span class="line">            ancestor.<span class="property">elm</span> = vnode.<span class="property">elm</span></span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.<span class="property">create</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">                cbs.<span class="property">create</span>[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.<span class="property">data</span>.<span class="property">hook</span>.<span class="property">insert</span></span><br><span class="line">              <span class="keyword">if</span> (insert.<span class="property">merged</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.<span class="property">fns</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                  insert.<span class="property">fns</span>[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title function_">registerRef</span>(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新父节点</span></span><br><span class="line">            ancestor = ancestor.<span class="property">parent</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果旧节点还存在，就删掉旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(parentElm)) &#123;</span><br><span class="line">          <span class="title function_">removeVnodes</span>([oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">tag</span>)) &#123;</span><br><span class="line">          <span class="comment">// 否则直接卸载 oldVnode</span></span><br><span class="line">          <span class="title function_">invokeDestroyHook</span>(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回更新后的节点</span></span><br><span class="line">    <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="hV66y"></a></p>
<h3 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h3><p>就是用来判断节点是否相同，通过标签和key判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span> (a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;  <span class="comment">// key 是不是一样</span></span><br><span class="line">    a.<span class="property">asyncFactory</span> === b.<span class="property">asyncFactory</span> &amp;&amp; ( <span class="comment">// 是不是异步组件</span></span><br><span class="line">      (</span><br><span class="line">        a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp; <span class="comment">// 标签是不是一样</span></span><br><span class="line">        a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp; <span class="comment">// 是不是注释节点</span></span><br><span class="line">        <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp; <span class="comment">// 内容数据是不是一样</span></span><br><span class="line">        <span class="title function_">sameInputType</span>(a, b) <span class="comment">// 判断 input 的 type 是不是一样</span></span><br><span class="line">      ) || (</span><br><span class="line">        <span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp; <span class="comment">// 判断区分异步组件的占位符否存在</span></span><br><span class="line">        <span class="title function_">isUndef</span>(b.<span class="property">asyncFactory</span>.<span class="property">error</span>)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="ILyPk"></a></p>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p><strong>这个是在新的 vnode 和 oldVnode 是同一节点的情况下，才会执行的函数，主要是对比节点文本变化或子节点变化</strong><br>流程是这样的：</p>
<ul>
<li>如果 oldVnode 和 vnode 的引用地址是一样的，就表示节点没有变化，直接返回</li>
<li>如果 oldVnode 的 isAsyncPlaceholder 存在，就跳过异步组件的检查，直接返回</li>
<li>如果 oldVnode 和 vnode 都是静态节点，并且有一样的 key，并且 vnode 是克隆节点或者 v-once 指令控制的节点时，把 oldVnode.elm 和 oldVnode.child 都复制到 vnode 上，然后返回</li>
<li>如果 vnode 不是文本节点也不是注释的情况下<ul>
<li>如果 vnode 和 oldVnode 都有子节点，而且子节点不一样的话，就调用 updateChildren 更新子节点</li>
<li>如果只有 vnode 有子节点，就调用 addVnodes 创建子节点</li>
<li>如果只有 oldVnode 有子节点，就调用 removeVnodes 删除该子节点</li>
<li>如果 vnode 文本为 undefined，就删掉 vnode.elm 文本</li>
</ul>
</li>
<li>如果 vnode 是文本节点但是和 oldVnode 文本内容不一样，就更新文本</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (</span><br><span class="line">  oldVnode, <span class="comment">// 老的虚拟 DOM 节点</span></span><br><span class="line">  vnode, <span class="comment">// 新的虚拟 DOM 节点</span></span><br><span class="line">  insertedVnodeQueue, <span class="comment">// 插入节点的队列</span></span><br><span class="line">  ownerArray, <span class="comment">// 节点数组</span></span><br><span class="line">  index, <span class="comment">// 当前节点的下标</span></span><br><span class="line">  removeOnly <span class="comment">// 只有在</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 新老节点引用地址是一样的，直接返回</span></span><br><span class="line">  <span class="comment">// 比如 props 没有改变的时候，子组件就不做渲染，直接复用</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 新的 vnode 真实的 DOM 元素</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">elm</span>) &amp;&amp; <span class="title function_">isDef</span>(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// clone reused vnode</span></span><br><span class="line">    vnode = ownerArray[index] = <span class="title function_">cloneVNode</span>(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line">  <span class="comment">// 如果当前节点是注释或 v-if 的，或者是异步函数，就跳过检查异步组件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(oldVnode.<span class="property">isAsyncPlaceholder</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">asyncFactory</span>.<span class="property">resolved</span>)) &#123;</span><br><span class="line">      <span class="title function_">hydrate</span>(oldVnode.<span class="property">elm</span>, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.<span class="property">isAsyncPlaceholder</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点是静态节点的时候，key 也一样，或者有 v-once 的时候，就直接赋值返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">    <span class="title function_">isTrue</span>(oldVnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">    vnode.<span class="property">key</span> === oldVnode.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    (<span class="title function_">isTrue</span>(vnode.<span class="property">isCloned</span>) || <span class="title function_">isTrue</span>(vnode.<span class="property">isOnce</span>))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.<span class="property">componentInstance</span> = oldVnode.<span class="property">componentInstance</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// hook 相关的不用管</span></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">prepatch</span>)) &#123;</span><br><span class="line">    <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取子元素列表</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) &#123;</span><br><span class="line">    <span class="comment">// 遍历调用 update 更新 oldVnode 所有属性，比如 class,style,attrs,domProps,events...</span></span><br><span class="line">    <span class="comment">// 这里的 update 钩子函数是 vnode 本身的钩子函数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) cbs.<span class="property">update</span>[i](oldVnode, vnode)</span><br><span class="line">    <span class="comment">// 这里的 update 钩子函数是我们传过来的函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">update</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果新节点不是文本节点，也就是说有子节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果新老节点都有子节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果新老节点的子节点不一样，就执行 updateChildren 函数，对比子节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果新节点有子节点的话，就是说老节点没有子节点</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果老节点文本节点，就是说没有子节点，就清空</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="comment">// 添加子节点</span></span><br><span class="line">      <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果新节点没有子节点，老节点有子节点，就删除</span></span><br><span class="line">      <span class="title function_">removeVnodes</span>(oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">      <span class="comment">// 如果老节点是文本节点，就清空</span></span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">    <span class="comment">// 新老节点都是文本节点，且文本不一样，就更新文本</span></span><br><span class="line">    nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">    <span class="comment">// 执行 postpatch 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">postpatch</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a name="hMAzZ"></a></p>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p><strong>这个是新的 vnode 和 oldVnode 都有子节点，且子节点不一样的时候进行对比子节点的函数</strong><br>这里很关键，很关键！应该是vue2diff算法的核心<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366504873-9f69469f-3948-4da6-97b4-7dec09de8c7b.webp#averageHue=%23fbfbfb&clientId=ucaab1cbc-703a-4&from=paste&id=HNHIG&originHeight=423&originWidth=700&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufeffeed7-ae52-4a42-8dd6-88160c25e77&title="><br>在新老两组VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢，当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。<br>先进行以下4种情况的优化策略：</p>
<ul>
<li><strong>老数组的开始与新数组的开始：oldStartVnode, newStartVnode</strong></li>
<li><strong>老数组的结尾与新数组的结尾：oldEndVnode, newEndVnode</strong></li>
<li><strong>老数组的开始与新数组的结尾：oldStartVnode, newEndVnode</strong></li>
<li><strong>老数组的结尾与新数组的开始：oldEndVnode, newStartVnode</strong><br><a name="wCKct"></a></li>
</ul>
<h4 id="老数组的开始与新数组的开始"><a href="#老数组的开始与新数组的开始" class="headerlink" title="老数组的开始与新数组的开始"></a>老数组的开始与新数组的开始</h4><p><a name="OR3NZ"></a></p>
<h5 id="新数组的结尾节点有剩余则添加"><a href="#新数组的结尾节点有剩余则添加" class="headerlink" title="新数组的结尾节点有剩余则添加"></a><strong>新数组的结尾节点有剩余则添加</strong></h5><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366711308-50caf337-77aa-4efe-8d77-f339300205f1.webp#averageHue=%23f8f8f7&clientId=ucaab1cbc-703a-4&from=paste&id=udeaa8578&originHeight=378&originWidth=661&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u92e7126e-0328-4bd1-90e4-9f1db930da3&title="><br>从左往右比对完，老数组的游标先相交了，发现新数组结尾还有节点没有比对，则在新数组结尾创建剩下没有比对的节点。<br><a name="AYxOy"></a></p>
<h5 id="老数组的结尾节点有剩余则删除"><a href="#老数组的结尾节点有剩余则删除" class="headerlink" title="老数组的结尾节点有剩余则删除"></a><strong>老数组的结尾节点有剩余则删除</strong></h5><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366947781-1f4bb869-5c43-4152-9e8f-b0cce6e40ed0.webp#averageHue=%23f9f9f9&clientId=ucaab1cbc-703a-4&from=paste&id=udfe49980&originHeight=431&originWidth=593&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u7767f579-3ff0-4cab-9991-a088301cea2&title="><br>从左往右比对完，新数组的游标先相交了，发现老数组结尾还有节点没有比对，则删除老数组剩下没有比对的节点。<br><a name="bQtYI"></a></p>
<h4 id="老数组的结尾与新数组的结尾"><a href="#老数组的结尾与新数组的结尾" class="headerlink" title="老数组的结尾与新数组的结尾"></a>老数组的结尾与新数组的结尾</h4><p><a name="OxqLH"></a></p>
<h5 id="新数组的开头节点有剩余则添加"><a href="#新数组的开头节点有剩余则添加" class="headerlink" title="新数组的开头节点有剩余则添加"></a><strong>新数组的开头节点有剩余则添加</strong></h5><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711366988576-9c2a353b-1c15-4da7-b1c1-6f388c3d017d.webp#averageHue=%23f8f8f8&clientId=ucaab1cbc-703a-4&from=paste&id=ueb116dec&originHeight=381&originWidth=662&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u76959916-53fe-47b9-b30a-2fc21328320&title="><br><a name="JrTJa"></a></p>
<h5 id="老数组的开头节点有剩余则删除"><a href="#老数组的开头节点有剩余则删除" class="headerlink" title="老数组的开头节点有剩余则删除"></a><strong>老数组的开头节点有剩余则删除</strong></h5><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367012773-7d60f3be-2c54-4d89-9121-c29ceb67e507.webp#averageHue=%23f8f8f8&clientId=ucaab1cbc-703a-4&from=paste&id=ua396e169&originHeight=414&originWidth=676&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u34d040e9-457d-465d-8710-46bcf7b706a&title="><br>从右往左比对完，新数组的游标先相交了，发现老数组的开头还有节点没有比对，则删除老数组开头没有比对的节点。<br><a name="JRJhN"></a></p>
<h4 id="老数组的开始与新数组的结尾"><a href="#老数组的开始与新数组的结尾" class="headerlink" title="老数组的开始与新数组的结尾"></a>老数组的开始与新数组的结尾</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367196570-674d9870-487d-40c2-8e78-5d1b344a326c.webp#averageHue=%23faf6ec&clientId=ucaab1cbc-703a-4&from=paste&id=ua02f08a5&originHeight=429&originWidth=613&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ufc154651-e494-4b79-964d-8461c3d3351&title="><br>如果老数组的开头节点与新数组的结尾节点比对成功了，除了会继续递归比对它们，还将真实节点 A 移动到结尾。<br><a name="Z1ERS"></a></p>
<h4 id="老数组的结尾与新数组的开始"><a href="#老数组的结尾与新数组的开始" class="headerlink" title="老数组的结尾与新数组的开始"></a>老数组的结尾与新数组的开始</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367223091-a096cf79-0f47-418a-a3e1-11d10f149ae1.webp#averageHue=%23faf5ec&clientId=ucaab1cbc-703a-4&from=paste&id=u9fec563b&originHeight=416&originWidth=583&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc51df7f5-4f85-4f39-8540-0fa090cdf73&title="><br>如果老数组的结尾节点与新数组的开始节点比对成功了，除了会继续递归比对它们，还将真实节点D移动到开头。<br><a name="RmOEw"></a></p>
<h4 id="以上四种情况都没对比成功"><a href="#以上四种情况都没对比成功" class="headerlink" title="以上四种情况都没对比成功"></a>以上四种情况都没对比成功</h4><p>如果以上4种情况都没找到，则拿新数组的第一个节点去老数组中去查找。<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367523261-8fe78515-3c41-4f7e-a121-65d889d64523.webp#averageHue=%23f9f4ea&clientId=ucaab1cbc-703a-4&from=paste&id=u89fd8150&originHeight=410&originWidth=574&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u903abd0e-0f03-430d-a09f-fdc180b6579&title="><br>如果拿新数组的第一个节点去老数组中查找成功了，则会继续递归比对它们，同时将比对到的节点移动到对应的节点前面，并且将老数组原来的位置内容设置为 undefind。<br>注：这里 <strong>只有找到了旧节点并且新旧节点一样才会将旧节点数组中 idxInOld 中的元素置为 undefined</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/40732470/1711367567687-77ca73c4-95f9-4854-8a20-243a6bf7f79f.webp#averageHue=%23faf5ed&clientId=ucaab1cbc-703a-4&from=paste&id=u55c4f36b&originHeight=425&originWidth=642&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=uc6c7edf9-9cce-4962-9bb7-02d9159856f&title="><br> 如果拿新数组的第一个节点去老数组中查找，没找到，则创建一个新的节点<strong>插入到未处理的节点前面</strong>。</p>
<p>经过上面的处理之后，根据判断条件也不难看出，<strong>遍历结束之后 新旧节点数组都刚好没有剩余元素</strong> 是很难出现的，<strong>当且仅当遍历过程中每次新头尾节点总能和旧头尾节点中总能有两个新旧节点相同时才会发生</strong>，只要有一个节点发生改变或者顺序发生大幅调整，最后 <strong>都会有一个节点数组起始索引和末尾索引无法闭合</strong>。<br>那么此时就需要对剩余元素进行处理：</p>
<ul>
<li>旧节点数组遍历结束、新节点数组仍有剩余，则遍历新节点数组剩余数据，分别创建节点并插入到旧末尾索引对应节点之前</li>
<li>新节点数组遍历结束、旧节点数组仍有剩余，则遍历旧节点数组剩余数据，分别从节点数组和 dom 树中移除<br><a name="WRKxb"></a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue 2 的 diff 算法相对于简单 diff 算法来说，通过 <strong>双端对比与生成索引 map 两种方式</strong> 减少了简单算法中的多次循环操作，新旧数组均只需要进行一次遍历即可将所有节点进行对比。<br>其中双端对比会分别进行四次对比和移动，性能不算最优解，所以 Vue 3 中引入了 <strong>最长递增子序列</strong> 的方式来 <strong>替代双端对比</strong>，而其余部分则依然通过转为索引map 的形式利用空间扩展来减少时间复杂度，从而更高的提升计算性能。</p>
<br> 




<p><a name="jUFXC"></a></p>
<h4 id="-1"><a href="#-1" class="headerlink" title></a><br></h4><p><a name="a44lx"></a></p>
<h4 id="-2"><a href="#-2" class="headerlink" title></a><br></h4></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/vue3/">vue3</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/05/27/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CSRF-跨站请求伪造攻击</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/03/21/vue3-ts-%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86/"><span class="level-item">vue3+ts 样式处理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avator.jpg" alt="Enoch"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Enoch</p><p class="is-size-6 is-block">有形非易测，无源讵可量。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>chengdu-SiChuan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Enochbest" target="_blank" rel="noopener">Follow</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/Enochbest" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Git-hub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="2658929241@qq.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">E-mail</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/dart/"><span class="tag">dart</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/three/"><span class="tag">three</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uniapp/"><span class="tag">uniapp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue3/"><span class="tag">vue3</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"><span class="tag">区块链</span><span class="tag">10</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#认识虚拟-DOM"><span class="level-left"><span class="level-item">1</span><span class="level-item">认识虚拟 DOM</span></span></a></li><li><a class="level is-mobile" href="#Vue3快速diff算法"><span class="level-left"><span class="level-item">2</span><span class="level-item">Vue3快速diff算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#流程概述"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">流程概述</span></span></a></li><li><a class="level is-mobile" href="#对比详解"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">对比详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#patchChildren函数"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">patchChildren函数</span></span></a></li><li><a class="level is-mobile" href="#当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现</span></span></a></li><li><a class="level is-mobile" href="#patchUnkeyedChildren函数"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">patchUnkeyedChildren函数</span></span></a></li><li><a class="level is-mobile" href="#patchKeyedChildren函数"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">patchKeyedChildren函数</span></span></a></li><li><a class="level is-mobile" href="#如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。"><span class="level-left"><span class="level-item">2.2.5</span><span class="level-item">如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Vue2双端diff算法"><span class="level-left"><span class="level-item">3</span><span class="level-item">Vue2双端diff算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#patch"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">patch()</span></span></a></li><li><a class="level is-mobile" href="#sameVnode"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">sameVnode</span></span></a></li><li><a class="level is-mobile" href="#patchVnode"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">patchVnode</span></span></a></li><li><a class="level is-mobile" href="#updateChildren"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">updateChildren</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#老数组的开始与新数组的开始"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">老数组的开始与新数组的开始</span></span></a></li><li><a class="level is-mobile" href="#老数组的结尾与新数组的结尾"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">老数组的结尾与新数组的结尾</span></span></a></li><li><a class="level is-mobile" href="#老数组的开始与新数组的结尾"><span class="level-left"><span class="level-item">3.4.3</span><span class="level-item">老数组的开始与新数组的结尾</span></span></a></li><li><a class="level is-mobile" href="#老数组的结尾与新数组的开始"><span class="level-left"><span class="level-item">3.4.4</span><span class="level-item">老数组的结尾与新数组的开始</span></span></a></li><li><a class="level is-mobile" href="#以上四种情况都没对比成功"><span class="level-left"><span class="level-item">3.4.5</span><span class="level-item">以上四种情况都没对比成功</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#-1"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item"> </span></span></a></li><li><a class="level is-mobile" href="#-2"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item"> </span></span></a></li></ul></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Three-js%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">Three.js学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/dart%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">dart学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/react/"><span class="level-start"><span class="level-item">react</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/uniapp/"><span class="level-start"><span class="level-item">uniapp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/vue3/"><span class="level-start"><span class="level-item">vue3</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">前端安全</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">区块链基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">区块链系统实现</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">浏览器原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-14T06:27:20.000Z">2024-03-14</time></p><p class="title"><a href="/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/">vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法</a></p><p class="categories"><a href="/categories/vue3/">vue3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:52:35.000Z">2023-12-26</time></p><p class="title"><a href="/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/">初识着色器(包括着色器传参)</a></p><p class="categories"><a href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-25T05:50:41.000Z">2023-12-25</time></p><p class="title"><a href="/2023/12/25/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%8E%9F%E7%90%86/">渲染管线原理</a></p><p class="categories"><a href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-09T12:12:41.000Z">2023-09-09</time></p><p class="title"><a href="/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/">IM发送表情（基于quill富文本编辑器）</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-07T12:42:20.000Z">2023-09-07</time></p><p class="title"><a href="/2023/09/07/%E5%9C%A8Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/">在Vue3中使用quill富文本编辑器</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">March 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/avator.jpg" alt="Enoch&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Enoch</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>