<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>初识着色器(包括着色器传参) - Enoch&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Enoch&#039;s Blog"><meta name="msapplication-TileImage" content="/images/avator.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Enoch&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="摘要本文内容主要介绍 Three.js 中的着色器知识，通过讲解什么是着色器、着色器的分类、GLSL 语言的核心语法要点、Three.js 中的两种着色器材质的 RawShaderMaterial 和 ShaderMaterial 的区别和用法等基本知识，深入理解着色器，并使用它创建出有趣的三维图形。 效果随着本文内容一步步深入，最终将使用着色器构建一个如下所示的波动旗帜 🚩 效果，通过滑"><meta property="og:type" content="blog"><meta property="og:title" content="Enoch&#039;s Blog"><meta property="og:url" content="http://example.com/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/"><meta property="og:site_name" content="Enoch&#039;s Blog"><meta property="og:description" content="摘要本文内容主要介绍 Three.js 中的着色器知识，通过讲解什么是着色器、着色器的分类、GLSL 语言的核心语法要点、Three.js 中的两种着色器材质的 RawShaderMaterial 和 ShaderMaterial 的区别和用法等基本知识，深入理解着色器，并使用它创建出有趣的三维图形。 效果随着本文内容一步步深入，最终将使用着色器构建一个如下所示的波动旗帜 🚩 效果，通过滑"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045193-b8e161ee-bc17-4aea-8963-1c1545e83d8c.webp#clientId=uea1e22cc-b254-4&amp;from=paste&amp;id=udfbb4a20&amp;originHeight=865&amp;originWidth=1376&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua09959eb-0c6b-46e0-a978-31c9d61278e&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562044943-77e5183f-7336-4fa9-9a62-a2e6ba9a3a1d.webp#averageHue=%23a6958c&amp;clientId=uea1e22cc-b254-4&amp;from=paste&amp;id=u8384a639&amp;originHeight=394&amp;originWidth=512&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3186b75c-09d7-4227-9829-2abd84067da&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045030-f2c429ba-6d26-4e09-9256-6293df9ca073.webp#averageHue=%233c0100&amp;clientId=uea1e22cc-b254-4&amp;from=paste&amp;id=u03d39f3b&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6364ca47-8103-4f6a-aa89-b26d4a41e8a&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562044980-355b4055-727b-454a-9197-fd3feb820925.webp#averageHue=%233c0100&amp;clientId=uea1e22cc-b254-4&amp;from=paste&amp;id=u77d1bffb&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua00bc5dc-94a9-480c-8b76-57a5baf936f&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703573865903-9b56721f-11bd-4708-8c9c-cd68712d8bf1.webp#averageHue=%23060000&amp;clientId=uea1e22cc-b254-4&amp;from=paste&amp;id=ucdeb0424&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5a276834-01ac-4300-9b36-401eb9952b3&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576267876-e3e36258-3457-43aa-9f23-7fe0f6ba7cbe.webp#averageHue=%23120000&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=uabbd3774&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c162ef7-0e72-4424-a908-33d181371b3&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576298541-cf9f547a-8704-42de-880a-4eed725ac7b1.webp#averageHue=%233e0100&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u28c773ae&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue9f2b6b8-afbe-4470-b4ff-496d15d6254&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576734744-fffc09a5-dfe1-40f9-ae9f-83d4ff97e200.webp#averageHue=%23010200&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=ufba13080&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u23564775-9a16-4f7f-bb8b-1cc393d1afb&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577180914-4240b40c-cc5c-4e5f-a521-ecd8212ad273.webp#averageHue=%23010200&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=uc2c027d8&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue34fb9fa-f157-4423-b062-dd5cb4f0e13&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577237286-5a0b6f92-14f2-4de8-bd5a-d7edbfbae6a3.webp#averageHue=%23020200&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u48f19863&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u38cfc988-ab24-4ac4-9a8c-9c31a587170&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577414544-0ae79204-fb4e-4bab-bbca-53611fada084.webp#averageHue=%23010200&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u40aa8a49&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc2ef55af-fed7-4966-8036-f6af2b24c8f&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577509047-b365cdc7-61fb-4b1d-a679-33d611828dc8.webp#averageHue=%23020200&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u4963fec8&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud7769660-9675-48c9-8293-3e639c4e764&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577591182-7d100dd3-841d-4f75-972b-0a64e7feb603.webp#clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u2e5b1888&amp;originHeight=945&amp;originWidth=1512&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8000f8c6-4642-4761-9c42-b4cbe2d21fd&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577616202-0c052bd5-3ef8-4877-9530-ff811e7084b1.webp#clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u9b59e523&amp;originHeight=945&amp;originWidth=1512&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf646fb78-fa63-49d9-b4da-7b54e427133&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577671636-91fd4308-d731-43c7-97f1-cf3ba98615cf.webp#clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=uc2ce14e2&amp;originHeight=945&amp;originWidth=1512&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0a76e568-86e2-4187-a352-0ee5fdaa2c0&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577716145-cf954f5e-a81f-49f6-b9f2-514957877e29.webp#averageHue=%23271900&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=udf19aaa2&amp;originHeight=750&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u118ba5ba-7c0c-4f8e-b8c0-e228c945d38&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577861026-96a69468-e1f3-4d49-b8aa-48ebe2d45da9.webp#averageHue=%231a1108&amp;clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u7f4f2384&amp;originHeight=829&amp;originWidth=1200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3af20e4a-f957-4753-ac23-f129725678d&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577926006-88ad5209-6df1-466d-9eb7-3db2d9b41c23.webp#clientId=u30fc2202-5c6f-4&amp;from=paste&amp;id=u16ff335e&amp;originHeight=884&amp;originWidth=1279&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u098185b6-684f-4c3a-bafe-1eaadb8d2c3&amp;title="><meta property="article:published_time" content="2023-12-26T05:52:35.000Z"><meta property="article:modified_time" content="2024-05-27T05:56:05.912Z"><meta property="article:author" content="Enoch"><meta property="article:tag" content="three"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045193-b8e161ee-bc17-4aea-8963-1c1545e83d8c.webp#clientId=uea1e22cc-b254-4&amp;from=paste&amp;id=udfbb4a20&amp;originHeight=865&amp;originWidth=1376&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua09959eb-0c6b-46e0-a978-31c9d61278e&amp;title="><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"blog"},"headline":"初识着色器(包括着色器传参)","image":[],"datePublished":"2023-12-26T05:52:35.000Z","dateModified":"2024-05-27T05:56:05.912Z","author":{"@type":"Person","name":"Enoch"},"publisher":{"@type":"Organization","name":"Enoch's Blog","logo":{"@type":"ImageObject","url":"/images/avator.jpg"}},"description":"摘要本文内容主要介绍 Three.js 中的着色器知识，通过讲解什么是着色器、着色器的分类、GLSL 语言的核心语法要点、Three.js 中的两种着色器材质的 RawShaderMaterial 和 ShaderMaterial 的区别和用法等基本知识，深入理解着色器，并使用它创建出有趣的三维图形。 效果随着本文内容一步步深入，最终将使用着色器构建一个如下所示的波动旗帜 🚩 效果，通过滑"}</script><link rel="canonical" href="http://example.com/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/"><link rel="icon" href="/images/avator.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/avator.jpg" alt="Enoch&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-26T05:52:35.000Z" title="2023/12/26 13:52:35">2023-12-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T05:56:05.912Z" title="2024/5/27 13:56:05">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></span><span class="level-item">an hour read (About 8271 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">初识着色器(包括着色器传参)</h1><div class="content"><meta name="referrer" content="no-referrer">

<p><a name="uAQeQ"></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文内容主要介绍 Three.js 中的着色器知识，通过讲解什么是着色器、着色器的分类、GLSL 语言的核心语法要点、Three.js 中的两种着色器材质的 <code>RawShaderMaterial </code>和 <code>ShaderMaterial</code> 的区别和用法等基本知识，深入理解着色器，并使用它创建出有趣的三维图形。<br><a name="nFwCe"></a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>随着本文内容一步步深入，最终将使用着色器构建一个如下所示的波动旗帜 🚩 效果，通过滑动调整页面右上方的 dat.GUI 控制器，可以调整 x轴 和 y轴 上的波动幅度。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045193-b8e161ee-bc17-4aea-8963-1c1545e83d8c.webp#clientId=uea1e22cc-b254-4&from=paste&id=udfbb4a20&originHeight=865&originWidth=1376&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua09959eb-0c6b-46e0-a978-31c9d61278e&title="></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a name="brCFE"></a></p>
<h3 id="Shader着色器简介"><a href="#Shader着色器简介" class="headerlink" title="Shader着色器简介"></a>Shader着色器简介</h3><p>着色器是 WebGL 的重要组件之一，它是一种使用 GLSL 语言编写的运行在 GPU 上的程序。顾名思义，着色器用于定位几何体的每个顶点，并为几何体的每个可见像素进行着色 🎨。着色器是屏幕上呈现画面之前的最后一步，用它可以实现对先前渲染结果进行修改，如颜色、位置等，也可以对先前渲染的结果做后处理，实现高级的渲染效果。<br>例如，对于相同场景、相同光照、相同模型等条件下，对这个模型分别使用不同的着色器，就会呈现出完全不同的渲染效果：使用 plastic shader 的模型渲染出塑料质感，而使用了 toon shader 的模型则看起来是二维卡通效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562044943-77e5183f-7336-4fa9-9a62-a2e6ba9a3a1d.webp#averageHue=%23a6958c&clientId=uea1e22cc-b254-4&from=paste&id=u8384a639&originHeight=394&originWidth=512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3186b75c-09d7-4227-9829-2abd84067da&title="><br><a name="lUqpl"></a></p>
<h3 id="为什么要使用着色器"><a href="#为什么要使用着色器" class="headerlink" title="为什么要使用着色器"></a>为什么要使用着色器</h3><p>虽然 Three.js 已经内置了非常多的材质，但是在实际开发中很难满足我们的需求，比如在数字孪生系统的开发中，我们经常需要添加一些炫酷的<strong>飞线效果</strong>、<strong>雷达效果</strong>等 ✨，它们是无法直接使用 Three.js 来生成，此时就需要我们创建自己的着色器。而且出于性能的考虑，我们也可以使用自己的着色器材质代替像 MeshStandardMaterial 这样的材质非常精细涉及大量代码和计算的材质，以便于提升页面性能。<br><a name="jvXE0"></a></p>
<h3 id="着色器的类型"><a href="#着色器的类型" class="headerlink" title="着色器的类型"></a>着色器的类型</h3><p><a name="IXyNh"></a></p>
<h4 id="顶点着色器Vertex-Shader"><a href="#顶点着色器Vertex-Shader" class="headerlink" title="顶点着色器Vertex Shader"></a>顶点着色器Vertex Shader</h4><p>Vertex Shader 用于定位几何体的顶点，它的工作原理是发送顶点位置、网格变换（<code>position</code>、旋<code>rotation</code>和 scale 等）、摄像机信息（<code>position</code>、<code>rotation</code>、<code>fov</code> 等）。GPU 将按照 Vertex Shader 中的指令处理这些信息，然后将顶点投影到 2D 空间中渲染成 Canvas。<br>当使用 Vertex Shader 时，它的代码将作用于几何体的每个顶点。在每个顶点之间，有些数据会发生变化，这类数据称为 attribute；有些数据在顶点之间永远不会变化，称这种数据为 uniform。Vertex Shader 会首先触发，当顶点被放置，GPU 知道几何体的哪些像素可见，然后执行 Fragment Shader。</p>
<ul>
<li>attribute：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点的位置。</li>
<li>uniform：顶点着色器使用的常量数据，不能被修改，一般用于对同一组顶点组成的单个 3D 物体中所有顶点都相同的变量，如当前光源的位置。</li>
<li>varying: 从顶点着色器发送到片元着色器中的插值计算数据<br><a name="JTUTh"></a></li>
</ul>
<h4 id="片元着色器Fragment-Shader"><a href="#片元着色器Fragment-Shader" class="headerlink" title="片元着色器Fragment Shader"></a>片元着色器Fragment Shader</h4><p>Fragment Shader 在 Vertex Shader 之后执行，它的作用是为几何体的每个可见像素进行着色。我们可以通过uniforms 将数据发送给它，也可以将 Vertex Shader 中的数据发送给它，我们将这种从 Vertex Shader 发送到 Fragment Shader 的数据称为 varying。<br>Fragment Shader 中最直接的指令就是可以使用相同的颜色为所有像素进行着色。如果只设置了颜色属性，就相当于得到了与 MeshBasicMaterial 等价的材质。如果我们将光照的位置发送给 Fragment Shader，然后根据像素收到光照影响的多少来给像素上色，此时就能得到与 MeshPhongMaterial 效果等价的材质。</p>
<p>📌 以下内容示例流程翻译、并整理于<a href="https://link.juejin.cn/?target=https://threejs-journey.com/">《three.js journey》</a> shader 相关课程，如果对英文原版感兴趣可前往查看。<br><a name="w8DRq"></a></p>
<h3 id="原始着色器材质RawShaderMaterial"><a href="#原始着色器材质RawShaderMaterial" class="headerlink" title="原始着色器材质RawShaderMaterial"></a>原始着色器材质RawShaderMaterial</h3><p>在 Three.js 中可以渲染着色器的材质有两种：RawShaderMaterial 和 ShaderMaterial，它们之间的区别是 ShaderMaterial 会自动将一些初始化着色器的参数添加到代码中（内置 attributes 和 uniforms），而 RawShaderMaterial 则什么都不会添加。<br>我们先来看看如何使用 RawShaderMaterial 材质，首先我们创建一个平面，然后和创建其他材质一样，通过 new THREE.RawShaderMaterial 初始化原始着色器材质，并给它添加两个参数 vertexShader 和 fragmentShader 代表材质的<strong>顶点着色器</strong>和<strong>片元着色器</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">    vertexShader: &#x27;&#x27;,</span><br><span class="line">    fragmentShader: &#x27;&#x27;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>然后开始编写材质的顶点着色器和片元着色器，分别添加如下的代码。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">    vertexShader: `</span><br><span class="line">      <span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line">    <span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line">    <span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main() &#123;</span><br><span class="line">      <span class="built_in">gl_Position</span> = projectionMatrix * viewMatrix * modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    `,</span><br><span class="line">    fragmentShader: `</span><br><span class="line">      <span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()&#123;</span><br><span class="line">      <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    `</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>此时可以得到一个<strong>红色</strong>的平面，说明我们编写的第一个着色器运行成功了 🎉。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045030-f2c429ba-6d26-4e09-9256-6293df9ca073.webp#averageHue=%233c0100&clientId=uea1e22cc-b254-4&from=paste&id=u03d39f3b&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6364ca47-8103-4f6a-aa89-b26d4a41e8a&title="><br><a name="Gmylm"></a></p>
<h4 id="分离两种着色器"><a href="#分离两种着色器" class="headerlink" title="分离两种着色器"></a>分离两种着色器</h4><p>在实际开发中，着色器比较复杂，代码量比较多，如果直接放在材质中的话会增加代码阅读困难量。我们可以将着色器代码单独拆分出来，分别存放在 vertex.glsl 和 fragment.glsl 文件中，然后在代码中像下面这样引入即可。这样做还有一个好处就是可以安装代码编辑器的 GLSL 高亮语法插件，提高编程效率。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import testVertexShader from &#x27;./shaders/test/vertex.glsl&#x27;;</span><br><span class="line">import testFragmentShader from &#x27;./shaders/test/fragment.glsl&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>此时查看页面，得到的结果还是一样的。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562044980-355b4055-727b-454a-9197-fd3feb820925.webp#averageHue=%233c0100&clientId=uea1e22cc-b254-4&from=paste&id=u77d1bffb&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua00bc5dc-94a9-480c-8b76-57a5baf936f&title="><br><a name="rhtB5"></a></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>材质的一些通用属性在 RawShaderMaterial 同样是适用的，比如 wireframe、side、transparent、flatShading 等都可以生效，对上面材质开启 wireframe 属性，可以得到如下图所示的平面的网格模型。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">    vertexShader: testVertexShader,</span><br><span class="line">    fragmentShader: testFragmentShader,</span><br><span class="line">    wireframe: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703573865903-9b56721f-11bd-4708-8c9c-cd68712d8bf1.webp#averageHue=%23060000&clientId=uea1e22cc-b254-4&from=paste&id=ucdeb0424&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a276834-01ac-4300-9b36-401eb9952b3&title="><br>:::danger<br>但是需要注意的是，像map、alphaMap、opacity、color等属性在着色器材质中会失效，我们需要在着色器代码中自己实现<br>:::<br><a name="u3ee8"></a></p>
<h3 id="GLSL-语言"><a href="#GLSL-语言" class="headerlink" title="GLSL 语言"></a>GLSL 语言</h3><p>在 Three.js 中，需要使用 GLSL 语言来编写着色器，全称是 OpenGL Shading Language，意为 OpenGL 中的着色语言。它的语法类似于 C语言，在开始编写着色器之前，我们先了解一些它的基本语法。</p>
<ul>
<li><strong>日志</strong>：由于着色器语言是针对每个顶点和每个片元执行的，日志记录是没有意义的，因此编写 GLSL 时没有控制台。</li>
<li><strong>缩进</strong>：代码缩进格式<strong>没有严格要求</strong>，只要易读美观就行。</li>
<li><strong>分号</strong>：和 C语言 一样，编写 GLSL 语言时，任何指令的结尾都<strong>必须添加分号</strong>，丢失分号就会导致代码无法运行。</li>
<li><strong>类型</strong>：和 C语言 一样， GLSL 是一种强类型语言，<strong>不同类型的变量不能混用</strong>，否则会报错。<br><a name="umqxA"></a></li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 GLSL 中有很多变量类型，编写着色器时，我们需要根据需要选择合适类型的变量。<br><a name="kFzE4"></a></p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p>用以定义整数。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> bar = - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><a name="ZfJz7"></a></p>
<h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><p>浮点数就是小数，可以是正数也可以是负数，必须提供小数点 .。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> foo = - <span class="number">0.123</span>;</span><br><span class="line"><span class="type">float</span> bar = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<p><a name="DkFs8"></a></p>
<h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>用于表示值得真假。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> bar = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><a name="eZIpZ"></a></p>
<h5 id="二维向量vec2"><a href="#二维向量vec2" class="headerlink" title="二维向量vec2"></a>二维向量vec2</h5><p>如果我们需要存储具有 x 和 y 属性这样具有2个坐标的值时，可以使用 vec2。需要注意的是，直接使用 vec2 foo &#x3D; vec2() 这样未添加参数的空值会报错，应该像下面这样提供完整的参数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> foo = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>创建 vec2 后修改属性值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> foo = <span class="type">vec2</span>(<span class="number">0.0</span>);</span><br><span class="line">foo.x = <span class="number">1.0</span>;</span><br><span class="line">foo.y = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>

<p>进行浮点数与 vec2 相乘等操作运算时，结果将同时作用于 x 和 y：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec2 foo = vec2(1.0, 2.0);</span><br><span class="line">foo *= 2.0;</span><br></pre></td></tr></table></figure>

<p><a name="KZCzY"></a></p>
<h5 id="三维向量vec3"><a href="#三维向量vec3" class="headerlink" title="三维向量vec3"></a>三维向量vec3</h5><p>与 vec2 类似，vec3 用于表示具有 x、y、z 三个坐标的值，可以用它非常方便的表示<strong>三维空间坐标</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> foo = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> bar = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">bar.z = <span class="number">4.0</span>;</span><br></pre></td></tr></table></figure>

<p>RGB 颜色也同样适合使用 vec3 表示：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">color.r = <span class="number">0.5</span>;</span><br><span class="line">color.b = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用 vec2 来创建 vec3：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> foo = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="type">vec3</span> bar = <span class="type">vec3</span>(foo, <span class="number">3.0</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用 vec3 来创建 vec2，其中 bar 的值为 1.0, 2.0，baz 的 值为 2.0, 1.0：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> foo = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line"><span class="type">vec2</span> bar = foo.xy;</span><br><span class="line"><span class="type">vec2</span> baz = foo.yx;</span><br></pre></td></tr></table></figure>

<p><a name="xjaUz"></a></p>
<h5 id="四维向量vec4"><a href="#四维向量vec4" class="headerlink" title="四维向量vec4"></a>四维向量vec4</h5><p>与前面几个类似，vec4 用于表示四维向量，四个值命名为 x, y, z, w 或 r, g, b, a，向量之间同样能进行相互转换：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> foo = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line"><span class="type">vec4</span> bar = <span class="type">vec4</span>(foo.zw, <span class="type">vec2</span>(<span class="number">5.0</span>, <span class="number">6.0</span>));</span><br></pre></td></tr></table></figure>

<p>除上述之外，还有一些其它类型的变量，如 mat2、mat3、mat4、sampler2D 等将在后续学习中介绍。</p>
<ul>
<li>在着色器内，一般命名以 gl_ 开头的变量是着色器的内置变量。</li>
<li>webgl_ 和 <em>webgl 是着色器保留字，自定义变量不能以 webgl</em> 或 _webgl 开头。</li>
<li>变量声明一般包含 &lt;存储限定符&gt; &lt;数据类型&gt; &lt;变量名称&gt;，以 attribute vec4 a_Position 为例，attribute 表示存储限定符，vec 是数据类型，a_Position 为变量名。<br><a name="Y5HZ3"></a></li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 GLSL 中定义函数，必须以返回值的类型开头，如果没有返回值，则可以使用 void。定义函数的参数时，也必须提供参数类型。<br>在 GLSL 中定义函数，必须以返回值的类型开头，如果没有返回值，则可以使用 void。定义函数的参数时，也必须提供参数类型。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line"><span class="type">float</span> loremIpsum() &#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="type">void</span> justDoingStuff() &#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义参数类型</span></span><br><span class="line"><span class="type">float</span> add(<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="fEi1i"></a></p>
<h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><p>GLSL 内置了很多使用的函数，下面列举了一些比较常用的：</p>
<ul>
<li><strong>运算函数</strong><ul>
<li>abs(x)：取 x 的绝对值</li>
<li>radians(x)：角度转弧度</li>
<li>degrees(x)：弧度转角度</li>
<li>sin(x)：正弦函数，传入值为弧度。还有 cos 余弦函数、tan 正切函数、asin 反正弦、acos反余弦、atan 反正切等</li>
<li>pow(x,y)：x^y</li>
<li>exp(x)：e^x</li>
<li>exp2(x)：2^x</li>
<li>log(x)：logex</li>
<li>log2(x)：log2x</li>
<li>sqrt(x)：x√</li>
<li>inversesqr(x)：1x√</li>
<li>sign(x)：x&gt;0 返回 1.0，x&lt;0 返回 -1.0，否则返回 0.0</li>
<li>ceil(x)：返回大于或者等于 x 的整数</li>
<li>floor(x)：返回小于或者等于 x 的整数</li>
<li>fract(x)：返回 x-floor(x) 的值</li>
<li>mod(x,y)：取模求余数</li>
<li>min(x,y)：获取 x、y 中小的那个</li>
<li>max(x,y)：获取 x、y 中大的那个</li>
<li>mix(x,y,a)：返回 x∗(1−a)+y∗a</li>
<li>step(x,a)：x&lt;a返回 0.0，否则返回 1.0。</li>
<li>smoothstep(x,y,a)：a&lt;x 返回 0.0，a&gt;y 返回 1.0，否则返回 0.0-1.0 之间平滑的 Hermite 插值。</li>
<li>dFdx(p)：p 在 x 方向上的偏导数</li>
<li>dFdy(p)：p 在 y 方向上的偏导数</li>
<li>fwidth(p)：p 在 x 和 y 方向上的偏导数的绝对值之和</li>
</ul>
</li>
<li>**几何函数 **<ul>
<li>length(x)：计算向量 x 的长度</li>
<li>distance(x, y)：返回向量 xy 之间的距离</li>
<li>dot(x,y)：返回向量 xy 的点积</li>
<li>cross(x,y)：返回向量 xy 的差积</li>
<li>normalize(x)：返回与 x 向量方向相同，长度为 1 的向量</li>
</ul>
</li>
<li><strong>矩阵函数</strong><ul>
<li>matrixCompMult(x,y)：将矩阵相乘</li>
<li>lessThan(x,y)：返回向量 xy 的各个分量执行 x&lt;y 的结果</li>
<li>lessThanEqual(x,y)：返回向量 xy 的各个分量执行 x&lt;&#x3D;y 的结果，类似的有类似的有 greaterThanEqual</li>
<li>any(bvec x)：x 有一个元素为 true，则为 true</li>
<li>all(bvec x)：x 所有元素为 true，则返回 true，否则返回 false</li>
<li>not(bvec x)：x 所有分量执行逻辑非运算<br>:::success<br>如果想了解更多GLSL的内置函数，可以到这个网站查询：<a href="https://link.juejin.cn/?target=https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/indexflat.php">Kronos Group OpenGL reference pages</a><br>:::<br><a name="vaV7r"></a></li>
</ul>
</li>
</ul>
<h3 id="理解顶点着色器Vertex-Shader"><a href="#理解顶点着色器Vertex-Shader" class="headerlink" title="理解顶点着色器Vertex Shader"></a>理解顶点着色器Vertex Shader</h3><p>接下来讲解着色器里代码的具体内容。<br><strong>顶点着色器</strong>的作用是将几何体的每个顶点放置在 2D 渲染空间上，即顶点着色器将 3D 顶点坐标转换为 2D canvas 坐标。<br>main函数<br>它将被自动调用，并且不会返回任何内容。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><a name="cgIWe"></a></p>
<h4 id="gl-Position"><a href="#gl-Position" class="headerlink" title="gl_Position"></a>gl_Position</h4><p>gl_Position 是一个内置变量，我们只需要给它重新赋值就能使用，它将会包含屏幕上的顶点的位置。下面 main 函数中就是用于给它设置合适的值。执行这段指令后，将得到一个 vec4，意味着我们可以直接在 gl_Position 变量上使用其x、y、z 和 w 属性。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = projectionMatrix * viewMatrix * modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  <span class="built_in">gl_Position</span>.x += <span class="number">0.5</span>;</span><br><span class="line">  <span class="built_in">gl_Position</span>.y += <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br>平面向右上角发生了位移，但是需要注意的是，我们并没有像在 Three.js 中一样将平面在三维空间中进行了移动，我们只是在二维空间中移动了平面的投影。就像你在桌子上画了一幅具有透视效果的画，然后把它向桌子右上角移动，但是你的画中的透视效果并没有发生变化。<br>gl_Position 的作用是在 2D 空间上定位 📍 顶点，既然是 2D 空间，为什么需要使用一个四维向量表示呢？实际上是这些坐标并不是精确的在 2D 空间，而是位于被称为 Clip Space 需要四个维度的<strong>裁切空间</strong>。裁切空间是指在 -1 到 +1 范围内所有 x、y、z 3个方向上的空间，第四个值 w 用于表示透视。就像把所有东西都放在 3D 盒子中一样，任何超出范围的内容都将被裁切。gl_Position 这些内容的这些内容都是自动完成的，我们只需明白其大概原理即可。<br><a name="Ix3An"></a></p>
<h4 id="位置属性Position-attributes"><a href="#位置属性Position-attributes" class="headerlink" title="位置属性Position attributes"></a>位置属性Position attributes</h4><p>相同的代码将应用于几何体的每一个顶点，属性变量 attribute 是在顶点之间唯一会发生改变的变量。相同的顶点着色器 Vertex Shader 将应用于每一个顶点，position 属性将包含具体顶点的 x, y, z 坐标值。我们可以使用如下代码获取顶点位置：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br>因为 gl_Position 是 vec4 类型，可以使用以下方法将 vec3 转化成 vec4：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = <span class="comment">/* ... */</span> <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="HtiRR"></a></p>
<h4 id="矩阵限定变量Matrices-uniforms"><a href="#矩阵限定变量Matrices-uniforms" class="headerlink" title="矩阵限定变量Matrices uniforms"></a>矩阵限定变量Matrices uniforms</h4><p>每个矩阵将转换 position，直到我们获得最终的裁切空间坐标。下面是 3 个矩阵，因为在几何体所有顶点中它们的值都是相同的，我们可以通过 uniform 来获取它们。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br></pre></td></tr></table></figure>

<p><br>下面将对每个矩阵做出一些变换：</p>
<ul>
<li>modelMatrix：将进行网格相关的变换，如缩放、旋转、移动等操作变换都将作用于 position。</li>
<li>viewMatrix：将进行相机相关的变换，如我们向左移动相机，顶点应该在右边、如果我们朝着网格方向移动相机，顶点会变大等。</li>
<li>projectionMatrix：会将我们的坐标转化为裁切空间坐标。</li>
</ul>
<p>为了使用矩阵，我们需要将其相乘，如果想让一个 mat4 作为变量，则该变量类型必须是 vec4。我们也可以将多个矩阵相乘：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = projectionMatrix * viewMatrix * modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上还可以使用更短的写法来让 viewMatrix 和 modelMatrix 组合成一个 projectionMatrix，虽然代码少了，但我们可控制的步骤也少了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = projectionMatrix * modelViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际中我们会选择更长的写法，以便于更好地理解及对 position 进行更多的控制。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  <span class="type">vec4</span> viewPosition = viewMatrix * modelPosition;</span><br><span class="line">  <span class="type">vec4</span> projectedPosition = projectionMatrix * viewPosition;~~~~</span><br><span class="line">  <span class="built_in">gl_Position</span> = projectedPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面两种写法都是等价的，使用下面这种时，我们可以更方便地进行控制，比如可以通过调整 modelPosition 的值来对整个模型进行移动，通过以下代码，就能向上移动模型：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  modelPosition.y += <span class="number">1.0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576267876-e3e36258-3457-43aa-9f23-7fe0f6ba7cbe.webp#averageHue=%23120000&clientId=u30fc2202-5c6f-4&from=paste&id=uabbd3774&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c162ef7-0e72-4424-a908-33d181371b3&title="><br>我们还可以做一些更有趣的操作，比如将平面变换为<strong>波浪形状</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * <span class="number">10.0</span>) * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576298541-cf9f547a-8704-42de-880a-4eed725ac7b1.webp#averageHue=%233e0100&clientId=u30fc2202-5c6f-4&from=paste&id=u28c773ae&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue9f2b6b8-afbe-4470-b4ff-496d15d6254&title="></p>
<p><a name="TU4mH"></a></p>
<h3 id="理解片元着色器Fragment-Shader"><a href="#理解片元着色器Fragment-Shader" class="headerlink" title="理解片元着色器Fragment Shader"></a>理解片元着色器Fragment Shader</h3><p><strong>片元着色器</strong>的代码将应用于几何体的每个可见像素，这就是片元着色器在顶点着色器之后运行的原因，它的代码比顶点着色器更易于管理。<br><a name="zSt4H"></a></p>
<h4 id="主函数main"><a href="#主函数main" class="headerlink" title="主函数main"></a>主函数main</h4><p>同样，片元着色器中也有一个主函数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="jMvtk"></a></p>
<h4 id="精度Precision"><a href="#精度Precision" class="headerlink" title="精度Precision"></a>精度Precision</h4><p>在顶部有一条这样的指令，我们用它来决定浮点数的精度，有以下几种值供选择：</p>
<ul>
<li>highp：会影响性能，在有些机器上可能无法运行；</li>
<li>mediump：常用的类型；</li>
<li>lowp：可能会由于精度问题产生错误。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在示例使用的是 RawShaderMaterial 原始着色器材质才需要设置精度，在着色器材质 ShaderMaterial中会自动处理。</p>
<blockquote>
<p>在顶点着色器中也可以是指精度，但是这是非必须的。</p>
</blockquote>
<p><a name="DbTlz"></a></p>
<h4 id="gl-FragColor"><a href="#gl-FragColor" class="headerlink" title="gl_FragColor"></a>gl_FragColor</h4><p>gl_FragColor 和 gl_Position 类似，但它用于颜色。它也一样是已经被内置声明了的，我们只需要在main 函数中重新给它赋值。它是一个 vec4，前三个值是红色、绿色、蓝色通道 (r, g, b)，第四个值是透明度 alpha (a)。gl_FragColor 的每个值的取值范围是 0.0 到 1.0，如果我们设置的值高于它们，也不会产生报错。<br>下面这段代码将生成一个<strong>紫色</strong>的几何体</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576734744-fffc09a5-dfe1-40f9-ae9f-83d4ff97e200.webp#averageHue=%23010200&clientId=u30fc2202-5c6f-4&from=paste&id=ufba13080&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23564775-9a16-4f7f-bb8b-1cc393d1afb&title="><br>为了 alpha 透明度值可以生效，我们需要在材质中将 transparent 属性设置为 true：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  transparent: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="SB3W6"></a></p>
<h3 id="属性Attributes"><a href="#属性Attributes" class="headerlink" title="属性Attributes"></a>属性Attributes</h3><p>Attributes 是每个顶点之间变化的值，我们之前已经有一个命名为 position 的属性变量，它是每个顶点在坐标轴中的 vec3 值。我们将为每个顶点添加一个随机值，并根据这个值在 z 轴上移动该顶点。在 JavaScript 代码中我们可以像下面这个直接给 BufferGeometry 添加 attribute 属性。然后再创建一个 32位 的浮点类型数组 Float32Array，为了知道几何体中有多少个顶点，现在可以通过 attributes 属性获取。最后在 BufferAttribute 中使用该数组，并将它添加到几何体的属性中。</p>
<ul>
<li>setAttribute：第一个参数是需要设置的 attribute <strong>属性名称</strong>，然后在着色器中可以使用该名字，属性名命名时最好加一个 a 前缀方便区分。</li>
<li>BufferAttribute：第一个参数是<strong>数据数组</strong>；第二个参数表示组成一个属性的值的数量，如我们要发送一个 (x, y, z) 构成位置，则需要使用 3，示例中每个顶点的随机数只有 1个，因此这个参数使用 1。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = new THREE.PlaneBufferGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">const</span> count = geometry.attributes.position.count</span><br><span class="line"><span class="keyword">const</span> randoms = new Float32Array(count)</span><br><span class="line"><span class="comment">// 使用随机数填充数组</span></span><br><span class="line"><span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  randoms[i] = Math.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加到几何体的属性中</span></span><br><span class="line">geometry.setAttribute(&#x27;aRandom&#x27;, new THREE.BufferAttribute(randoms, <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，我们可以在<strong>顶点着色器</strong>中获取该属性，并使用它移动顶点，可以得到一个如下图所示的一个由<strong>随机尖峰</strong>构成的平面。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">float</span> aRandom;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  modelPosition.z += aRandom * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577180914-4240b40c-cc5c-4e5f-a521-ecd8212ad273.webp#averageHue=%23010200&clientId=u30fc2202-5c6f-4&from=paste&id=uc2c027d8&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue34fb9fa-f157-4423-b062-dd5cb4f0e13&title="></p>
<p><a name="DxNv4"></a></p>
<h3 id="限定变量Varyings"><a href="#限定变量Varyings" class="headerlink" title="限定变量Varyings"></a>限定变量Varyings</h3><p>现在我们若想在<strong>片元着色器</strong>中想使用 aRandom 属性给片元着色，是无法直接使用 attribute 属性变量的。此时，实现这个功能的方法就是将这个值从<strong>顶点着色器发送到片元着色器</strong>，称这种变量为 varying。我们需要在两种着色器中都做如下的操作：</p>
<p>在<strong>顶点着色器</strong>中，我们需要在 main 函数之前创建 varying，将其命名为以 v 作为前缀的变量名 vRandom，然后在 main 函数中给它赋值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vRandom;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vRandom = aRandom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<strong>片元着色器</strong>中，使用相同的方法声明，然后在 main 函数中使用它，可以得到如下的染色效果：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vRandom;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.5</span>, vRandom, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577237286-5a0b6f92-14f2-4de8-bd5a-d7edbfbae6a3.webp#averageHue=%23020200&clientId=u30fc2202-5c6f-4&from=paste&id=u48f19863&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u38cfc988-ab24-4ac4-9a8c-9c31a587170&title="><br>:::danger<br>📌 varying的一个有趣之处是，顶点之间的值是线性插值的，如GPU在两个顶点之间绘制一个片元，一个顶点的varying是1.0，另一个顶点的varying是0.0，则该片元值将为0.5。这个特性可以实现平滑的渐变效果。<br>:::<br><a name="Ewl0h"></a></p>
<h3 id="统一变量Uniforms"><a href="#统一变量Uniforms" class="headerlink" title="统一变量Uniforms"></a>统一变量Uniforms</h3><p>uniform 用于将数据从 JavaScript 发送到 着色器。如果我们使用同一个着色器但是参数不同时就可以使用 uniform，使用期间参数还可以改变。在<strong>顶点着色器</strong> 和 片元着色器 中都可以使用 uniform，它的值在每个顶点和每个片元中的数据都是相同的。实际上在我们的代码中已经有 projectionMatrix、viewMatrix、modelMatrix 等 uniform，Three.js 内置创建了它们。<br>现在，我们来创建自己的 uniform。为了将统一变量添加到材质中，需要使用 uniforms 属性。我们将创建一个波动的平面，并使用变量来控制波浪的频率。下面用于控制 <strong>频率</strong> 的变量命名为 uFrequency，特地加了一个 u 字符作为前缀来标识是 uniform 变量，方便在着色器中和其他参数区分开来，但这不是强制的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: <span class="number">10</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，可以在着色器代码中获取 uniform 值，并在 main 函数中使用它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uFrequency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency) * <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577414544-0ae79204-fb4e-4bab-bbca-53611fada084.webp#averageHue=%23010200&clientId=u30fc2202-5c6f-4&from=paste&id=u40aa8a49&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc2ef55af-fed7-4966-8036-f6af2b24c8f&title=">显示结果和前面的相同，但是现在我们可以在 JavaScript 来控制频率了。我们可以把频率 frequency 改成 vec2 来控制水平和垂直方向的波动，在 Three.js 中可以使用二维向量 THREE.Vector2：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: new THREE.Vector2(<span class="number">10</span>, <span class="number">5</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在着色器中，将 uFrequency 的类型从 float 改为 vec2 并在 z轴 同时应用 uFrequency 的 x值 和 y值，此时我们的模型网格就会同时产生在<strong>水平</strong>和<strong>垂直</strong>方向的波动：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> uFrequency;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency.x) * <span class="number">0.1</span>;</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y) * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577509047-b365cdc7-61fb-4b1d-a679-33d611828dc8.webp#averageHue=%23020200&clientId=u30fc2202-5c6f-4&from=paste&id=u4963fec8&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud7769660-9675-48c9-8293-3e639c4e764&title="><br>让我们再新加一个 uniform 来让平面像在风中飘动的旗帜。我们将使用统一变量 uTime 向着色器发送一个时间值，然后在 sin(…) 函数中使用它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: new THREE.Vector2(<span class="number">10</span>, <span class="number">5</span>) &#125;,</span><br><span class="line">    uTime: &#123; value: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不要忘了在 tick (render函数)页面重绘函数中更新 uTime，我们使用 getElapsedTime 来获取已经花费了多少时间:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tick = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> elapsedTime = clock.getElapsedTime();</span><br><span class="line">  material.uniforms.uTime.value = elapsedTime;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在着色器中获取 uTime 并在 sin(…) 函数中使用它，我们的平面就会看起来像一个在风中飘动的旗帜 🚩：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency.x + uTime) * <span class="number">0.1</span>;</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y + uTime) * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577591182-7d100dd3-841d-4f75-972b-0a64e7feb603.webp#clientId=u30fc2202-5c6f-4&from=paste&id=u2e5b1888&originHeight=945&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8000f8c6-4642-4761-9c42-b4cbe2d21fd&title="><br>我们也可以将 uTime 之前的 + 改为 - 来修改波动的方向。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency.x - uTime) * <span class="number">0.1</span>;</span><br><span class="line">modelPosition.z += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y - uTime) * <span class="number">0.1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577616202-0c052bd5-3ef8-4877-9530-ff811e7084b1.webp#clientId=u30fc2202-5c6f-4&from=paste&id=u9b59e523&originHeight=945&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf646fb78-fa63-49d9-b4da-7b54e427133&title="><br>:::danger<br>📌 注意，使用uTime时如果直接使用JavaScript的Date.now()，会发现不起作用，因为它的数值对于着色器而言太过庞大，我们不能发送太小或太大的统一变量值。<br>:::<br>虽然现在网格模型具有波动效果，但是它仍然是一个平面网格构成，我们可以修改它的属性来使它看起来更像个旗子 🚩。我们可以修改它的大小比例：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">mesh.scale.y = <span class="number">2</span> / <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577671636-91fd4308-d731-43c7-97f1-cf3ba98615cf.webp#clientId=u30fc2202-5c6f-4&from=paste&id=uc2ce14e2&originHeight=945&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0a76e568-86e2-4187-a352-0ee5fdaa2c0&title="><br>在片元着色器中也可以使用 uniform 统一变量，我们添加一个 uColor 作为颜色变量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: new THREE.Vector2(<span class="number">10</span>, <span class="number">5</span>) &#125;,</span><br><span class="line">    uTime: &#123; value: <span class="number">0</span> &#125;,</span><br><span class="line">    uColor: &#123; value: new THREE.Color(&#x27;orange&#x27;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在片元着色器中获取颜色变量，并将它作为 gl_FragColor 的值，你会看到平面将变成设定的颜色效果：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(uColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577716145-cf954f5e-a81f-49f6-b9f2-514957877e29.webp#averageHue=%23271900&clientId=u30fc2202-5c6f-4&from=paste&id=udf19aaa2&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u118ba5ba-7c0c-4f8e-b8c0-e228c945d38&title="><br><a name="N4bZh"></a></p>
<h3 id="纹理Textures"><a href="#纹理Textures" class="headerlink" title="纹理Textures"></a>纹理Textures</h3><p>Textures 知识比较复杂，在之前的文章中已经介绍过使用 THREE.TextureLoader 加载纹理，下面我们给着色器材质添加一个图片纹理，并使用 uTexture 统一变量传递给着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uTexture: &#123; value: textureLoader.load(&#x27;/textures/flag.png&#x27;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在着色器中，为了使纹理的颜色应用于每个可见片元上，我们需要使用 texture2D(…)，它接收两个参数，第一个是需要应用的纹理即 uTexture，第二个是纹理上拾取颜色的坐标系，这个坐标系其实就是前面讨论的 UV坐标,它的作用是将纹理坐标投射到几何体上。我们用于创建几何体的 PlaneBufferGeometry 会自动生成这个坐标，我们可以通过 geometry.attributes.uv 来查看它。texture2D(…) 的返回结果是一个由 r, g, b, a 构成的 vec4。<br>因为 uv 是一个 attribute 属性，因此需要在<strong>顶点着色器</strong>中需要这样获取它，我们需要在片元着色器中使用它，因此还需要通过 varying 发送到片元着色器，并在 main 函数中更新它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> uv;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vUv = uv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，我们可以在<strong>片元着色器</strong>中获取 vUv 变量，并在 texture2D(…)方法中使用它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> uTexture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> textureColor = <span class="built_in">texture2D</span>(uTexture, vUv);</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = textureColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577861026-96a69468-e1f3-4d49-b8aa-48ebe2d45da9.webp#averageHue=%231a1108&clientId=u30fc2202-5c6f-4&from=paste&id=u7f4f2384&originHeight=829&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3af20e4a-f957-4753-ac23-f129725678d&title="></p>
<p><a name="A9vYv"></a></p>
<h3 id="颜色变化"><a href="#颜色变化" class="headerlink" title="颜色变化"></a>颜色变化</h3><p>现在虽然有了图片贴图，但是旗子 🚩 的明暗颜色变化还不太明显，下面我们将为它添加一些阴影变化。<br>首先在<strong>顶点着色器</strong>中，我们将把风的高程存储 elevation 变量中，然后通过 varying 发送到<strong>片元着色器</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vElevation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> elevation = <span class="built_in">sin</span>(modelPosition.x * uFrequency.x - uTime) * <span class="number">0.1</span>;</span><br><span class="line">  elevation += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y - uTime) * <span class="number">0.1</span>;</span><br><span class="line">  modelPosition.z += elevation;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vElevation = elevation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在<strong>片元着色器</strong>中获取 vElevation，用它来改变 textureColor 的 r, g, b属性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vElevation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> textureColor = <span class="built_in">texture2D</span>(uTexture, vUv);</span><br><span class="line">  textureColor.rgb *= vElevation * <span class="number">2.0</span> + <span class="number">0.5</span>;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = textureColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577926006-88ad5209-6df1-466d-9eb7-3db2d9b41c23.webp#clientId=u30fc2202-5c6f-4&from=paste&id=u16ff335e&originHeight=884&originWidth=1279&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u098185b6-684f-4c3a-bafe-1eaadb8d2c3&title="></p>
<p><a name="Cbg71"></a></p>
<h3 id="着色器材质ShaderMaterial"><a href="#着色器材质ShaderMaterial" class="headerlink" title="着色器材质ShaderMaterial"></a>着色器材质ShaderMaterial</h3><p>上面所有内容，为了深入理解着色器的原理，我们使用的是 RawShaderMaterial，接下来我们使用<strong>更简单</strong>的 ShaderMaterial 来重构上面完成的所有功能。ShaderMaterial 和 RawShaderMaterial 的工作原理其实是一样的，只不过其内置 attributes 和 uniforms，精度 也会自动设置。我们只需按下面流程稍加修改代码即可。<br>在 JavaScript 代码中将材质换为 THREE.ShaderMaterial。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.ShaderMaterial(&#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后<strong>删除</strong>着色器中以下属性和定义：</p>
<ul>
<li>uniform mat4 projectionMatrix;</li>
<li>uniform mat4 viewMatrix;</li>
<li>uniform mat4 modelMatrix;</li>
<li>attribute vec3 position;</li>
<li>attribute vec2 uv;</li>
<li>precision mediump float;<br><a name="l7dhX"></a></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>查错：因为着色器是对每个片元执行，因此没有日志记录，出错的话很难查找，如果我们忘写了分号，Three.js 会将整个着色器代码打印出来并会提示出错的行号；</li>
<li>调试：调试数值的一种方法是可以在 gl_FragColor 中使用它，虽然不够精确，但是可以看到颜色变化；</li>
<li>GLSLify：一个 node module 模块，可以改对 glsl 文件的处理，通过 glslify 我们可以像模块一样导入和导出 glsl 代码。你可以使用 glslify-loader 并将其加到 webpack 配置中。<br><a name="LINe3"></a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>了解什么是着色器</li>
<li>了解为什么要使用着色器</li>
<li>GLSL 语言的基本语法规则</li>
<li>理解 Vertex Shader 顶点着色器</li>
<li>理解 Fragment Shader 片元着色器</li>
<li>掌握 Attributes、Varyings、Uniforms的区别和用法</li>
<li>着色器在两种着色器材质 RawShaderMaterial 和 ShanderMaterial 中的使用方法</li>
<li>使用着色器设置颜色和纹理等</li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/three/">three</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/12/25/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%8E%9F%E7%90%86/"><span class="level-item">渲染管线原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avator.jpg" alt="Enoch"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Enoch</p><p class="is-size-6 is-block">有形非易测，无源讵可量。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>chengdu-SiChuan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Enochbest" target="_blank" rel="noopener">Follow</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/Enochbest" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Git-hub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="2658929241@qq.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">E-mail</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/dart/"><span class="tag">dart</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/three/"><span class="tag">three</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uniapp/"><span class="tag">uniapp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue3/"><span class="tag">vue3</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"><span class="tag">区块链</span><span class="tag">10</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#摘要"><span class="level-left"><span class="level-item">1</span><span class="level-item">摘要</span></span></a></li><li><a class="level is-mobile" href="#效果"><span class="level-left"><span class="level-item">2</span><span class="level-item">效果</span></span></a></li><li><a class="level is-mobile" href="#正文"><span class="level-left"><span class="level-item">3</span><span class="level-item">正文</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Shader着色器简介"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Shader着色器简介</span></span></a></li><li><a class="level is-mobile" href="#为什么要使用着色器"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">为什么要使用着色器</span></span></a></li><li><a class="level is-mobile" href="#着色器的类型"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">着色器的类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#顶点着色器Vertex-Shader"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">顶点着色器Vertex Shader</span></span></a></li><li><a class="level is-mobile" href="#片元着色器Fragment-Shader"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">片元着色器Fragment Shader</span></span></a></li></ul></li><li><a class="level is-mobile" href="#原始着色器材质RawShaderMaterial"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">原始着色器材质RawShaderMaterial</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分离两种着色器"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">分离两种着色器</span></span></a></li><li><a class="level is-mobile" href="#属性"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">属性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#GLSL-语言"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">GLSL 语言</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#变量"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">变量</span></span></a></li><li><a class="level is-mobile" href="#函数"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#理解顶点着色器Vertex-Shader"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">理解顶点着色器Vertex Shader</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#gl-Position"><span class="level-left"><span class="level-item">3.6.1</span><span class="level-item">gl_Position</span></span></a></li><li><a class="level is-mobile" href="#位置属性Position-attributes"><span class="level-left"><span class="level-item">3.6.2</span><span class="level-item">位置属性Position attributes</span></span></a></li><li><a class="level is-mobile" href="#矩阵限定变量Matrices-uniforms"><span class="level-left"><span class="level-item">3.6.3</span><span class="level-item">矩阵限定变量Matrices uniforms</span></span></a></li></ul></li><li><a class="level is-mobile" href="#理解片元着色器Fragment-Shader"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">理解片元着色器Fragment Shader</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#主函数main"><span class="level-left"><span class="level-item">3.7.1</span><span class="level-item">主函数main</span></span></a></li><li><a class="level is-mobile" href="#精度Precision"><span class="level-left"><span class="level-item">3.7.2</span><span class="level-item">精度Precision</span></span></a></li><li><a class="level is-mobile" href="#gl-FragColor"><span class="level-left"><span class="level-item">3.7.3</span><span class="level-item">gl_FragColor</span></span></a></li></ul></li><li><a class="level is-mobile" href="#属性Attributes"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">属性Attributes</span></span></a></li><li><a class="level is-mobile" href="#限定变量Varyings"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">限定变量Varyings</span></span></a></li><li><a class="level is-mobile" href="#统一变量Uniforms"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">统一变量Uniforms</span></span></a></li><li><a class="level is-mobile" href="#纹理Textures"><span class="level-left"><span class="level-item">3.11</span><span class="level-item">纹理Textures</span></span></a></li><li><a class="level is-mobile" href="#颜色变化"><span class="level-left"><span class="level-item">3.12</span><span class="level-item">颜色变化</span></span></a></li><li><a class="level is-mobile" href="#着色器材质ShaderMaterial"><span class="level-left"><span class="level-item">3.13</span><span class="level-item">着色器材质ShaderMaterial</span></span></a></li><li><a class="level is-mobile" href="#其他"><span class="level-left"><span class="level-item">3.14</span><span class="level-item">其他</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Three-js%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">Three.js学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/dart%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">dart学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/react/"><span class="level-start"><span class="level-item">react</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/uniapp/"><span class="level-start"><span class="level-item">uniapp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/vue3/"><span class="level-start"><span class="level-item">vue3</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">前端安全</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">区块链基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">区块链系统实现</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">浏览器原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-14T06:27:20.000Z">2024-03-14</time></p><p class="title"><a href="/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/">vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法</a></p><p class="categories"><a href="/categories/vue3/">vue3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:52:35.000Z">2023-12-26</time></p><p class="title"><a href="/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/">初识着色器(包括着色器传参)</a></p><p class="categories"><a href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-25T05:50:41.000Z">2023-12-25</time></p><p class="title"><a href="/2023/12/25/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%8E%9F%E7%90%86/">渲染管线原理</a></p><p class="categories"><a href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-09T12:12:41.000Z">2023-09-09</time></p><p class="title"><a href="/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/">IM发送表情（基于quill富文本编辑器）</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-07T12:42:20.000Z">2023-09-07</time></p><p class="title"><a href="/2023/09/07/%E5%9C%A8Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/">在Vue3中使用quill富文本编辑器</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">March 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/avator.jpg" alt="Enoch&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Enoch</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>