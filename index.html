<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Enoch&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Enoch&#039;s Blog"><meta name="msapplication-TileImage" content="/images/avator.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Enoch&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Enoch&#039;s Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Enoch&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Enoch"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"blog"},"headline":"Enoch's Blog","image":["/img/og_image.png"],"author":{"@type":"Person","name":"Enoch"},"publisher":{"@type":"Organization","name":"Enoch's Blog","logo":{"@type":"ImageObject","url":"/images/avator.jpg"}},"description":""}</script><link rel="icon" href="/images/avator.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/avator.jpg" alt="Enoch&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-03-14T06:27:20.000Z" title="2024/3/14 14:27:20">2024-03-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-14T07:05:30.899Z" title="2024/3/14 15:05:30">2024-03-14</time></span><span class="level-item"><a class="link-muted" href="/categories/vue3/">vue3</a></span><span class="level-item">3 minutes read (About 484 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/">vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法</a></p><div class="content"><p>问题:发现控制台一直输出的是热更新失效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[vite] page reload src/pages/Login/index.vue (circular imports)</span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-26T05:52:35.000Z" title="2023/12/26 13:52:35">2023-12-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T05:56:05.912Z" title="2024/5/27 13:56:05">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></span><span class="level-item">an hour read (About 8271 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/">初识着色器(包括着色器传参)</a></p><div class="content"><meta name="referrer" content="no-referrer">

<p><a name="uAQeQ"></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文内容主要介绍 Three.js 中的着色器知识，通过讲解什么是着色器、着色器的分类、GLSL 语言的核心语法要点、Three.js 中的两种着色器材质的 <code>RawShaderMaterial </code>和 <code>ShaderMaterial</code> 的区别和用法等基本知识，深入理解着色器，并使用它创建出有趣的三维图形。<br><a name="nFwCe"></a></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>随着本文内容一步步深入，最终将使用着色器构建一个如下所示的波动旗帜 🚩 效果，通过滑动调整页面右上方的 dat.GUI 控制器，可以调整 x轴 和 y轴 上的波动幅度。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045193-b8e161ee-bc17-4aea-8963-1c1545e83d8c.webp#clientId=uea1e22cc-b254-4&from=paste&id=udfbb4a20&originHeight=865&originWidth=1376&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua09959eb-0c6b-46e0-a978-31c9d61278e&title="></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a name="brCFE"></a></p>
<h3 id="Shader着色器简介"><a href="#Shader着色器简介" class="headerlink" title="Shader着色器简介"></a>Shader着色器简介</h3><p>着色器是 WebGL 的重要组件之一，它是一种使用 GLSL 语言编写的运行在 GPU 上的程序。顾名思义，着色器用于定位几何体的每个顶点，并为几何体的每个可见像素进行着色 🎨。着色器是屏幕上呈现画面之前的最后一步，用它可以实现对先前渲染结果进行修改，如颜色、位置等，也可以对先前渲染的结果做后处理，实现高级的渲染效果。<br>例如，对于相同场景、相同光照、相同模型等条件下，对这个模型分别使用不同的着色器，就会呈现出完全不同的渲染效果：使用 plastic shader 的模型渲染出塑料质感，而使用了 toon shader 的模型则看起来是二维卡通效果。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562044943-77e5183f-7336-4fa9-9a62-a2e6ba9a3a1d.webp#averageHue=%23a6958c&clientId=uea1e22cc-b254-4&from=paste&id=u8384a639&originHeight=394&originWidth=512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3186b75c-09d7-4227-9829-2abd84067da&title="><br><a name="lUqpl"></a></p>
<h3 id="为什么要使用着色器"><a href="#为什么要使用着色器" class="headerlink" title="为什么要使用着色器"></a>为什么要使用着色器</h3><p>虽然 Three.js 已经内置了非常多的材质，但是在实际开发中很难满足我们的需求，比如在数字孪生系统的开发中，我们经常需要添加一些炫酷的<strong>飞线效果</strong>、<strong>雷达效果</strong>等 ✨，它们是无法直接使用 Three.js 来生成，此时就需要我们创建自己的着色器。而且出于性能的考虑，我们也可以使用自己的着色器材质代替像 MeshStandardMaterial 这样的材质非常精细涉及大量代码和计算的材质，以便于提升页面性能。<br><a name="jvXE0"></a></p>
<h3 id="着色器的类型"><a href="#着色器的类型" class="headerlink" title="着色器的类型"></a>着色器的类型</h3><p><a name="IXyNh"></a></p>
<h4 id="顶点着色器Vertex-Shader"><a href="#顶点着色器Vertex-Shader" class="headerlink" title="顶点着色器Vertex Shader"></a>顶点着色器Vertex Shader</h4><p>Vertex Shader 用于定位几何体的顶点，它的工作原理是发送顶点位置、网格变换（<code>position</code>、旋<code>rotation</code>和 scale 等）、摄像机信息（<code>position</code>、<code>rotation</code>、<code>fov</code> 等）。GPU 将按照 Vertex Shader 中的指令处理这些信息，然后将顶点投影到 2D 空间中渲染成 Canvas。<br>当使用 Vertex Shader 时，它的代码将作用于几何体的每个顶点。在每个顶点之间，有些数据会发生变化，这类数据称为 attribute；有些数据在顶点之间永远不会变化，称这种数据为 uniform。Vertex Shader 会首先触发，当顶点被放置，GPU 知道几何体的哪些像素可见，然后执行 Fragment Shader。</p>
<ul>
<li>attribute：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点的位置。</li>
<li>uniform：顶点着色器使用的常量数据，不能被修改，一般用于对同一组顶点组成的单个 3D 物体中所有顶点都相同的变量，如当前光源的位置。</li>
<li>varying: 从顶点着色器发送到片元着色器中的插值计算数据<br><a name="JTUTh"></a></li>
</ul>
<h4 id="片元着色器Fragment-Shader"><a href="#片元着色器Fragment-Shader" class="headerlink" title="片元着色器Fragment Shader"></a>片元着色器Fragment Shader</h4><p>Fragment Shader 在 Vertex Shader 之后执行，它的作用是为几何体的每个可见像素进行着色。我们可以通过uniforms 将数据发送给它，也可以将 Vertex Shader 中的数据发送给它，我们将这种从 Vertex Shader 发送到 Fragment Shader 的数据称为 varying。<br>Fragment Shader 中最直接的指令就是可以使用相同的颜色为所有像素进行着色。如果只设置了颜色属性，就相当于得到了与 MeshBasicMaterial 等价的材质。如果我们将光照的位置发送给 Fragment Shader，然后根据像素收到光照影响的多少来给像素上色，此时就能得到与 MeshPhongMaterial 效果等价的材质。</p>
<p>📌 以下内容示例流程翻译、并整理于<a href="https://link.juejin.cn/?target=https://threejs-journey.com/">《three.js journey》</a> shader 相关课程，如果对英文原版感兴趣可前往查看。<br><a name="w8DRq"></a></p>
<h3 id="原始着色器材质RawShaderMaterial"><a href="#原始着色器材质RawShaderMaterial" class="headerlink" title="原始着色器材质RawShaderMaterial"></a>原始着色器材质RawShaderMaterial</h3><p>在 Three.js 中可以渲染着色器的材质有两种：RawShaderMaterial 和 ShaderMaterial，它们之间的区别是 ShaderMaterial 会自动将一些初始化着色器的参数添加到代码中（内置 attributes 和 uniforms），而 RawShaderMaterial 则什么都不会添加。<br>我们先来看看如何使用 RawShaderMaterial 材质，首先我们创建一个平面，然后和创建其他材质一样，通过 new THREE.RawShaderMaterial 初始化原始着色器材质，并给它添加两个参数 vertexShader 和 fragmentShader 代表材质的<strong>顶点着色器</strong>和<strong>片元着色器</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">    vertexShader: &#x27;&#x27;,</span><br><span class="line">    fragmentShader: &#x27;&#x27;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>然后开始编写材质的顶点着色器和片元着色器，分别添加如下的代码。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">    vertexShader: `</span><br><span class="line">      <span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line">    <span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line">    <span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main() &#123;</span><br><span class="line">      <span class="built_in">gl_Position</span> = projectionMatrix * viewMatrix * modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    `,</span><br><span class="line">    fragmentShader: `</span><br><span class="line">      <span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> main()&#123;</span><br><span class="line">      <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    `</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>此时可以得到一个<strong>红色</strong>的平面，说明我们编写的第一个着色器运行成功了 🎉。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562045030-f2c429ba-6d26-4e09-9256-6293df9ca073.webp#averageHue=%233c0100&clientId=uea1e22cc-b254-4&from=paste&id=u03d39f3b&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6364ca47-8103-4f6a-aa89-b26d4a41e8a&title="><br><a name="Gmylm"></a></p>
<h4 id="分离两种着色器"><a href="#分离两种着色器" class="headerlink" title="分离两种着色器"></a>分离两种着色器</h4><p>在实际开发中，着色器比较复杂，代码量比较多，如果直接放在材质中的话会增加代码阅读困难量。我们可以将着色器代码单独拆分出来，分别存放在 vertex.glsl 和 fragment.glsl 文件中，然后在代码中像下面这样引入即可。这样做还有一个好处就是可以安装代码编辑器的 GLSL 高亮语法插件，提高编程效率。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import testVertexShader from &#x27;./shaders/test/vertex.glsl&#x27;;</span><br><span class="line">import testFragmentShader from &#x27;./shaders/test/fragment.glsl&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>此时查看页面，得到的结果还是一样的。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703562044980-355b4055-727b-454a-9197-fd3feb820925.webp#averageHue=%233c0100&clientId=uea1e22cc-b254-4&from=paste&id=u77d1bffb&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua00bc5dc-94a9-480c-8b76-57a5baf936f&title="><br><a name="rhtB5"></a></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>材质的一些通用属性在 RawShaderMaterial 同样是适用的，比如 wireframe、side、transparent、flatShading 等都可以生效，对上面材质开启 wireframe 属性，可以得到如下图所示的平面的网格模型。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">    vertexShader: testVertexShader,</span><br><span class="line">    fragmentShader: testFragmentShader,</span><br><span class="line">    wireframe: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703573865903-9b56721f-11bd-4708-8c9c-cd68712d8bf1.webp#averageHue=%23060000&clientId=uea1e22cc-b254-4&from=paste&id=ucdeb0424&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a276834-01ac-4300-9b36-401eb9952b3&title="><br>:::danger<br>但是需要注意的是，像map、alphaMap、opacity、color等属性在着色器材质中会失效，我们需要在着色器代码中自己实现<br>:::<br><a name="u3ee8"></a></p>
<h3 id="GLSL-语言"><a href="#GLSL-语言" class="headerlink" title="GLSL 语言"></a>GLSL 语言</h3><p>在 Three.js 中，需要使用 GLSL 语言来编写着色器，全称是 OpenGL Shading Language，意为 OpenGL 中的着色语言。它的语法类似于 C语言，在开始编写着色器之前，我们先了解一些它的基本语法。</p>
<ul>
<li><strong>日志</strong>：由于着色器语言是针对每个顶点和每个片元执行的，日志记录是没有意义的，因此编写 GLSL 时没有控制台。</li>
<li><strong>缩进</strong>：代码缩进格式<strong>没有严格要求</strong>，只要易读美观就行。</li>
<li><strong>分号</strong>：和 C语言 一样，编写 GLSL 语言时，任何指令的结尾都<strong>必须添加分号</strong>，丢失分号就会导致代码无法运行。</li>
<li><strong>类型</strong>：和 C语言 一样， GLSL 是一种强类型语言，<strong>不同类型的变量不能混用</strong>，否则会报错。<br><a name="umqxA"></a></li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 GLSL 中有很多变量类型，编写着色器时，我们需要根据需要选择合适类型的变量。<br><a name="kFzE4"></a></p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p>用以定义整数。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> bar = - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><a name="ZfJz7"></a></p>
<h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><p>浮点数就是小数，可以是正数也可以是负数，必须提供小数点 .。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> foo = - <span class="number">0.123</span>;</span><br><span class="line"><span class="type">float</span> bar = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<p><a name="DkFs8"></a></p>
<h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>用于表示值得真假。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> bar = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><a name="eZIpZ"></a></p>
<h5 id="二维向量vec2"><a href="#二维向量vec2" class="headerlink" title="二维向量vec2"></a>二维向量vec2</h5><p>如果我们需要存储具有 x 和 y 属性这样具有2个坐标的值时，可以使用 vec2。需要注意的是，直接使用 vec2 foo &#x3D; vec2() 这样未添加参数的空值会报错，应该像下面这样提供完整的参数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> foo = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>创建 vec2 后修改属性值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> foo = <span class="type">vec2</span>(<span class="number">0.0</span>);</span><br><span class="line">foo.x = <span class="number">1.0</span>;</span><br><span class="line">foo.y = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>

<p>进行浮点数与 vec2 相乘等操作运算时，结果将同时作用于 x 和 y：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec2 foo = vec2(1.0, 2.0);</span><br><span class="line">foo *= 2.0;</span><br></pre></td></tr></table></figure>

<p><a name="KZCzY"></a></p>
<h5 id="三维向量vec3"><a href="#三维向量vec3" class="headerlink" title="三维向量vec3"></a>三维向量vec3</h5><p>与 vec2 类似，vec3 用于表示具有 x、y、z 三个坐标的值，可以用它非常方便的表示<strong>三维空间坐标</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> foo = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> bar = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">bar.z = <span class="number">4.0</span>;</span><br></pre></td></tr></table></figure>

<p>RGB 颜色也同样适合使用 vec3 表示：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">color.r = <span class="number">0.5</span>;</span><br><span class="line">color.b = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用 vec2 来创建 vec3：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> foo = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="type">vec3</span> bar = <span class="type">vec3</span>(foo, <span class="number">3.0</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用 vec3 来创建 vec2，其中 bar 的值为 1.0, 2.0，baz 的 值为 2.0, 1.0：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> foo = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line"><span class="type">vec2</span> bar = foo.xy;</span><br><span class="line"><span class="type">vec2</span> baz = foo.yx;</span><br></pre></td></tr></table></figure>

<p><a name="xjaUz"></a></p>
<h5 id="四维向量vec4"><a href="#四维向量vec4" class="headerlink" title="四维向量vec4"></a>四维向量vec4</h5><p>与前面几个类似，vec4 用于表示四维向量，四个值命名为 x, y, z, w 或 r, g, b, a，向量之间同样能进行相互转换：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> foo = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line"><span class="type">vec4</span> bar = <span class="type">vec4</span>(foo.zw, <span class="type">vec2</span>(<span class="number">5.0</span>, <span class="number">6.0</span>));</span><br></pre></td></tr></table></figure>

<p>除上述之外，还有一些其它类型的变量，如 mat2、mat3、mat4、sampler2D 等将在后续学习中介绍。</p>
<ul>
<li>在着色器内，一般命名以 gl_ 开头的变量是着色器的内置变量。</li>
<li>webgl_ 和 <em>webgl 是着色器保留字，自定义变量不能以 webgl</em> 或 _webgl 开头。</li>
<li>变量声明一般包含 &lt;存储限定符&gt; &lt;数据类型&gt; &lt;变量名称&gt;，以 attribute vec4 a_Position 为例，attribute 表示存储限定符，vec 是数据类型，a_Position 为变量名。<br><a name="Y5HZ3"></a></li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 GLSL 中定义函数，必须以返回值的类型开头，如果没有返回值，则可以使用 void。定义函数的参数时，也必须提供参数类型。<br>在 GLSL 中定义函数，必须以返回值的类型开头，如果没有返回值，则可以使用 void。定义函数的参数时，也必须提供参数类型。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line"><span class="type">float</span> loremIpsum() &#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="type">void</span> justDoingStuff() &#123;</span><br><span class="line">  <span class="type">float</span> a = <span class="number">1.0</span>;</span><br><span class="line">  <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义参数类型</span></span><br><span class="line"><span class="type">float</span> add(<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="fEi1i"></a></p>
<h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><p>GLSL 内置了很多使用的函数，下面列举了一些比较常用的：</p>
<ul>
<li><strong>运算函数</strong><ul>
<li>abs(x)：取 x 的绝对值</li>
<li>radians(x)：角度转弧度</li>
<li>degrees(x)：弧度转角度</li>
<li>sin(x)：正弦函数，传入值为弧度。还有 cos 余弦函数、tan 正切函数、asin 反正弦、acos反余弦、atan 反正切等</li>
<li>pow(x,y)：x^y</li>
<li>exp(x)：e^x</li>
<li>exp2(x)：2^x</li>
<li>log(x)：logex</li>
<li>log2(x)：log2x</li>
<li>sqrt(x)：x√</li>
<li>inversesqr(x)：1x√</li>
<li>sign(x)：x&gt;0 返回 1.0，x&lt;0 返回 -1.0，否则返回 0.0</li>
<li>ceil(x)：返回大于或者等于 x 的整数</li>
<li>floor(x)：返回小于或者等于 x 的整数</li>
<li>fract(x)：返回 x-floor(x) 的值</li>
<li>mod(x,y)：取模求余数</li>
<li>min(x,y)：获取 x、y 中小的那个</li>
<li>max(x,y)：获取 x、y 中大的那个</li>
<li>mix(x,y,a)：返回 x∗(1−a)+y∗a</li>
<li>step(x,a)：x&lt;a返回 0.0，否则返回 1.0。</li>
<li>smoothstep(x,y,a)：a&lt;x 返回 0.0，a&gt;y 返回 1.0，否则返回 0.0-1.0 之间平滑的 Hermite 插值。</li>
<li>dFdx(p)：p 在 x 方向上的偏导数</li>
<li>dFdy(p)：p 在 y 方向上的偏导数</li>
<li>fwidth(p)：p 在 x 和 y 方向上的偏导数的绝对值之和</li>
</ul>
</li>
<li>**几何函数 **<ul>
<li>length(x)：计算向量 x 的长度</li>
<li>distance(x, y)：返回向量 xy 之间的距离</li>
<li>dot(x,y)：返回向量 xy 的点积</li>
<li>cross(x,y)：返回向量 xy 的差积</li>
<li>normalize(x)：返回与 x 向量方向相同，长度为 1 的向量</li>
</ul>
</li>
<li><strong>矩阵函数</strong><ul>
<li>matrixCompMult(x,y)：将矩阵相乘</li>
<li>lessThan(x,y)：返回向量 xy 的各个分量执行 x&lt;y 的结果</li>
<li>lessThanEqual(x,y)：返回向量 xy 的各个分量执行 x&lt;&#x3D;y 的结果，类似的有类似的有 greaterThanEqual</li>
<li>any(bvec x)：x 有一个元素为 true，则为 true</li>
<li>all(bvec x)：x 所有元素为 true，则返回 true，否则返回 false</li>
<li>not(bvec x)：x 所有分量执行逻辑非运算<br>:::success<br>如果想了解更多GLSL的内置函数，可以到这个网站查询：<a href="https://link.juejin.cn/?target=https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/indexflat.php">Kronos Group OpenGL reference pages</a><br>:::<br><a name="vaV7r"></a></li>
</ul>
</li>
</ul>
<h3 id="理解顶点着色器Vertex-Shader"><a href="#理解顶点着色器Vertex-Shader" class="headerlink" title="理解顶点着色器Vertex Shader"></a>理解顶点着色器Vertex Shader</h3><p>接下来讲解着色器里代码的具体内容。<br><strong>顶点着色器</strong>的作用是将几何体的每个顶点放置在 2D 渲染空间上，即顶点着色器将 3D 顶点坐标转换为 2D canvas 坐标。<br>main函数<br>它将被自动调用，并且不会返回任何内容。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><a name="cgIWe"></a></p>
<h4 id="gl-Position"><a href="#gl-Position" class="headerlink" title="gl_Position"></a>gl_Position</h4><p>gl_Position 是一个内置变量，我们只需要给它重新赋值就能使用，它将会包含屏幕上的顶点的位置。下面 main 函数中就是用于给它设置合适的值。执行这段指令后，将得到一个 vec4，意味着我们可以直接在 gl_Position 变量上使用其x、y、z 和 w 属性。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = projectionMatrix * viewMatrix * modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  <span class="built_in">gl_Position</span>.x += <span class="number">0.5</span>;</span><br><span class="line">  <span class="built_in">gl_Position</span>.y += <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br>平面向右上角发生了位移，但是需要注意的是，我们并没有像在 Three.js 中一样将平面在三维空间中进行了移动，我们只是在二维空间中移动了平面的投影。就像你在桌子上画了一幅具有透视效果的画，然后把它向桌子右上角移动，但是你的画中的透视效果并没有发生变化。<br>gl_Position 的作用是在 2D 空间上定位 📍 顶点，既然是 2D 空间，为什么需要使用一个四维向量表示呢？实际上是这些坐标并不是精确的在 2D 空间，而是位于被称为 Clip Space 需要四个维度的<strong>裁切空间</strong>。裁切空间是指在 -1 到 +1 范围内所有 x、y、z 3个方向上的空间，第四个值 w 用于表示透视。就像把所有东西都放在 3D 盒子中一样，任何超出范围的内容都将被裁切。gl_Position 这些内容的这些内容都是自动完成的，我们只需明白其大概原理即可。<br><a name="Ix3An"></a></p>
<h4 id="位置属性Position-attributes"><a href="#位置属性Position-attributes" class="headerlink" title="位置属性Position attributes"></a>位置属性Position attributes</h4><p>相同的代码将应用于几何体的每一个顶点，属性变量 attribute 是在顶点之间唯一会发生改变的变量。相同的顶点着色器 Vertex Shader 将应用于每一个顶点，position 属性将包含具体顶点的 x, y, z 坐标值。我们可以使用如下代码获取顶点位置：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br>因为 gl_Position 是 vec4 类型，可以使用以下方法将 vec3 转化成 vec4：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = <span class="comment">/* ... */</span> <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="HtiRR"></a></p>
<h4 id="矩阵限定变量Matrices-uniforms"><a href="#矩阵限定变量Matrices-uniforms" class="headerlink" title="矩阵限定变量Matrices uniforms"></a>矩阵限定变量Matrices uniforms</h4><p>每个矩阵将转换 position，直到我们获得最终的裁切空间坐标。下面是 3 个矩阵，因为在几何体所有顶点中它们的值都是相同的，我们可以通过 uniform 来获取它们。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br></pre></td></tr></table></figure>

<p><br>下面将对每个矩阵做出一些变换：</p>
<ul>
<li>modelMatrix：将进行网格相关的变换，如缩放、旋转、移动等操作变换都将作用于 position。</li>
<li>viewMatrix：将进行相机相关的变换，如我们向左移动相机，顶点应该在右边、如果我们朝着网格方向移动相机，顶点会变大等。</li>
<li>projectionMatrix：会将我们的坐标转化为裁切空间坐标。</li>
</ul>
<p>为了使用矩阵，我们需要将其相乘，如果想让一个 mat4 作为变量，则该变量类型必须是 vec4。我们也可以将多个矩阵相乘：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = projectionMatrix * viewMatrix * modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上还可以使用更短的写法来让 viewMatrix 和 modelMatrix 组合成一个 projectionMatrix，虽然代码少了，但我们可控制的步骤也少了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = projectionMatrix * modelViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际中我们会选择更长的写法，以便于更好地理解及对 position 进行更多的控制。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  <span class="type">vec4</span> viewPosition = viewMatrix * modelPosition;</span><br><span class="line">  <span class="type">vec4</span> projectedPosition = projectionMatrix * viewPosition;~~~~</span><br><span class="line">  <span class="built_in">gl_Position</span> = projectedPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面两种写法都是等价的，使用下面这种时，我们可以更方便地进行控制，比如可以通过调整 modelPosition 的值来对整个模型进行移动，通过以下代码，就能向上移动模型：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  modelPosition.y += <span class="number">1.0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576267876-e3e36258-3457-43aa-9f23-7fe0f6ba7cbe.webp#averageHue=%23120000&clientId=u30fc2202-5c6f-4&from=paste&id=uabbd3774&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2c162ef7-0e72-4424-a908-33d181371b3&title="><br>我们还可以做一些更有趣的操作，比如将平面变换为<strong>波浪形状</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> modelPosition = modelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * <span class="number">10.0</span>) * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576298541-cf9f547a-8704-42de-880a-4eed725ac7b1.webp#averageHue=%233e0100&clientId=u30fc2202-5c6f-4&from=paste&id=u28c773ae&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue9f2b6b8-afbe-4470-b4ff-496d15d6254&title="></p>
<p><a name="TU4mH"></a></p>
<h3 id="理解片元着色器Fragment-Shader"><a href="#理解片元着色器Fragment-Shader" class="headerlink" title="理解片元着色器Fragment Shader"></a>理解片元着色器Fragment Shader</h3><p><strong>片元着色器</strong>的代码将应用于几何体的每个可见像素，这就是片元着色器在顶点着色器之后运行的原因，它的代码比顶点着色器更易于管理。<br><a name="zSt4H"></a></p>
<h4 id="主函数main"><a href="#主函数main" class="headerlink" title="主函数main"></a>主函数main</h4><p>同样，片元着色器中也有一个主函数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="jMvtk"></a></p>
<h4 id="精度Precision"><a href="#精度Precision" class="headerlink" title="精度Precision"></a>精度Precision</h4><p>在顶部有一条这样的指令，我们用它来决定浮点数的精度，有以下几种值供选择：</p>
<ul>
<li>highp：会影响性能，在有些机器上可能无法运行；</li>
<li>mediump：常用的类型；</li>
<li>lowp：可能会由于精度问题产生错误。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在示例使用的是 RawShaderMaterial 原始着色器材质才需要设置精度，在着色器材质 ShaderMaterial中会自动处理。</p>
<blockquote>
<p>在顶点着色器中也可以是指精度，但是这是非必须的。</p>
</blockquote>
<p><a name="DbTlz"></a></p>
<h4 id="gl-FragColor"><a href="#gl-FragColor" class="headerlink" title="gl_FragColor"></a>gl_FragColor</h4><p>gl_FragColor 和 gl_Position 类似，但它用于颜色。它也一样是已经被内置声明了的，我们只需要在main 函数中重新给它赋值。它是一个 vec4，前三个值是红色、绿色、蓝色通道 (r, g, b)，第四个值是透明度 alpha (a)。gl_FragColor 的每个值的取值范围是 0.0 到 1.0，如果我们设置的值高于它们，也不会产生报错。<br>下面这段代码将生成一个<strong>紫色</strong>的几何体</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703576734744-fffc09a5-dfe1-40f9-ae9f-83d4ff97e200.webp#averageHue=%23010200&clientId=u30fc2202-5c6f-4&from=paste&id=ufba13080&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23564775-9a16-4f7f-bb8b-1cc393d1afb&title="><br>为了 alpha 透明度值可以生效，我们需要在材质中将 transparent 属性设置为 true：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  transparent: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="SB3W6"></a></p>
<h3 id="属性Attributes"><a href="#属性Attributes" class="headerlink" title="属性Attributes"></a>属性Attributes</h3><p>Attributes 是每个顶点之间变化的值，我们之前已经有一个命名为 position 的属性变量，它是每个顶点在坐标轴中的 vec3 值。我们将为每个顶点添加一个随机值，并根据这个值在 z 轴上移动该顶点。在 JavaScript 代码中我们可以像下面这个直接给 BufferGeometry 添加 attribute 属性。然后再创建一个 32位 的浮点类型数组 Float32Array，为了知道几何体中有多少个顶点，现在可以通过 attributes 属性获取。最后在 BufferAttribute 中使用该数组，并将它添加到几何体的属性中。</p>
<ul>
<li>setAttribute：第一个参数是需要设置的 attribute <strong>属性名称</strong>，然后在着色器中可以使用该名字，属性名命名时最好加一个 a 前缀方便区分。</li>
<li>BufferAttribute：第一个参数是<strong>数据数组</strong>；第二个参数表示组成一个属性的值的数量，如我们要发送一个 (x, y, z) 构成位置，则需要使用 3，示例中每个顶点的随机数只有 1个，因此这个参数使用 1。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = new THREE.PlaneBufferGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">const</span> count = geometry.attributes.position.count</span><br><span class="line"><span class="keyword">const</span> randoms = new Float32Array(count)</span><br><span class="line"><span class="comment">// 使用随机数填充数组</span></span><br><span class="line"><span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  randoms[i] = Math.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加到几何体的属性中</span></span><br><span class="line">geometry.setAttribute(&#x27;aRandom&#x27;, new THREE.BufferAttribute(randoms, <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，我们可以在<strong>顶点着色器</strong>中获取该属性，并使用它移动顶点，可以得到一个如下图所示的一个由<strong>随机尖峰</strong>构成的平面。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">float</span> aRandom;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  modelPosition.z += aRandom * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577180914-4240b40c-cc5c-4e5f-a521-ecd8212ad273.webp#averageHue=%23010200&clientId=u30fc2202-5c6f-4&from=paste&id=uc2c027d8&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue34fb9fa-f157-4423-b062-dd5cb4f0e13&title="></p>
<p><a name="DxNv4"></a></p>
<h3 id="限定变量Varyings"><a href="#限定变量Varyings" class="headerlink" title="限定变量Varyings"></a>限定变量Varyings</h3><p>现在我们若想在<strong>片元着色器</strong>中想使用 aRandom 属性给片元着色，是无法直接使用 attribute 属性变量的。此时，实现这个功能的方法就是将这个值从<strong>顶点着色器发送到片元着色器</strong>，称这种变量为 varying。我们需要在两种着色器中都做如下的操作：</p>
<p>在<strong>顶点着色器</strong>中，我们需要在 main 函数之前创建 varying，将其命名为以 v 作为前缀的变量名 vRandom，然后在 main 函数中给它赋值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vRandom;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vRandom = aRandom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<strong>片元着色器</strong>中，使用相同的方法声明，然后在 main 函数中使用它，可以得到如下的染色效果：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vRandom;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">0.5</span>, vRandom, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577237286-5a0b6f92-14f2-4de8-bd5a-d7edbfbae6a3.webp#averageHue=%23020200&clientId=u30fc2202-5c6f-4&from=paste&id=u48f19863&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u38cfc988-ab24-4ac4-9a8c-9c31a587170&title="><br>:::danger<br>📌 varying的一个有趣之处是，顶点之间的值是线性插值的，如GPU在两个顶点之间绘制一个片元，一个顶点的varying是1.0，另一个顶点的varying是0.0，则该片元值将为0.5。这个特性可以实现平滑的渐变效果。<br>:::<br><a name="Ewl0h"></a></p>
<h3 id="统一变量Uniforms"><a href="#统一变量Uniforms" class="headerlink" title="统一变量Uniforms"></a>统一变量Uniforms</h3><p>uniform 用于将数据从 JavaScript 发送到 着色器。如果我们使用同一个着色器但是参数不同时就可以使用 uniform，使用期间参数还可以改变。在<strong>顶点着色器</strong> 和 片元着色器 中都可以使用 uniform，它的值在每个顶点和每个片元中的数据都是相同的。实际上在我们的代码中已经有 projectionMatrix、viewMatrix、modelMatrix 等 uniform，Three.js 内置创建了它们。<br>现在，我们来创建自己的 uniform。为了将统一变量添加到材质中，需要使用 uniforms 属性。我们将创建一个波动的平面，并使用变量来控制波浪的频率。下面用于控制 <strong>频率</strong> 的变量命名为 uFrequency，特地加了一个 u 字符作为前缀来标识是 uniform 变量，方便在着色器中和其他参数区分开来，但这不是强制的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: <span class="number">10</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，可以在着色器代码中获取 uniform 值，并在 main 函数中使用它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> viewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uFrequency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency) * <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577414544-0ae79204-fb4e-4bab-bbca-53611fada084.webp#averageHue=%23010200&clientId=u30fc2202-5c6f-4&from=paste&id=u40aa8a49&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc2ef55af-fed7-4966-8036-f6af2b24c8f&title=">显示结果和前面的相同，但是现在我们可以在 JavaScript 来控制频率了。我们可以把频率 frequency 改成 vec2 来控制水平和垂直方向的波动，在 Three.js 中可以使用二维向量 THREE.Vector2：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: new THREE.Vector2(<span class="number">10</span>, <span class="number">5</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在着色器中，将 uFrequency 的类型从 float 改为 vec2 并在 z轴 同时应用 uFrequency 的 x值 和 y值，此时我们的模型网格就会同时产生在<strong>水平</strong>和<strong>垂直</strong>方向的波动：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> uFrequency;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency.x) * <span class="number">0.1</span>;</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y) * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577509047-b365cdc7-61fb-4b1d-a679-33d611828dc8.webp#averageHue=%23020200&clientId=u30fc2202-5c6f-4&from=paste&id=u4963fec8&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud7769660-9675-48c9-8293-3e639c4e764&title="><br>让我们再新加一个 uniform 来让平面像在风中飘动的旗帜。我们将使用统一变量 uTime 向着色器发送一个时间值，然后在 sin(…) 函数中使用它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: new THREE.Vector2(<span class="number">10</span>, <span class="number">5</span>) &#125;,</span><br><span class="line">    uTime: &#123; value: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不要忘了在 tick (render函数)页面重绘函数中更新 uTime，我们使用 getElapsedTime 来获取已经花费了多少时间:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tick = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> elapsedTime = clock.getElapsedTime();</span><br><span class="line">  material.uniforms.uTime.value = elapsedTime;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在着色器中获取 uTime 并在 sin(…) 函数中使用它，我们的平面就会看起来像一个在风中飘动的旗帜 🚩：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency.x + uTime) * <span class="number">0.1</span>;</span><br><span class="line">  modelPosition.z += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y + uTime) * <span class="number">0.1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577591182-7d100dd3-841d-4f75-972b-0a64e7feb603.webp#clientId=u30fc2202-5c6f-4&from=paste&id=u2e5b1888&originHeight=945&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8000f8c6-4642-4761-9c42-b4cbe2d21fd&title="><br>我们也可以将 uTime 之前的 + 改为 - 来修改波动的方向。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modelPosition.z += <span class="built_in">sin</span>(modelPosition.x * uFrequency.x - uTime) * <span class="number">0.1</span>;</span><br><span class="line">modelPosition.z += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y - uTime) * <span class="number">0.1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577616202-0c052bd5-3ef8-4877-9530-ff811e7084b1.webp#clientId=u30fc2202-5c6f-4&from=paste&id=u9b59e523&originHeight=945&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf646fb78-fa63-49d9-b4da-7b54e427133&title="><br>:::danger<br>📌 注意，使用uTime时如果直接使用JavaScript的Date.now()，会发现不起作用，因为它的数值对于着色器而言太过庞大，我们不能发送太小或太大的统一变量值。<br>:::<br>虽然现在网格模型具有波动效果，但是它仍然是一个平面网格构成，我们可以修改它的属性来使它看起来更像个旗子 🚩。我们可以修改它的大小比例：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mesh = new THREE.Mesh(geometry, material);</span><br><span class="line">mesh.scale.y = <span class="number">2</span> / <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577671636-91fd4308-d731-43c7-97f1-cf3ba98615cf.webp#clientId=u30fc2202-5c6f-4&from=paste&id=uc2ce14e2&originHeight=945&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0a76e568-86e2-4187-a352-0ee5fdaa2c0&title="><br>在片元着色器中也可以使用 uniform 统一变量，我们添加一个 uColor 作为颜色变量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  vertexShader: testVertexShader,</span><br><span class="line">  fragmentShader: testFragmentShader,</span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    uFrequency: &#123; value: new THREE.Vector2(<span class="number">10</span>, <span class="number">5</span>) &#125;,</span><br><span class="line">    uTime: &#123; value: <span class="number">0</span> &#125;,</span><br><span class="line">    uColor: &#123; value: new THREE.Color(&#x27;orange&#x27;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在片元着色器中获取颜色变量，并将它作为 gl_FragColor 的值，你会看到平面将变成设定的颜色效果：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(uColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577716145-cf954f5e-a81f-49f6-b9f2-514957877e29.webp#averageHue=%23271900&clientId=u30fc2202-5c6f-4&from=paste&id=udf19aaa2&originHeight=750&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u118ba5ba-7c0c-4f8e-b8c0-e228c945d38&title="><br><a name="N4bZh"></a></p>
<h3 id="纹理Textures"><a href="#纹理Textures" class="headerlink" title="纹理Textures"></a>纹理Textures</h3><p>Textures 知识比较复杂，在之前的文章中已经介绍过使用 THREE.TextureLoader 加载纹理，下面我们给着色器材质添加一个图片纹理，并使用 uTexture 统一变量传递给着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.RawShaderMaterial(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  uniforms: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    uTexture: &#123; value: textureLoader.load(&#x27;/textures/flag.png&#x27;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在着色器中，为了使纹理的颜色应用于每个可见片元上，我们需要使用 texture2D(…)，它接收两个参数，第一个是需要应用的纹理即 uTexture，第二个是纹理上拾取颜色的坐标系，这个坐标系其实就是前面讨论的 UV坐标,它的作用是将纹理坐标投射到几何体上。我们用于创建几何体的 PlaneBufferGeometry 会自动生成这个坐标，我们可以通过 geometry.attributes.uv 来查看它。texture2D(…) 的返回结果是一个由 r, g, b, a 构成的 vec4。<br>因为 uv 是一个 attribute 属性，因此需要在<strong>顶点着色器</strong>中需要这样获取它，我们需要在片元着色器中使用它，因此还需要通过 varying 发送到片元着色器，并在 main 函数中更新它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> uv;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vUv = uv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，我们可以在<strong>片元着色器</strong>中获取 vUv 变量，并在 texture2D(…)方法中使用它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> uTexture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> textureColor = <span class="built_in">texture2D</span>(uTexture, vUv);</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = textureColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577861026-96a69468-e1f3-4d49-b8aa-48ebe2d45da9.webp#averageHue=%231a1108&clientId=u30fc2202-5c6f-4&from=paste&id=u7f4f2384&originHeight=829&originWidth=1200&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3af20e4a-f957-4753-ac23-f129725678d&title="></p>
<p><a name="A9vYv"></a></p>
<h3 id="颜色变化"><a href="#颜色变化" class="headerlink" title="颜色变化"></a>颜色变化</h3><p>现在虽然有了图片贴图，但是旗子 🚩 的明暗颜色变化还不太明显，下面我们将为它添加一些阴影变化。<br>首先在<strong>顶点着色器</strong>中，我们将把风的高程存储 elevation 变量中，然后通过 varying 发送到<strong>片元着色器</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vElevation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> elevation = <span class="built_in">sin</span>(modelPosition.x * uFrequency.x - uTime) * <span class="number">0.1</span>;</span><br><span class="line">  elevation += <span class="built_in">sin</span>(modelPosition.y * uFrequency.y - uTime) * <span class="number">0.1</span>;</span><br><span class="line">  modelPosition.z += elevation;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vElevation = elevation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在<strong>片元着色器</strong>中获取 vElevation，用它来改变 textureColor 的 r, g, b属性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">float</span> vElevation;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec4</span> textureColor = <span class="built_in">texture2D</span>(uTexture, vUv);</span><br><span class="line">  textureColor.rgb *= vElevation * <span class="number">2.0</span> + <span class="number">0.5</span>;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = textureColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/40732470/1703577926006-88ad5209-6df1-466d-9eb7-3db2d9b41c23.webp#clientId=u30fc2202-5c6f-4&from=paste&id=u16ff335e&originHeight=884&originWidth=1279&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u098185b6-684f-4c3a-bafe-1eaadb8d2c3&title="></p>
<p><a name="Cbg71"></a></p>
<h3 id="着色器材质ShaderMaterial"><a href="#着色器材质ShaderMaterial" class="headerlink" title="着色器材质ShaderMaterial"></a>着色器材质ShaderMaterial</h3><p>上面所有内容，为了深入理解着色器的原理，我们使用的是 RawShaderMaterial，接下来我们使用<strong>更简单</strong>的 ShaderMaterial 来重构上面完成的所有功能。ShaderMaterial 和 RawShaderMaterial 的工作原理其实是一样的，只不过其内置 attributes 和 uniforms，精度 也会自动设置。我们只需按下面流程稍加修改代码即可。<br>在 JavaScript 代码中将材质换为 THREE.ShaderMaterial。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = new THREE.ShaderMaterial(&#123;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后<strong>删除</strong>着色器中以下属性和定义：</p>
<ul>
<li>uniform mat4 projectionMatrix;</li>
<li>uniform mat4 viewMatrix;</li>
<li>uniform mat4 modelMatrix;</li>
<li>attribute vec3 position;</li>
<li>attribute vec2 uv;</li>
<li>precision mediump float;<br><a name="l7dhX"></a></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>查错：因为着色器是对每个片元执行，因此没有日志记录，出错的话很难查找，如果我们忘写了分号，Three.js 会将整个着色器代码打印出来并会提示出错的行号；</li>
<li>调试：调试数值的一种方法是可以在 gl_FragColor 中使用它，虽然不够精确，但是可以看到颜色变化；</li>
<li>GLSLify：一个 node module 模块，可以改对 glsl 文件的处理，通过 glslify 我们可以像模块一样导入和导出 glsl 代码。你可以使用 glslify-loader 并将其加到 webpack 配置中。<br><a name="LINe3"></a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>了解什么是着色器</li>
<li>了解为什么要使用着色器</li>
<li>GLSL 语言的基本语法规则</li>
<li>理解 Vertex Shader 顶点着色器</li>
<li>理解 Fragment Shader 片元着色器</li>
<li>掌握 Attributes、Varyings、Uniforms的区别和用法</li>
<li>着色器在两种着色器材质 RawShaderMaterial 和 ShanderMaterial 中的使用方法</li>
<li>使用着色器设置颜色和纹理等</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-25T05:50:41.000Z" title="2023/12/25 13:50:41">2023-12-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T05:51:54.678Z" title="2024/5/27 13:51:54">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></span><span class="level-item">31 minutes read (About 4576 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/25/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%8E%9F%E7%90%86/">渲染管线原理</a></p><div class="content"><meta name="referrer" content="no-referrer">
<a name="Uezi0"></a>

<h2 id="什么是渲染管线"><a href="#什么是渲染管线" class="headerlink" title="什么是渲染管线"></a>什么是渲染管线</h2><p>渲染管线（渲染<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B5%81%E6%B0%B4%E7%BA%BF&spm=1001.2101.3001.7020">流水线</a>）是将三维场景模型转换到屏幕像素空间输出的过程。图形渲染管线接受一组3D坐标，然后把它们转变为屏幕上的有色2D像素输出。<br>流水线可抽象为三个阶段：应用阶段、几何阶段、光栅化阶段。<br>应用阶段：这是一个由开发者完全控制的阶段，在这一阶段将进行数据准备，并通过CPU向GPU输送数据，例如顶点数据、摄像机位置、视锥体数据、场景模型数据、光源等等；此外，为了提高渲染性能，还会对这些数据进行处理，比如剔除不可见物体；最后还要设置每个模型的渲染状态，这些渲染状态包括但不限于所使用的材质、纹理、shader等。这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，通俗来讲渲染图元可以是点、线、面等。<br>几何阶段：几何阶段运行在GPU中，几何阶段用于处理我们要绘制的几何相关事情，它和每个渲染图元打交道。几何阶段最重要的任务是将顶点坐标变换到屏幕空间中。后面会对几何阶段进行更详细的表述。<br>光栅化阶段：光栅化阶段运行在GPU中，其主要任务是决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值，然后进行逐像素处理。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1701914654794-eea686c2-2d46-4437-aad6-803d11c248b8.png#averageHue=%23f0e4c9&clientId=u7ae31f10-a1fb-4&from=paste&id=ub21516be&originHeight=497&originWidth=1453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u92c3684e-c71d-4051-bf3b-42fc265bd0c&title="><br>流水线可抽象为三个阶段：应用阶段、几何阶段、光栅化阶段。<br>应用阶段：这是一个由开发者完全控制的阶段，在这一阶段将进行数据准备，并通过CPU向GPU输送数据，例如顶点数据、摄像机位置、视锥体数据、场景模型数据、光源等等；此外，为了提高渲染性能，还会对这些数据进行处理，比如剔除不可见物体；最后还要设置每个模型的渲染状态，这些渲染状态包括但不限于所使用的材质、纹理、shader等。这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，通俗来讲渲染图元可以是点、线、面等。<br>几何阶段：几何阶段运行在GPU中，几何阶段用于处理我们要绘制的几何相关事情，它和每个渲染图元打交道。几何阶段最重要的任务是将顶点坐标变换到屏幕空间中。后面会对几何阶段进行更详细的表述。<br>光栅化阶段：光栅化阶段运行在GPU中，其主要任务是决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值，然后进行逐像素处理。</p>
<p><a name="WDXbx"></a></p>
<h2 id="CPU和GPU之间的通信"><a href="#CPU和GPU之间的通信" class="headerlink" title="CPU和GPU之间的通信"></a>CPU和GPU之间的通信</h2><p>渲染管线的起点是CPU，CPU与GPU的通信即上文的应用阶段，在这个阶段可分为以下三个步骤：<br>（1）把数据加载到显存：大多数显卡没有直接访问RAM的能力，将数据加载到显存中使GPU能更快的访问这些数据。当把数据加载到显存后，内存中的数据便可以释放了，但对于一些还需要使用的数据则需要继续保留在内存中，如CPU需要网格数据进行碰撞检测。<br>（2）设置渲染状态：渲染状态的一个通俗解释就是，定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器&#x2F;片段着色器、光源属性、材质等。如果不设置渲染状态，那所有的网格将使用同一种渲染，显然这是不希望得到的结果。<br>（3）调用Draw Call：当所有的数据准备好后，CPU就需要调用一个渲染指令告诉GPU，按照上述设置进行渲染，这个渲染命令就是Draw Call。Draw Call命令仅仅会指向一个需要被渲染的图元列表，而不包含任何材质信息，因为这些信息已经在上一个阶段中完成。<strong>执行DrawCall后GPU就会按照渲染流水线进行渲染计算，并输出到显示设备中，所执行的操作便是下述GPU渲染管线的内容。</strong></p>
<blockquote>
<p>💡 Tips：可通过 markdown 语法（<code>+ `code` + </code> + <code>空格</code>）或者快捷键 <code>ctrl/cmd</code> + <code>E</code>快速插入行内代码。</p>
</blockquote>
<p>在文本中使用<code>行内代码</code>，可以顺畅地显示代码变量名。<br><a name="kpfOc"></a></p>
<h2 id="GPU渲染"><a href="#GPU渲染" class="headerlink" title="GPU渲染"></a>GPU渲染</h2><p>上述是对渲染管线抽象的概述，这里开始对每个阶段进行展开。图形渲染管线可以被划分为如下图所示的几个阶段，每个阶段将会把前一个阶段的输出作为输入，所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行，正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个渲染管线阶段运行各自的小程序，从而在图形渲染管线中快速处理数据。</p>
<blockquote>
<p>💡 Tips：GPU具有成千上万的小处理核心，每个核心的运算能力相比GPU要弱得多，但GPU的“人海战术”体现了其强大的并行处理能力，而运行在这些核心上的小程序就叫做Shader。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1701915183806-6aa69330-87c8-4c26-bfc8-be87c711a855.png#averageHue=%23f3f29e&clientId=u7ae31f10-a1fb-4&from=paste&id=u5b218b6c&originHeight=613&originWidth=1404&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0ef47beb-d7df-4c60-a482-ed602c86d21&title="><br>上图所示的渲染管线，绿色部分代表<strong>可编程</strong>的阶段，因此也被称为<strong>可编程渲染管线</strong>（这区别于一些较旧的GPU渲染管线，这种渲染管线只提供一些配置操作，开发者没有对流水线的完全控制权），接下来对各个阶段进行展开。</p>
<p>顶点数据：顶点数据是渲染流水线的输入，顶点数据包括顶点坐标、法线、切线、顶点颜色、纹理坐标等。<br>顶点着色器：顶点着色器的处理单位是顶点，即对于输入的每个顶点都会调用一次顶点着色器。顶点着色器主要功能是进行坐标系变换操作，所输入的顶点坐标等位于模型局部坐标空间，在这一阶段需要将顶点坐标数据变换为到齐次裁剪空间。当顶点坐标被变换到齐次裁剪空间后，通常再由硬件做透视除法，最终得到归一化的设备坐标(NDC)。顶点着色器还可执行顶点光照计算(高洛德着色)，但顶点光照效果通常不尽人意，因此通常在片元着色器中执行逐片元光照计算。<br>曲面细分着色器：曲面细分着色器是一个可选的阶段。曲面细分是利用镶嵌化处理技术对三角形进行细分，以此来增加物体表面的三角面数量。</p>
<blockquote>
<p>💡 在这一阶段，程序员可以进行曲面细分操作，看起来就像在原有的图元内加入了更多的顶点。对于一些有大量曲面的模型，进行曲面细分可以让曲面更加圆润；如果为这些细分的顶点再准备一些位置信息，那么这些细分的顶点将有助于我们展现一个细节更加丰富的模型。这也是贴图置换（Displacement Mapping）的基本思路。</p>
</blockquote>
<p>几何着色器：几何着色器也是一个可选的阶段。顶点着色器以顶点数据作为输入，而几何着色器则以完整的图元(Primitive)作为输入数据。例如，以三角形的三个顶点作为输入，然后输出对应的图元。与顶点着色器不能销毁或创建顶点不同，几何着色器的主要亮点就是可以创建或销毁几何图元，此功能让GPU可以实现一些有趣的效果。例如，根据输入图元类型扩展为一个或更多其他类型的图元，或者不输出任何图元。需要注意的是，几何着色器的输出图元不一定和输入图元相同。几何着色器的一个拿手好戏就是将一个点扩展为一个四边形(即两个三角形)。</p>
<p>裁剪：裁剪操作就是将相机看不到的物体、顶点剔除，使其不被下一阶段处理。只有当图元完全位于视锥体内时，才会将它送到下一阶段，对于部分位于视锥体内的图元，外部的顶点将被剔除掉。由于已经知道在NDC下的顶点位置（即顶点位置在一个立方体内），因此裁剪就变得简单：只需要将图元裁剪到单位立方体内。裁剪这一步骤是硬件的固定操作，因此是不可编程的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1701918271565-2097db69-c1e9-4fed-9d34-c38265304e8a.png#averageHue=%23f4f4f4&clientId=u7ae31f10-a1fb-4&from=paste&id=u85b55520&originHeight=467&originWidth=1557&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u84868c99-d62f-436b-9f9d-1d1cbcb4ef7&title="></p>
<p>屏幕映射：这一步输入的坐标仍是三维坐标（范围在单位立方体内），屏幕映射的任务就是将每个图元的x、y值变换到屏幕坐标系（屏幕坐标系是一个2D空间）。由于输入坐标范围在[-1,1]，因此这是一个拉伸到屏幕分辨率大小的过程。对于输入的坐标z值不做任何处理（实际上屏幕坐标系和z坐标一起构成窗口坐标系），这些值会被一起传递到光栅化阶段。<br>屏幕坐标系在OpenGL和DirectX中的定义方式不同。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1701918287871-4906769d-0d91-4652-9ff1-e84f0196caaa.png#averageHue=%23f6f6f6&clientId=u7ae31f10-a1fb-4&from=paste&id=ucf56294f&originHeight=452&originWidth=1533&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubb4c73f4-36f8-4f07-a807-7d5cbe7cf87&title="></p>
<p>三角形设置：光栅化第的第一个流水线阶段是三角形设置，这个阶段会计算光栅化一个三角形所需的信息。具体来说上一阶段输出的都是三角形的顶点，但如果要得到整个三角形网格对像素的覆盖情况，就必须计算每条边上的像素坐标。为了能计算边界像素的坐标信息，就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。它的输出是为下一阶段做准备的。</p>
<p>三角形遍历：该阶段会检查每个像素是否被一个三角形网格所覆盖。若被覆盖的话就会生成一个片元。而这样一个找到哪些像素被三角形网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换。三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角形网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1701918318317-077d8f34-0808-4b16-99cd-449847651efc.png#averageHue=%23f5f2f0&clientId=u7ae31f10-a1fb-4&from=paste&id=u5e68ea99&originHeight=786&originWidth=1469&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u311ca17e-b08a-406f-9e3b-c26864a6a76&title="></p>
<p>关于三角形设置和三角形遍历，Dmitry V. Sokolov老师的tinyrenderer开源项目中的Lesson1和Lesson2对这部分内容进行了体现。这两节课从使用Bresenham算法绘制一根直线开始直至通过线扫绘制成一个三角形。（根据Dmitry V. Sokolov的说法，正文所述扫描变换似乎是较旧的CPU渲染算法？）<br>关于三角形顶点的插值与三角形的重心坐标系相关，三角形填充也会产生锯齿的问题，相关内容后续进行学习补充。</p>
<p>片元着色器：片元着色器是一个非常重要的可编程着色器阶段，前面的光栅化阶段实际上并不会影响每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的，而片元就负责存储这样一系列信息，<strong>真正会对产生影响的是下一个阶段逐片元操作。</strong><br>片元着色器的输入是上一个阶段对顶点信息进行插值的结果（是根据从顶点着色器输出的数据插值得到的），而它的输出是像素颜色值。这一阶段可以完成很多重要的渲染技术，其中最重要的技术有纹理采样、逐片光照计算等，覆盖片元的纹理坐标是通过前述的阶段的顶点数据插值得到的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1701918375513-494e0634-a239-4288-9766-abc772875713.png#averageHue=%23f6f3e8&clientId=u7ae31f10-a1fb-4&from=paste&id=uf2bc5a64&originHeight=749&originWidth=1243&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3663608a-586d-487f-9705-f54c0246e03&title="></p>
<p><strong>逐片元操作（输出合并）：</strong>逐片元操作是渲染管线的最后一个阶段，这一阶段有几个重要任务：</p>
<p>（1）决定每个片元的可见性，这涉及到很多测试功能，例如<strong>深度测试、模板测试</strong>。<br>模板测试与之相关的是模板缓冲，模板测试通常用来限制渲染的区域，渲染阴影，轮廓渲染等。如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值进行比较，这个比较函数可以是由开发者指定的。模板测试是高度可配置的，无论一个片元有没有经过模板测试，都可以根据模板测试和下面的深度测试结果来修改模板缓冲区。</p>
<p>深度测试同样是高度可配置的，如果开启了深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较，这个比较函数也是可以由开发者设置，通常这个值是小于等于的关系，因为我们总想显示出离相机最近的物体(不包括透明&#x2F;半透明)，而那些被遮挡的就不需要出现在屏幕。如果一个片元通过了测试，那么开发者可以指定是否要用这个片元的深度值覆盖所有的深度值。</p>
<blockquote>
<p>💡 Tips：测试顺序并不是唯一的，逻辑上来说测试是在片元着色器之后进行，但对于大多数GPU而言，会尽可能的在执行片元着色器之前就执行测试操作，从而避免将不需要渲染的图元流入到后续的运算中。但将测试提前可能会与片元着色器中的一些操作冲突，如透明度测试，因此需要对其进行判断。</p>
</blockquote>
<p>（2）如果一个片元通过了所有测试，就需要把这些片元的颜色值和颜色缓冲中已有的颜色值进行混合。<br>颜色混合的一个重要应用就是渲染出透明效果。开发者可以选择开启&#x2F;关闭混合功能，如果没有开启混合，就会直接覆盖掉颜色缓冲区中的颜色。如果开启了混合，GPU会取出片元着色器得到的颜色（源颜色）和颜色缓冲区存在的颜色（目标颜色），之后按照设定的函数进行混合，这个混合函数通常和透明度通道息息相关，例如可以根据透明通道的值进行相加、相减、相乘等。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-09T12:12:41.000Z" title="2023/9/9 20:12:41">2023-09-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-14T03:42:56.609Z" title="2024/3/14 11:42:56">2024-03-14</time></span><span class="level-item"><a class="link-muted" href="/categories/vue/">vue</a></span><span class="level-item">4 minutes read (About 661 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/">IM发送表情（基于quill富文本编辑器）</a></p><div class="content"><p>首先</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-quill-editor --save</span><br></pre></td></tr></table></figure>
<p>main.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import  VueQuillEditor from <span class="string">&#x27;vue-quill-editor&#x27;</span>//调用编辑器</span><br><span class="line">import <span class="string">&#x27;quill/dist/quill.core.css&#x27;</span></span><br><span class="line">import <span class="string">&#x27;quill/dist/quill.snow.css&#x27;</span></span><br><span class="line">import <span class="string">&#x27;quill/dist/quill.bubble.css&#x27;</span></span><br><span class="line">Vue.use(VueQuillEditor)</span><br></pre></td></tr></table></figure>
<p>最近公司在重构im项目，聊天中新增发送表情，有两种实现方法，由于公司现在的项目发送的时候用的不是富文本是输入框，第一种方法基于这种情况也可以实现原理都是一样的</p></div><a class="article-more button is-small is-size-7" href="/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-07T12:42:20.000Z" title="2023/9/7 20:42:20">2023-09-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-03-14T03:42:56.614Z" title="2024/3/14 11:42:56">2024-03-14</time></span><span class="level-item"><a class="link-muted" href="/categories/vue/">vue</a></span><span class="level-item">2 minutes read (About 364 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/07/%E5%9C%A8Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/">在Vue3中使用quill富文本编辑器</a></p><div class="content"><p>首先安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vueup/vue-quill@latest --save</span><br></pre></td></tr></table></figure>
<p>main.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">import App from <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line">import &#123; QuillEditor &#125; from <span class="string">&#x27;@vueup/vue-quill&#x27;</span></span><br><span class="line">import <span class="string">&#x27;@vueup/vue-quill/dist/vue-quill.snow.css&#x27;</span>;</span><br><span class="line">import <span class="string">&#x27;@vueup/vue-quill/dist/vue-quill.bubble.css&#x27;</span></span><br><span class="line">import <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line">import ElementPlus from <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"></span><br><span class="line">import router from <span class="string">&#x27;./router&#x27;</span></span><br><span class="line">import store from <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">const app = createApp(App)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(store)</span><br><span class="line">app.use(router)</span><br><span class="line">app.use(ElementPlus)</span><br><span class="line">app.component(<span class="string">&#x27;QuillEditor&#x27;</span>, QuillEditor)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Myeditor.vue简单封装一下，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 注意区别，content 和 contentType --&gt;</span><br><span class="line">    &lt;QuillEditor</span><br><span class="line">        ref=<span class="string">&quot;quillEditor&quot;</span></span><br><span class="line">        v-model:content=<span class="string">&quot;content&quot;</span></span><br><span class="line">        contentType=<span class="string">&quot;html&quot;</span></span><br><span class="line">        :options=<span class="string">&quot;editorOption&quot;</span></span><br><span class="line">        @blur=<span class="string">&quot;onEditorBlur(<span class="variable">$event</span>)&quot;</span></span><br><span class="line">        @focus=<span class="string">&quot;onEditorFocus(<span class="variable">$event</span>)&quot;</span></span><br><span class="line">        @editorChange=<span class="string">&quot;onEditorChange(<span class="variable">$event</span>)&quot;</span></span><br><span class="line">        @ready=<span class="string">&quot;onEditorReady(<span class="variable">$event</span>)&quot;</span></span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">&quot;insertImg&quot;</span>&gt;插入一张图片&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">&quot;insertText&quot;</span>&gt;插入文字&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref,toRaw,defineEmits,defineExpose  &#125; from <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">// import &#123;Quill&#125; from <span class="string">&quot;@vueup/vue-quill&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//富文本初始化配置</span><br><span class="line">// eslint-disable-next-line no-unused-vars</span><br><span class="line"><span class="built_in">let</span> myQuill</span><br><span class="line">const quillEditor = ref(null)</span><br><span class="line"><span class="built_in">let</span> content = ref(<span class="string">&quot;&quot;</span>);//定义content</span><br><span class="line">//获取ref实例</span><br><span class="line">//富文本面板配置</span><br><span class="line">const editorOption= &#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    toolbar: <span class="literal">false</span>, // 这里将工具栏隐藏</span><br><span class="line">  &#125;,</span><br><span class="line">  placeholder: <span class="string">&#x27;请输入内容...&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">//富文本准备完成</span><br><span class="line">const  onEditorReady =(quill)=&gt;&#123;</span><br><span class="line">  myQuill = quill</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//给父元素传值</span><br><span class="line">const emit = defineEmits([<span class="string">&#x27;getText&#x27;</span>,<span class="string">&#x27;getHtml&#x27;</span>])</span><br><span class="line">const onEditorChange = ()=&gt;&#123;</span><br><span class="line">  const html = toRaw(quillEditor.value).getHTML()</span><br><span class="line">  const myText = toRaw(quillEditor.value).getText()</span><br><span class="line">  const quill = toRaw(quillEditor.value).getQuill()</span><br><span class="line">  emit(<span class="string">&#x27;getText&#x27;</span>,myText)</span><br><span class="line">  emit(<span class="string">&#x27;getHtml&#x27;</span>,html)</span><br><span class="line">  console.log(content.value,<span class="string">&#x27;-----content----&#x27;</span>)</span><br><span class="line">  // console.log(myText,<span class="string">&#x27;-----html----&#x27;</span>)</span><br><span class="line">  console.log(quill,<span class="string">&#x27;-------quillEditor----------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">const onEditorFocus = (e)=&gt;&#123;</span><br><span class="line">  console.log(e,<span class="string">&#x27;--------onEditorFocus--------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">const onEditorBlur = (e)=&gt;&#123;</span><br><span class="line">  console.log(e,<span class="string">&#x27;--------onEditorBlur--------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const insertImg = ()=&gt;&#123;</span><br><span class="line">  const quill = toRaw(quillEditor.value).getQuill()</span><br><span class="line">  quill.insertEmbed(length, <span class="string">&#x27;image&#x27;</span>, <span class="string">&quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;</span>)</span><br><span class="line">  quill.setSelection(length + 1)</span><br><span class="line">  // quill.insertEmbed(quill.selection.savedRange.index,<span class="string">&quot;MsgEmoji&quot;</span>,&#123;src: <span class="string">&quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;</span>, code: <span class="string">&quot;0&quot;</span> &#125;,Quill.sources.USER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const insertText = (value)=&gt;&#123;</span><br><span class="line">  const quill = toRaw(quillEditor.value).getQuill()</span><br><span class="line">  //插入指定表情转移文字</span><br><span class="line">  quill.insertEmbed(quill.selection.savedRange.index, <span class="string">&#x27;text&#x27;</span>, value)</span><br><span class="line">  quill.setSelection(quill.selection.savedRange.index+value.length)</span><br><span class="line">&#125;</span><br><span class="line">//将插入表情的方法暴露给父组件</span><br><span class="line">defineExpose(&#123; insertText &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.ql-editor&#123;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-04T06:27:46.000Z" title="2023/8/4 14:27:46">2023-08-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T07:25:46.498Z" title="2024/5/27 15:25:46">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">区块链系统实现</a></span><span class="level-item">23 minutes read (About 3517 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/04/05-BTC-%E6%8C%96%E7%9F%BF-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">05 BTC-挖矿-区块链系统实现</a></p><div class="content"><meta name="referrer" content="no-referrer">

<p><a name="X8t7u"></a></p>
<h3 id="全节点和轻节点"><a href="#全节点和轻节点" class="headerlink" title="全节点和轻节点"></a>全节点和轻节点</h3><p>之前提到，由于硬件限制，BTC系统中分为轻节点和全节点，下表阐述了全节点和轻节点的区别<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704893265178-06fc259e-2ec5-4b7c-a4c2-14d1a21820a7.png#averageHue=%23f7f6f5&clientId=u01c8d3a0-6bcf-4&from=paste&height=558&id=u6f112a0e&originHeight=558&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=234936&status=done&style=none&taskId=u7a65f749-8b41-4732-86d1-e527835884f&title=&width=1074" alt="image.png"><br>在比特币网络中，大多数节点都是轻节点。如果只是想进行转账操作，不需要挖矿，就无需运行一个全节点。在挖矿 过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，在本地重新组装一个指向最 后这个新合法区块的候选区块，重新开始挖矿。<br>:::info</p>
<ol>
<li>这样是不是有些可惜？之前花费好多资源，全部白挖了。 实际上并不可惜。之前文章中提及，挖矿本身具有无 记忆性，前面无论挖多久，对后续继续挖矿没有影响。</li>
<li>比特币系统如何安全性？ 一是密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账 户上BTC转走。（前提：系统中大多数算力掌握在好人手中） 二是共识机制：保证了恶意交易不被系统承认。<br>:::<br><a name="PsBjp"></a></li>
</ol>
<h3 id="挖矿设备演化"><a href="#挖矿设备演化" class="headerlink" title="挖矿设备演化"></a><strong>挖矿设备演化</strong></h3><p>目前，挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。 普通CPU -&gt; GPU -&gt;ASIC芯片 （挖矿专用矿机）<br>:::info<br>实际上，挖矿本身就是计算，对于普通计算机来说，挖矿过程中大多数内存、硬盘、CPU中大多数部件（用到 指令较少）等都是闲置的，如果用普通计算机专门用于挖矿是根本不划算的。随着挖矿难度提高，用通用计算 机挖矿很快变得无利可图。 所以，挖矿设备转入第二代——GPU(主要用于大规模并行计算，如：深度学习)。 但是，用GPU挖矿，仍然有一定浪费(GPU为通用并行计算设计，挖矿仍然有很多部件闲置。例如：浮点数运算 部件，挖矿过程只使用整数操作，该部分部件根本不会用到)。<br>:::<br>GPU价格上涨，仅仅是深度学习火热导致的吗？实际上，很多GPU被用于了挖矿。<br>:::info<br>当然，目前GPU挖矿也已经不划算了（目前一些新开发货币仍然用GPU挖矿）。所以，开始进入第三代设备： ASIC芯片（专门为挖矿设计的芯片），这种芯片专门为挖矿设计，只能用于特定币种的挖矿。 但ASIC芯片设 计、流片流程很长，假如BTC价格剧烈变化，前期投入很可能会血本无归。所以，ASIC芯片需要提前预订。假 如BTC系统中，算力突然很猛烈增加，一般是一个大的厂商生产出新的ASIC矿机。<br>:::<br>ASIC芯片只能用于挖矿，一旦其过时，便完全作废。<br><strong>思考：ASIC芯片的出现是好事吗？ <strong>很明显，ASIC芯片并不是普通人可以参与的，一定程度上提升了挖矿的门槛，违 背了比特币系统</strong>去中心化</strong>的初衷。理想状态下，所有人用CPU挖矿，这样只要有一台家用计算机便可以参与挖矿。当 然，后续有一些货币便考虑到了这个问题，设计了抗ASIC芯片化的解决方案，后续介绍以太坊时会对这种方案进行介 绍。 但反过来想，如果大家都用ASIC矿机挖矿，如果有人想要颠覆BTC系统，必然会导致BTC价格跳水，从而导致其 所购买ASIC矿机作废，投入成本血本无归。所以，很多人反倒认为ASIC芯片出现，一定程度上并不是坏事。<br><a name="uscOp"></a></p>
<h3 id="大型矿池出现"><a href="#大型矿池出现" class="headerlink" title="大型矿池出现"></a><strong>大型矿池出现</strong></h3><p>:::info<br>挖矿另一个趋势便是大型矿池的出现。对于单个矿工来说，即使使用了ASIC矿机，其算力在整个系统中仍然只 占据很少一部分，即使从平均收益看有利可图，但收入很不稳定。 此外，单个矿工除挖矿还要承担全节点其他 责任，造成了算力的消耗。<br>:::<br>因此，为了解决这些问题，便引入了<strong>矿池</strong>的概念。 矿池的架构如下图，通常是一个全节点驱动多台矿机。矿工只需 要不停计算哈希值，而全节点其他职责由矿主来承担。ASIC芯片只能计算哈希值，不能实现全节点其他功能。此外， 矿池出现解决了单个矿工收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704893568698-e1b03b22-5be5-4542-aabd-3a07fa9a8a9b.png#averageHue=%23f0f0f0&clientId=u01c8d3a0-6bcf-4&from=paste&height=251&id=u928872b1&originHeight=251&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41957&status=done&style=none&taskId=ue60e78a3-7eb0-44c0-b302-d99dfb96a8e&title=&width=706" alt="image.png"><br>所以，必须涉及如何分配的问题。如果分配不公平，挖矿的动力就会减少。<br>矿池一般具有两种组织形式。1.类似大型数据中心（同一机构），集中成千上万矿机进行哈希计算。2.分布式。矿工 与矿主不认识(不同机构)，矿工与矿主联系，自愿加入其矿池，矿主分配任务，矿工进行计算，获得收益后整个矿池 中所有矿工进行利益分配。</p>
<p><a name="JduAJ"></a></p>
<h3 id="矿池利益分配方法"><a href="#矿池利益分配方法" class="headerlink" title="矿池利益分配方法"></a><strong>矿池利益分配方法</strong></h3><p>假使第二种情况，矿工来源于五湖四海（非同一机构），收益应该如何分配？</p>
<ol>
<li>思路一：平均分配，所有人平分出块奖励。 这一点有些类似我国某段历史时期，大家一起”吃大锅饭”，会导致 某些矿工懈怠，不干活（挖矿要费电，需要成本）。 所以，这里也需要进行<strong>按劳分配</strong>，需要一个工作量证明的 方案。如何证明每个矿工所作的工作量呢？</li>
<li>思路二：降低挖矿难度（可行方案）。 假设原本挖矿难度要求，计算所得126位的哈希值前70位都必须为0，现 在降低要求，只需要前60位为0，这样挖矿会更容易挖到。当然，这个哈希是不会被区块链所承认的，我们将其 称为一个share，或almost valid share。矿工每挖到一个share，将其提交给矿主，矿主对其进行记录，作为矿 工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的share数量进行分配。 因 为每个矿工尝试的nonce越多，挖到矿的可能性越大，所能得到的share也会越多，所以这种方案作为工作量证 明方案是可行的。</li>
</ol>
<p>:::info<br>1.思考一：有没有可能，某个矿工平时正常提交share，但真正挖到区块后不提交给矿主而是自己偷偷发布出去，从而避免他人分走挖矿所得到的出块奖励？事实上，这种情况是不可能的。因为每个矿工挖矿任务是矿主分配的。矿主组装区块，交给矿工计算，而区块中铸币交易的收款人地址是矿主，如果矿工修改该地址，计算的nonce值也会作废。<br>2.思考二：如果矿工自己刚开始就自己偷偷组装一个区块，自己挖矿，这样就类似于其脱离了该矿池。因为其自己所组织的区块不会被矿主所认可，其提交的share也不会被认可，也就得不到分配的收益。<br>3.思考三：有没有可能矿工捣乱？平时提交share，等挖到后扔掉区块，不提交？这种可能是有的，如果矿工本身仅仅想捣乱，是可以这么做的。但扔掉区块后，对其本身来说，也没有相应的奖励获得，看似是损人不利己的情况。但是，矿池之间存在竞争关系。有可能为了打击竞争对手，会派出矿机加入竞争对手矿池挖矿，从而起到搞破坏的作用。即只参与其他矿工挖矿分红，自己挖到的区块却丢掉不给他人分。</p>
<p>:::<br><a name="uGZue"></a></p>
<h3 id="关于矿池的一些统计数据（图片源自肖老师课程视频）"><a href="#关于矿池的一些统计数据（图片源自肖老师课程视频）" class="headerlink" title="关于矿池的一些统计数据（图片源自肖老师课程视频）"></a><strong>关于矿池的一些统计数据（图片源自肖老师课程视频）</strong></h3><p>图1：矿池在各个国家分布比例图（2018年） 可见，中国所占矿池比例远远超过其他国家。<img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704893810335-2c686bd7-e320-4e12-a2a0-1e9396f7187e.png#averageHue=%23fcfbfb&clientId=u01c8d3a0-6bcf-4&from=paste&height=449&id=uf690d414&originHeight=449&originWidth=991&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175043&status=done&style=none&taskId=ua18e11b9-87a4-40d5-bfce-be4003a9649&title=&width=991" alt="image.png"><br>图2：2014年图单个矿池算力分布比例图,这个时间，存在一个矿池(GHash.IO)算力比例占据全部算力一半以上，当时引起了恐慌(一个矿池就可以发动51攻 击)。之后，该矿池主动降低了矿池算力（化整为零，实际上仍然存在发动51攻击能力），避免动摇人们对比特币信 心。<img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704893839725-f09800d3-6bb2-4c07-a247-c59fbfa8f629.png#averageHue=%23f9f6f5&clientId=u01c8d3a0-6bcf-4&from=paste&height=529&id=u582995bf&originHeight=529&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85771&status=done&style=none&taskId=u605837bd-b659-4f74-a483-2448fb9e799&title=&width=1114" alt="image.png"><br>图3：2018年图单个矿池算力分布比例图 表面看上去是安全的，但实际实上某个机构如果有超过50%算力，其必然不会将其放入一个矿池中。而是将其分散隐藏，真正需要发动攻击时候再集中起来发动51攻击（注意：矿工转换矿池是很容易的）。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704893865733-be071034-354c-42e8-af9b-422a2a4ea314.png#averageHue=%23e8ca9b&clientId=u01c8d3a0-6bcf-4&from=paste&height=546&id=udf5c5196&originHeight=546&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=207190&status=done&style=none&taskId=ue723099e-6bdd-442d-b1f5-c9f105d0cdf&title=&width=1074" alt="image.png"><br>:::info<br>由这些数据可以得知，矿池本身对BTC系统带来了较大威胁。某个恶意用户如果想发动攻击，以前需要自己达 到51%算力，现在自己只需要作为矿主，只需要很少一部分算力就可以了。只要能够吸引到足够多的不明真相 的矿工，便可以用较低成本实现51攻击。 当然，矿主经验管理矿池，也需要收取一定比例(出块奖励、交易费) 作为管理费用。如果恶意者想要攻击系统，会将管理费降低甚至赔本吸引足够多矿工加入。这便使得发动51% 攻击变得容易了起来。<br>:::<br><a name="EEY7K"></a></p>
<h3 id="51-算力矿池可以发动哪些攻击"><a href="#51-算力矿池可以发动哪些攻击" class="headerlink" title="51%算力矿池可以发动哪些攻击"></a><strong>51%算力矿池可以发动哪些攻击</strong></h3><ol>
<li>分叉攻击 对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。<br>:::info<br>矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被 利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。 此外，51%攻击只是一个概率问 题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。<br>:::</li>
<li>封锁交易（Boycott） 假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发 布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。<br>:::info<br>像不像即当裁判又当运动员？”堂下何人状告本官“？<br>:::</li>
<li>盗币（将他人账户BTC转走） 这个是<strong>不可能</strong>的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签 名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。<br><a name="SBEnW"></a></li>
</ol>
<h3 id="矿池出现的优劣"><a href="#矿池出现的优劣" class="headerlink" title="矿池出现的优劣"></a><strong>矿池出现的优劣</strong></h3><p>优点：解决了矿工收入不稳定的问题，减轻了矿工的负担。 <br>缺点：威胁到了区块链系统的安全，使得51%攻击变得 容易起来。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-03T06:27:46.000Z" title="2023/8/3 14:27:46">2023-08-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T07:20:06.759Z" title="2024/5/27 15:20:06">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">区块链系统实现</a></span><span class="level-item">11 minutes read (About 1609 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/03/04-BTC-%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">03 BTC-系统实现-区块链系统实现</a></p><div class="content"><meta name="referrer" content="no-referrer">

<p><a name="Y7GUo"></a></p>
<h3 id="UTXO-Unspent-Transaction-Output尚未被花掉的交易输出"><a href="#UTXO-Unspent-Transaction-Output尚未被花掉的交易输出" class="headerlink" title="UTXO(Unspent Transaction Output尚未被花掉的交易输出)"></a><strong>UTXO(Unspent Transaction Output尚未被花掉的交易输出)</strong></h3><p>区块链是一个去中心化的账本，比特币采用了 **基于交易的账本模式 **。然而，系统中并无显示记录账户包含比特币 数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为 **UTXO(Unspent Transaction Output尚未被花掉的交易输出) **的数据结构。<br>:::info<br>如图，A转给B五个BTC，转给C3个BTC，B将5个BTC花掉，则该交易记录不保存在UTXO中，C没有花掉，则该交易记录保存在UTXO中<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704891960226-884f43ee-5d0e-4e2c-9f1b-3bdc5cd6e230.png#averageHue=%23fafafa&clientId=u107854ae-21e5-4&from=paste&height=198&id=u6cb6a96f&originHeight=198&originWidth=789&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12902&status=done&style=none&taskId=ubfa3f159-808d-4ad7-abf3-c59630dfbd5&title=&width=789" alt="image.png"><br>:::<br>UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出。<br>:::info<br>为什么要维护这样一个数据结构？？？为了防范“双花攻击”，判断一个交易是否合法，要查一下想要花掉的 BTC是否在该集合中，只有在集合中才是合法的。如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么根本不存在，要么已经被花过。所以，全节点需要在内存中维护一个UTXO，从而便于快速检测double spending（双花攻击）。<br>:::<br>每个交易会消耗输出，但也会产生新的输出。<br>:::info<br>如图，A转给B5个BTC，之后B将其转给D，则UTXO中会删掉A-&gt;B这一交易记录，同时会添加B-&gt;D这一交易记录。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704892031413-c48d4268-b6e7-46a2-9648-a8c744cad736.png#averageHue=%23f8f8f8&clientId=u107854ae-21e5-4&from=paste&height=262&id=u2c421535&originHeight=262&originWidth=987&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21997&status=done&style=none&taskId=u6188eec4-a617-4c51-a102-c36fc2c1524&title=&width=987" alt="image.png"><br>假如有人收到BTC转账，但一直不花，那么这个信息会一直保存在UTXO中。这种情况可能是该用户不想花这些BTC(如：中本聪) ，也有可能是忘记了私钥导致无法花掉。所以，UTXO是逐渐增大的，但该数据目前来说，一个普通的服务器硬盘中是可以完全保存这些数据的。<br>:::<br>每个交易可以有多个输入，也可以有多个输出，但输入之和要等于输出之和（total inputs &#x3D; total outputs）。存在一些交易的total inputs 略大于 total outputs，这部分差额便作为交易费，给了获得记账权的节点。在公开课笔记3中最后提及到“区块中保存交易记录，如果仅仅设置出块奖励，那么，会不会存在节点只想发布区块获得出块奖励而不想打包交易？” 因此，BTC系统设计了Tranction fee（交易费），对于获得记账权节点来说，除了出块奖励之外，还可以得到打包交易的交易费。但目前来说，交易费远远小于出块奖励。等到未来出块奖励变少，可能区块链的维护便主要依赖于交易费了。<br>:::info<br>BTC系统中每21万个区块，BTC出块奖励减半。根据下图计算，基本上出块奖励每4年减半。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704892229865-ad0db139-bd2e-42c8-a9a2-e224633a75cc.png#averageHue=%23374d46&clientId=u107854ae-21e5-4&from=paste&height=290&id=ub9e73e29&originHeight=290&originWidth=674&originalType=binary&ratio=1&rotation=0&showTitle=false&size=202164&status=done&style=none&taskId=ub7e3b110-e97b-4f53-a667-a6ced26579a&title=&width=674" alt="image.png"><br>比特币是基于交易的模式，与之对应，还有一种基于账户的模式（如：以太坊）。基于账户的模式要求，系统中显示记录账户余额。也就是说，可以直接查询当前账户余额是多少货币。可以看到，比特币这种模式，隐私性较好，但其也付出一定代价。在进行交易时，因为没有账户这一概念，无法知道账户剩余多少BTC,所以必须说明币的来源（防止双花攻击）。而基于账户的模式，则天然地避免了这种缺陷，转账交易就是对一（多 个）账户余额的数字减和另一个（多个）账户余额的数字<br>:::<br><a name="JcV6v"></a></p>
<h3 id="BTC系统中具体的区块信息"><a href="#BTC系统中具体的区块信息" class="headerlink" title="BTC系统中具体的区块信息"></a><strong>BTC系统中具体的区块信息</strong></h3><p>如下图所示，为一个区块的信息（取自视频中截图，源自blockchain.info）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704892410921-36d25d29-3c6a-40f2-ab97-8a2b89c73131.png#averageHue=%23fbfafa&clientId=u107854ae-21e5-4&from=paste&height=434&id=u54ad841e&originHeight=434&originWidth=891&originalType=binary&ratio=1&rotation=0&showTitle=false&size=198725&status=done&style=none&taskId=u17b1cd95-7c41-4ae8-b376-dfdf230ed31&title=&width=891" alt="image.png"><br>:::info<br>什么是挖矿？可以看到，区块哈希与前一区块哈希都是以一长串0开头的，挖矿本身就是尝试各种nonce，使得产生的区块哈希值小于等于目标阈值。该目标阈值，表示成16进制，就是前面含有一长串的0<br>:::<br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2024/pdf/40732470/1704892668797-2107cd16-1b09-4bd6-b517-48b45840d2b5.pdf?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2024/pdf/40732470/1704892668797-2107cd16-1b09-4bd6-b517-48b45840d2b5.pdf%22,%22name%22:%22%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%82%96%E8%87%BB%E8%80%81%E5%B8%88%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94BTC%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%AF%87.pdf%22,%22size%22:1745548,%22ext%22:%22pdf%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u8833009c-f9a0-4500-bd08-6213e24f1e4%22,%22taskType%22:%22upload%22,%22type%22:%22application/pdf%22,%22__spacing%22:%22both%22,%22id%22:%22u522c1527%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">北京大学肖臻老师《区块链技术与应用》公开课笔记5——BTC具体实现篇.pdf</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-02T06:27:46.000Z" title="2023/8/2 14:27:46">2023-08-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T07:19:23.683Z" title="2024/5/27 15:19:23">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">区块链系统实现</a></span><span class="level-item">14 minutes read (About 2102 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/02/02BTC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">02BTC-数据结构-区块链系统实现</a></p><div class="content"><meta name="referrer" content="no-referrer">
<a name="cKP6j"></a>

<h3 id="Hash-pointer（哈希指针）"><a href="#Hash-pointer（哈希指针）" class="headerlink" title="Hash pointer（哈希指针）"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020">Hash</a> pointer（哈希指针）</h3><ul>
<li>指针</li>
</ul>
<p>在程序运行过程中，需要用到数据。最简单的是直接获取数据，但当数据本身较大，需要占用较大空间时，明显会造成一定麻烦。因此，可以引入<strong>指针</strong>这一概念。当需要获取数据时，只需要按照指针所给的地址，去对应的位置读取数据即可，这样大大节省了内存空间。<br>:::info<br>区块链结构本身为一条链表，节点为区块。而传统链表实现，便是通过指针将各个节点串联起来而称为最终的链。如下便是我们最常见的一个链表：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704185458328-b016a2de-b261-4e83-9ec4-63ca6ef0b132.png#averageHue=%23ececec&clientId=u99aa17ce-4678-4&from=paste&id=uaf83b337&originHeight=71&originWidth=418&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u060f6674-dcea-4879-b220-a39382ce344&title="><br>但在区块链系统中，并未采用指针，而是使用了<strong>哈希指针</strong><br>:::</p>
<ul>
<li>哈希指针</li>
</ul>
<p>如下图对于该节点，我们可以看到有两个指针指向这个节点（实际上为一个），其中P为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704185614246-2eeca89e-78b8-4d04-a7eb-ffb157a47a53.png#averageHue=%23f7f7f7&clientId=u99aa17ce-4678-4&from=paste&id=u7674203c&originHeight=123&originWidth=213&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc29e769d-12b9-4c05-8cba-c9c3d8d973f&title="><br>:::info<br>在比特币中，其最基本的数据结构便是一个个区块形成的区块链。<br>:::</p>
<ul>
<li>区块链与链表区别：哈希指针代替普通指针</li>
</ul>
<p>如图为一个简单的区块链。其中，每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。需要注意的是，本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704186325485-763dfcde-6d3f-4043-bf88-4268131d6377.png#averageHue=%23f0f0f0&clientId=u99aa17ce-4678-4&from=paste&id=u4a99a7f5&originHeight=103&originWidth=444&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9bf5b317-92d3-43ef-9266-ba2b1b8e9ba&title="><br>:::info<br>如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。<br>在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。<br>:::<br><a name="N3u7w"></a></p>
<h3 id="Merkle-Tree-默克尔树"><a href="#Merkle-Tree-默克尔树" class="headerlink" title="Merkle Tree(默克尔树)"></a>Merkle Tree(默克尔树)</h3><p>Merkle Tree是比特币系统中又一个重要的数据结构<br>首先，回顾一下Binary Tree(如果不懂请自行复习数据结构)。Merkle Tree和Binary Tree的区别有哪些？<br><a name="USr9t"></a></p>
<h4 id="Merkle-Tree用哈希指针代替了普通指针"><a href="#Merkle-Tree用哈希指针代替了普通指针" class="headerlink" title="Merkle Tree用哈希指针代替了普通指针"></a>Merkle Tree用哈希指针代替了普通指针</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704186450708-eb6a2db2-fdd5-429b-9f8d-d4a810dc373b.png#averageHue=%23f2f2f2&clientId=u99aa17ce-4678-4&from=paste&id=u4eaff97a&originHeight=221&originWidth=442&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8fe02028-6873-4591-aff3-66e31a298a3&title=">&lt;br &#x2F;&gt;上图即为一个简单的Merkle Tree，其中A、B、C、D为数据块。可见，A和B各有一个哈希值，将其合并放在一个节点中，C和D同样操作，而后，针对得到的两个节点分别取哈希，又可以得到两个新的哈希值，即为图中根节点。<br>实际中，在区块块头中存储的是<strong>根节点</strong>的哈希值（对其再取一次哈希）。如视频中图片：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704186499642-9b7a696c-3b56-4373-995a-66ed3e2f2bac.png#averageHue=%233f5751&clientId=u99aa17ce-4678-4&from=paste&id=u2bde4408&originHeight=321&originWidth=750&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3f7d6bde-d09d-4658-a9de-9873d7002b6&title="><br>该数据结构的优点在于：只需要记住Root Hash（根哈希值），便可以检测出对树中任何部位的修改。<br>例如，所绘制Merkle Tree中节点B发生了改变，则对应的第二层第一个节点中第二个哈希值便也会发生改变，进而根节点中第一个哈希值也会发生改变，从而导致根哈希值也发生了改变。<br>:::info<br>在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过Merkle Tree的形式组织在一起。区块本身分为两部分（<strong>块头和块身</strong>），在块头中存在有<strong>根哈希值</strong>（没有交易的具体信息），块身中存在交易列表。<br>:::<br><a name="bArwI"></a></p>
<h4 id="Merkle-Tree的实际用途"><a href="#Merkle-Tree的实际用途" class="headerlink" title="Merkle Tree的实际用途"></a>Merkle Tree的实际用途</h4><p>Merkle Tree可以用于提供Merkle Proof。关于Merkle proof，需要先了解比特币系统中节点。比特币中节点分为<strong>轻节点</strong>和<strong>全节点</strong>。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。<br>:::info<br>为什么要分轻节点和全节点？<br>因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容即可。<br>:::<br>当需要向轻节点证明某条交易是否被写入区块链，便需要用到Merkle proof。我们将交易到根节点这一条路径称为Merkle proof，全节点将整个Merkle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704186687202-78ff9830-f8a2-4891-8817-a1587771ac5d.png#averageHue=%23e6d8ae&clientId=u99aa17ce-4678-4&from=paste&id=u2166d52c&originHeight=418&originWidth=823&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua1286417-187d-412e-a4e2-6120d3c76b3&title="><br>:::info<br>思考：是否存在不安全的情况？如下图我们要验证B，但是H(1)和H(4)都是全节点提供的。全节点可否修改B，通过H(1)调整，使得修改过后的H(1)和轻节点计算出的H(2)一起取得哈希仍然为H(3)？<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704186834179-3dd8b567-9e8d-448f-a7f7-c1579542e3eb.png#averageHue=%23f3f3f3&clientId=u99aa17ce-4678-4&from=paste&id=uc8a46977&originHeight=250&originWidth=445&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u43a3ff75-746b-4d20-96a2-3b47389806a&title="><br>实际上，这种情况为人为制造哈希碰撞。由于哈希函数的collision resistance性质，这种情况是不会发生的。从而，保证了系统的不可篡改性。同时，这样一个Merkle Proof的事件复杂度为O(log n),非常高效【证明交易存在】。如果要证明交易不存在，如果不对叶节点规定排序顺序，没有一个效率较高的方法证明不存在。在比特币系统中，没有相应的需求，所以在比特币系统中并没有对Merkle Tree进行排序。<br>:::</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-02T06:27:46.000Z" title="2023/8/2 14:27:46">2023-08-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T07:19:23.725Z" title="2024/5/27 15:19:23">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">区块链系统实现</a></span><span class="level-item">31 minutes read (About 4614 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/02/03-BTC-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">03 BTC-共识协议-区块链系统实现</a></p><div class="content"><meta name="referrer" content="no-referrer">

<p><a name="NKxq0"></a></p>
<h3 id="数字货币中经常出现的问题"><a href="#数字货币中经常出现的问题" class="headerlink" title="数字货币中经常出现的问题"></a><strong>数字货币中经常出现的问题</strong></h3><ul>
<li>双花攻击: 数字货币本身为带有签名的数据文件，可以进行复制。即：对用户来说，可以将同一货币花费两次。<br>:::info<br>修改：对货币添加唯一编号（不可篡改），每次支付向货币发行单位查询真伪。该方法每次交易都需要依赖于第三方机构来判断货币真伪且防止双花攻击。是一个典型的第三方中心化方案。现实中，我们通过支付宝、微信、信用卡等各种支付方式交易时，必然会依赖于第三方机构。由于这些第三方机构具有较高的可信度，有政府进行背书，所以可以采用这种方案。但是，很多场景下，并不存在这样一个可信赖的第三方机构。基于这个背景，以去中心化思想为核心的比特币系统便吸引了人们的注意力。<br>:::<br><a name="Fvupn"></a></li>
</ul>
<h3 id="去中心化需要解决的问题"><a href="#去中心化需要解决的问题" class="headerlink" title="去中心化需要解决的问题"></a><strong>去中心化需要解决的问题</strong></h3><ul>
<li><p>数字货币的发行由谁执行？如何发行？发行多少？什么时候发行？在传统中心化货币体系中，这些问题我们可以交给第三方机构（如：央行）。当引入去中心化思想后，系统中节点平等，交易不通过第三方，那么货币发行权的分配必然是一个需要解决的问题。<br>:::info<br>在比特币系统中由挖矿来决定货币发行权和发行量。<br>:::</p>
</li>
<li><p>如何验证交易是否有效？如何防止双花攻击？同样，在传统中心化体系中，该问题的解决由第三方机构来完成。而剔除这一机构后，交易双方如何能够验证交易的有效性？如何防止系统中恶意用户作恶获取收益？这也是去中心化交易系统需要解决的问题。<br>:::info<br>该问题的解决，依赖于系统中维护的一个数据结构，记录货币的使用情况（是否被花过？被谁花过？）。该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。<br>:::<br><a name="TV507"></a></p>
</li>
</ul>
<h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h3><p>如下，假定A获得<strong>铸币权</strong>，新发布了10个比特币（该交易称为铸币交易）。A将10个比特币转给了B(5个)和C(5 个)，A对该交易进行签名，同时该交易需要说明所花掉10个比特币来源（来自铸币交易）。之后，B将自己的5个比特币转给C(2个)和D(3个)，该交易需要B的签名，该交易需要说明所花掉的5个比特币来自于第二个交易中。然后，C将自己所拥有的全部7个比特币都转给E，并对该交易签名，可以发现该交易中C的比特币来源于两个交易中。这样就构成了一个简单的区块链。<strong>【红色部分为比特币来源】</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704249570499-2c9cba65-a575-4a60-bb36-c82944269f9d.png#averageHue=%233b574f&clientId=u16efc280-d0e4-4&from=paste&height=201&id=uc7112da5&originHeight=201&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110917&status=done&style=none&taskId=u5b79a55c-f621-47b9-804a-f4d4aac74c7&title=&width=474" alt="image.png"><br>:::info<br>需要注意的是，这里面有两种哈希指针。第一种为指向前面的区块（白色），使得各个区块形成链，第二种则是为了说明比特币的来源（红色）。说明比特币的来源并非凭空捏造，可以防止双花攻击。在进行交易时，需要付款人的签名和收款人的地址，在比特币系统中，该地址即为收款人的公钥的哈希。可以将其视为银行账 户，根据此进行转账交易。（虽然公钥可以公开，但实际中更多公开的是公钥的哈希）在交易中，收款方需要知道付款方的公钥，从而验证A签名是否有效。即A需要提供自己的公钥，如果所提供公钥与铸币交易中。（实际上其他节点都需要知道付款方公钥，验证交易合法性）实际中A转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造A的公钥来“偷”走A的比特币。在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。在该图中，一个区块仅含有一个交易，实际中一个区块中包含多个交易，交易通过Markle Tree（详见比特币数据结构篇中）组织起来，在区块中存储。<br>:::<br><a name="TZ9Lr"></a></p>
<h3 id="比特币区块信息"><a href="#比特币区块信息" class="headerlink" title="比特币区块信息"></a><strong>比特币区块信息</strong></h3><table>
<thead>
<tr>
<th><strong>block Header（区块宏观信息）</strong></th>
<th><strong>block body(略)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Version(版本协议)</td>
<td>…</td>
</tr>
<tr>
<td>Hash of previous block header（指向前一个区块指针）</td>
<td>…</td>
</tr>
<tr>
<td>Merkle root hash（默克尔树根哈希值）</td>
<td>…</td>
</tr>
<tr>
<td>target（挖矿难度目标阈值）</td>
<td>…</td>
</tr>
<tr>
<td>nonce（随机数）</td>
<td>…</td>
</tr>
</tbody></table>
<p><a name="g7Swx"></a></p>
<h3 id="什么是挖矿-怎么获得记账权"><a href="#什么是挖矿-怎么获得记账权" class="headerlink" title="什么是挖矿(怎么获得记账权)"></a><strong>什么是挖矿(怎么获得记账权)</strong></h3><p>简单的说挖矿就是通过输入一个随机值用固定工作量证明哈希函数求解一个目标哈希值<br><a name="JytDZ"></a></p>
<h4 id="工作量证明函数-固定工作量证明哈希函数"><a href="#工作量证明函数-固定工作量证明哈希函数" class="headerlink" title="工作量证明函数(固定工作量证明哈希函数)"></a>工作量证明函数(固定工作量证明哈希函数)</h4><p>比特币系统中使用的工作量证明函正是 SHA256。<br>SHA 是安全散列算法（Secure Hash Algorithm）的缩写，是一个密码散列函数家族。这一组函数是由美国国家安全局（NSA）设计，美国国家标准与技术研究院（NIST） 发布的，主要适用于数字签名标准。SHA256 就是这个函数家族中的一个，是输出值为 256 位的哈希算法。到目前为止，还没有出现对 SHA256 算法的有效攻击。<br><a name="BJJPu"></a></p>
<h4 id="区块-输入的一个随机值"><a href="#区块-输入的一个随机值" class="headerlink" title="区块(输入的一个随机值)"></a>区块(输入的一个随机值)</h4><p>比特币的区块由区块头及该区块所包含的交易列表组成。区块头的大小为 80 字节，由 4 字节的版本号、32 字节的上一个区块的散列值、32 字节的 Merkle Root Hash、4 字节的时间缀（当前时间）、4 字节的当前难度值、4 字节的随机数组成。区块包含的交易列表则附加在区块头后面，其中的第一笔交易是 coinbase 交易，这是一笔为了让矿工获得奖励及手续费的特殊交易。<br>区块的大致结构如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1702543435582-3beabea1-d99a-440b-b10e-132fe760f14b.png#averageHue=%23edecdc&clientId=u61d3ad66-0a13-4&from=paste&id=ud2906d55&originHeight=324&originWidth=553&originalType=url&ratio=1&rotation=0&showTitle=false&size=122493&status=done&style=none&taskId=ueadf21b0-9977-4b23-b631-db3d1885e32&title=" alt="image.png"><br>拥有 80 字节固定长度的区块头，就是用于比特币工作量证明的输入字符串。因此，为了使区块头能体现区块所包含的所有交易，在区块的构造过程中，需要将该区块要包含的交易列表，通过 Merkle Tree 算法生成 Merkle Root Hash，并以此作为交易列表的摘要存到区块头中。其中 Merkle Tree 的算法图解如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1702543435552-a1929b38-0a80-45e5-8816-b8de95901d71.png#averageHue=%23ebebeb&clientId=u61d3ad66-0a13-4&from=paste&id=ub670ae21&originHeight=271&originWidth=555&originalType=url&ratio=1&rotation=0&showTitle=false&size=37469&status=done&style=none&taskId=ud273c20b-bea4-4de5-91b0-d8d572d26e9&title=" alt="image.png"><br><a name="Y5Zrg"></a></p>
<h4 id="难度值"><a href="#难度值" class="headerlink" title="难度值"></a>难度值</h4><p>难度值（difficulty）是矿工们在挖矿时候的重要参考指标，它决定了矿工大约需要经过多少次哈希运算才能产生一个合法的区块。比特币的区块大约每 10 分钟生成一个，如果要在不同的全网算力条件下，新区块的产生保持都基本这个速率，难度值必须根据全网算力的变化进行调整。简单地说，难度值被设定在无论挖矿能力如何，新区块产生速率都保持在 10 分钟一个。<br>难度的调整是在每个完整节点中独立自动发生的。每 2016 个区块，所有节点都会按统一的公式自动调整难度，这个公式是由最新 2016 个区块的花费时长与期望时长（期望时长为 20160 分钟即两周，是按每 10 分钟一个区块的产生速率计算出的总时长）比较得出的，根据实际时长与期望时长的比值，进行相应调整（或变难或变易）。也就是说，如果区块产生的速率比 10 分钟快则增加难度，比 10 分钟慢则降低难度。<br>这个公式可以总结为如下形式：<br>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新难度值 = 旧难度值 * ( 过去 2016 个区块花费时长 / 20160 分钟 )</span><br></pre></td></tr></table></figure>

<p><a name="m5wBU"></a></p>
<h4 id="目标值-目标哈希值"><a href="#目标值-目标哈希值" class="headerlink" title="目标值(目标哈希值)"></a>目标值(目标哈希值)</h4><p>工作量证明需要有一个目标值。比特币工作量证明的目标值（Target）的计算公式如下：<br>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目标值 = 最大目标值 / 难度值</span><br><span class="line"></span><br><span class="line">其中最大目标值为一个恒定值：</span><br><span class="line"></span><br><span class="line">0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure>

<p>目标值的大小与难度值成反比。比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值。<br>我们也可以简单理解成，比特币工作量证明的过程，就是通过不停的变换区块头（即尝试不同的 nouce 值）作为输入进行 SHA256 哈希运算，找出一个特定格式哈希值的过程（即要求有一定数量的前导 0）。而要求的前导 0 的个数越多，代表难度越大。<br><a name="xWARy"></a></p>
<h4 id="工作量证明的过程"><a href="#工作量证明的过程" class="headerlink" title="工作量证明的过程"></a>工作量证明的过程</h4><p>我们可以把比特币矿工解这道工作量证明迷题的步骤大致归纳如下：</p>
<ol>
<li>生成 Coinbase 交易，并与其他所有准备打包进区块的交易组成交易列表，通过 Merkle Tree 算法生成 Merkle Root Hash</li>
<li>把 Merkle Root Hash 及其他相关字段组装成区块头，将区块头的 80 字节数据（Block Header）作为工作量证明的输入</li>
<li>不停的变更区块头中的随机数即 nonce 的数值，并对每次变更后的的区块头做双重 SHA256 运算（即 SHA256(SHA256(Block_Header))），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。获得记账权</li>
</ol>
<p>该过程可以用下图表示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1702543435581-57d990a7-43d1-4af2-a9e0-7b45f28b8a7f.png#averageHue=%23f5f5f5&clientId=u61d3ad66-0a13-4&from=paste&id=u137e29b9&originHeight=323&originWidth=489&originalType=url&ratio=1&rotation=0&showTitle=false&size=64830&status=done&style=none&taskId=ub001875d-d602-4575-a881-bd7abb4690b&title=" alt="image.png"><br><a name="Deb2G"></a></p>
<h3 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a><strong>分布式共识</strong></h3><p>可否各个节点独立完成区块链构建？很明显不行，各个节点独立打包交易，形成区块链，必然无法避免区块链内容不一致。从分布式系统角度来说，账本内容需要取得分布式共识，从而保证区块链内容在不同节点上的一致性。根据FLP不可能结论，在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。根据CAP Theorem（Consistency一致性、Availability可靠性、Partition tolerance容错性），任何一个分布式系统 中，最多只能满足其中两个性质。分布式共识中协议Paxos 可以保证Consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。<br><a name="moBQL"></a></p>
<h3 id="比特币共识协议"><a href="#比特币共识协议" class="headerlink" title="比特币共识协议"></a><strong>比特币共识协议</strong></h3><p>:::info<br>背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。<br>想法1：直接投票某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。<br>存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。<br>存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。<br>存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。更大的一个问题—— membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击）。所以，这种简单的投票方案也是不可行的。<br>:::<br>比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。<code>[H(block header)&lt;=target]</code>当某个节点找到符合要求的nonce，便获得了<strong>记账权</strong>，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。<br>:::info<br>猜想:  会不会合法区块被拒绝？如图所示。发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。这样，也就会导致合法区块被拒绝<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704253235152-81ae5453-f2d4-4303-8b7f-b1f262783d23.png#averageHue=%23f5f5f5&clientId=u9e5d8d63-569b-4&from=paste&height=118&id=ub60f2c2f&originHeight=118&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6775&status=done&style=none&taskId=u17466082-8939-41ec-85f6-fa8661f8ab0&title=&width=430" alt="image.png"><br>分叉攻击如图所示，A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/40732470/1704253509457-d8898a72-937c-4449-992a-3f8a3283ad77.png#averageHue=%23f6f5f5&clientId=u9e5d8d63-569b-4&from=paste&height=178&id=ua65af8d2&originHeight=178&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10385&status=done&style=none&taskId=u58237b64-4c65-47e7-bc5c-d9322c0349d&title=&width=543" alt="image.png"><br>此外，区块链正常运行场景下，也可能会发生分叉。当两个节点同时获得记账权时，会有两个等长的合法链。在缺省情况下，节点接收最先听到的区块，该节点会沿着该区块继续延续。但随着时间延续，必然有一个链胜出，由此保证了区块链的一致性。（被扔掉的区块称为“孤儿区块”）可见，依赖于算力竞争，有效的防止了“女巫攻击”。<br>:::<br><a name="AtLfW"></a></p>
<h3 id="比特币激励机制"><a href="#比特币激励机制" class="headerlink" title="比特币激励机制"></a><strong>比特币激励机制</strong></h3><p>:::info<br>为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？<br>:::<br>比特币系统设计之初便考虑到了这个问题，那就是引入激励机制。比特币通过设置<strong>出块奖励</strong>来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。<br>:::info<br>比特币系统设计规定，起初每个区块可以获得50个比特币，但之后每隔21万个区块，奖励减半。<br>:::<br><strong>但是这样就可以了吗？？？</strong>区块中保存交易记录，那么，会不会存在节点只想发布区块而不想打包交易？中本聪在设计该系统时，引入了交易费。在一个区块中，其输入&gt;&#x3D;输出，差值便是给区块所属节点的手续费。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-01T06:27:46.000Z" title="2023/8/1 14:27:46">2023-08-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-05-27T07:19:23.637Z" title="2024/5/27 15:19:23">2024-05-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">区块链系统实现</a></span><span class="level-item">21 minutes read (About 3212 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/01/01BTC-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">01BTC-密码学原理-区块链系统实现</a></p><div class="content"><meta name="referrer" content="no-referrer">

<p><a name="P9bMX"></a></p>
<h2 id="区块链与密码学"><a href="#区块链与密码学" class="headerlink" title="区块链与密码学"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8C%BA%E5%9D%97%E9%93%BE&spm=1001.2101.3001.7020">区块链</a>与密码学</h2><p>以比特币为例子，比特币作为区块链的经典应用，其本质是一种加密货币， 但实际上，比特币是不加密的，区块链上的所有信息都是公开的，包括账户的地址、交易记录、金额等等。比特币主要用到了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AF%86%E7%A0%81%E5%AD%A6&spm=1001.2101.3001.7020">密码学</a>中的2个功能，一个是哈希，另一个是签名；这也是区块链中涉及到密码学部分的主要功能。<br><a name="jgcFx"></a></p>
<h3 id="一、哈希-散列-函数"><a href="#一、哈希-散列-函数" class="headerlink" title="一、哈希(散列)函数"></a>一、哈希(散列)函数</h3><p>哈希函数是可以用来将任意大小的数据映射到固定大小值的任何函数。哈希函数返回的值称为哈希值、哈希码、摘要或简单的哈希。这些值用于索引一个固定大小的表，称为哈希表。使用哈希函数为哈希表建立索引称为哈希或分散存储寻址。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1703840496071-f04f079e-ae01-4815-b9f6-7cc27ae64831.png#averageHue=%23bf7f6e&clientId=u7ec67b05-618e-4&from=paste&id=uaa0863dc&originHeight=184&originWidth=240&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3d7063b-fbe5-4ad6-bce0-efa2b310f07&title="><br><a name="hiCMB"></a></p>
<h3 id="二、密码散列函数-Cryptographic-hash-function"><a href="#二、密码散列函数-Cryptographic-hash-function" class="headerlink" title="二、密码散列函数(Cryptographic hash function)"></a>二、密码散列函数(Cryptographic hash function)</h3><p>密码散列函数（英语：Cryptographic hash function），又译为加密散列函数、密码散列函数、加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的资料是什么。这样的单向函数被称为“现代密码学的驮马”<br><img src="https://cdn.nlark.com/yuque/0/2023/png/40732470/1703840504957-830d0c79-c0b5-43a9-be69-9d648af89d93.png#averageHue=%23e4e480&clientId=u7ec67b05-618e-4&from=paste&id=uf5a5aa1f&originHeight=272&originWidth=375&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u15a8c59b-2ece-42c4-9976-833d240d34d&title="><br>那么区块链中的哈希函数主要是密码散列函数，它有几个重要的性质：</p>
<ol>
<li>Collision resistance(抗碰撞性)</li>
<li>Hiding(不可逆)</li>
<li>puzzle friendly （仅比特币需满足）<br><a name="Fto5r"></a></li>
</ol>
<h4 id="Collision-resistance"><a href="#Collision-resistance" class="headerlink" title="Collision resistance"></a>Collision resistance</h4><p>抗碰撞性的意思就是对于一个哈希函数H,2个输入a,b，你很难找到两个不同的输入使得哈希后的输出值相同</p>
<p><br><em>H</em>(<em>a</em>)&#x3D;<em>H</em>(<em>b</em>),_wherea_\&#x3D;<em>b</em></p>
<p><br>两个不同的输入输出的值是相同的，一般来说，哈希碰撞是无可避免的，因为你的输入空间其实远远大于输出空间，假如我们的哈希函数输出值控制在256个bit位，那么它的输出空间有2256种情况，理论上，如果进行2256+1次计算，则能达到哈希碰撞，也就是能找到两个不同的输入使得哈希值相同。但是这样的计算太庞大，很难实现。<br>利用抗碰撞性，我们可以拿来检测数据是否被篡改，假如我们有一个数据m,它的哈希值H(m)，也把它叫做’message digest’，如果有人改了m，那么哈希值一定会发生变化。因为抗碰撞性，意为着你无法篡改内容而又不被发现。<br>Collision resistance在数学上无法被证明，只能靠实际经验获得，但有一些哈希函数如MD5已经被找到一种方法能够人为的构造哈希碰撞。<br><a name="DCbnt"></a></p>
<h4 id="Hiding"><a href="#Hiding" class="headerlink" title="Hiding"></a>Hiding</h4><p>hiding的意思是哈希过程是不可逆的，你知道哈希值，并不能反推出哈希函数的输入值具体是多少。但这个条件成立的前提是<br>输入空间足够大：如果只有几个输入，那就很没意思了<br>输入空间均匀分布：即使有很大的输入空间，但如果某几个输入值被选中的概率很大，那就意味着有很大的概率反推输入值<br><a name="tpc74"></a></p>
<h4 id="digital-commitment"><a href="#digital-commitment" class="headerlink" title="digital commitment"></a>digital commitment</h4><p>用前面两个性质可以实现digital commitment，这也叫digital equivalent of a sealed envelop。<br>举一个现实生活的例子。如一个人说自己能预测股票涨停，那么如何证明呢？如果让他提前公布自己的“预测”——明天股票的涨停，然后明天再去看股市，那么他公布的信息本身就会影响到股票涨停。如果在股票涨停之后再公布，那么大家会怀疑他有没有篡改自己的“预测”。而这里sealed envelop也就是解决这个问题的办法，让这个人先把预测结果写在纸上，放进信封里封好，然后交给第三方的公证机构保管。第二天股市收盘后，再让公证机构检查信封完好、打开信封、查看纸上的预测结果和实际涨停是不是一致即可。<br>而使用digital commitment在这个问题上的做法是把预测结果计算出一个哈希值，然后把哈希值公布出去，因为有hiding的性质，所以大家没法通过哈希值知道预测结果。第二天收盘后公布预测结果，因为有collision resistance的性质，所以预测结果是没有篡改过的，否则和公布的哈希值就对不上了。在这个问题里，例如预测的是“涨的股票的名字”，那么因为股票一共就那么多支，输入空间并不是足够大，这样就不满足hiding的性质（大家可以遍历所有的股票取哈希去知道预测的是哪支股票涨）。这时候的解决办法可以是在输入后面加上一个随机数nonce，增大输入空间和输入的概率随机性,使得分布足够的均匀：</p>
<p><em>H</em>(<em>x_∣∣_nonce</em>)<em>orH</em>(<em>x_∣∣_nonce</em>)</p>
<p>在挖矿的时候，经常也是去算这个nonce。<br><a name="miiE6"></a></p>
<h4 id="puzzle-friendly"><a href="#puzzle-friendly" class="headerlink" title="puzzle friendly"></a>puzzle friendly</h4><p>除了前面两个性质，比特币中的哈希函数还要满足puzzle friendly这个性质。该性质要求哈希值计算事先不可预测，仅仅根据输入很难预测出输出。例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。比如说，我们想得到一个哈希值<br>这个哈希值前面K个位置都是0,总共是256位。</p>
<p>00000…<em>XXXXXX</em></p>
<p>那么什么样的输入可以得到这样的输出？答案很难得到。<br>该性质保证了比特币系统中，只能通过“挖矿”获得比特币。也就是说，该性质保证了工作量证明(POW)机制可以运行下去【“挖矿难，但验证易”】。在比特币系统中采用SHA-256哈希函数。比特币挖矿的过程就是去找一个随机数nonce，这个nonce和区块的块头里的其它信息合并在一起作为输入，取哈希值，所得哈希值要小于等于某个指定的阈值：</p>
<p><em>H</em>(<em>block</em>,<em>header</em>)≤<em>target</em></p>
<p><br>注意，nonce不是区块块头以外的东西，它是其中的一个域，但是可以人为设置。挖矿的过程就是不停的去试nonce，使得整个块头部分取哈希小于等于target。有了puzzle friendly这个性质，使得比特币挖矿的过程没有捷径可言，只能不停的去试大量的nonce才能找到符合要求的解，所以才能用来用作工作量证明（proof of work,POW）。这个puzzle friendly和最前面的collision resistance有一定的联系，但不是完全一样。那个是无法去人为制造哈希碰撞，而这个是无法去人为构造符合特定特征的哈希值。<br>虽然找到一个符合要求的nonce很难，但一旦找到之后，将它发布出去以后，其他人要验证这个nonce是不是符合要求是很容易的，只要算一次哈希值再和target比较一下就可以了。<br><a name="hMjMH"></a></p>
<h3 id="三、签名"><a href="#三、签名" class="headerlink" title="三、签名"></a>三、签名</h3><p><a name="N4m8S"></a></p>
<h4 id="比特币中账户管理"><a href="#比特币中账户管理" class="headerlink" title="比特币中账户管理"></a>比特币中账户管理</h4><p>在第三方中心化系统中，账户开通依赖于第三方。但去中心化的比特币系统中，很明显不能进行“申请账户”。在比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对。<br>公钥和私钥的应用保证了“签名”的应用。当在比特币网络中进行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。也就是说，只有拥有私钥，才能将该账户中的比特币转走。在比特币系统中，很难通过生成大量公私钥对来获取他人私钥<br><a name="lBan9"></a></p>
<h4 id="两种加密体系"><a href="#两种加密体系" class="headerlink" title="两种加密体系"></a>两种加密体系</h4><p><a name="qFTE4"></a></p>
<h5 id="对称加密体系"><a href="#对称加密体系" class="headerlink" title="对称加密体系"></a>对称加密体系</h5><p>最早的加密体系是对称的加密体系（symmetric encryption algorithm）。如两方进行通信，商量好一个密钥（encryption key），发送方使用密钥加密，接收方使用密钥解密。因为加密解密用的是用一个密钥，所以这是对称的加密体系。这种方式假设了存在某种安全的渠道，能够把密钥分发给通讯双方，这是对称加密体系的一个弱点。<br><a name="npNui"></a></p>
<h5 id="非对称加密体系"><a href="#非对称加密体系" class="headerlink" title="非对称加密体系"></a>非对称加密体系</h5><p>非对称的加密体系（asymmetric encryption algorithm）不再像对称加密那样使用一个密钥，而是使用一对密钥，即公钥和私钥，加密用的是公钥，解密用的是私钥。例如A要发信息给B，那么使用B的公钥对信息进行加密，B收到信息后用B自己的私钥进行解密就能得到原来的信息。也就是说加密和解密用的都是接收方的公钥和私钥。这样做的好处是公钥是不用保密的，可以告诉所有人，有的人主页上就有PGP public key。只有私钥是要保密的，但是私钥只需要保存在本地就可以了，不用传递给任何人，这样就避免了传输密钥过程不安全的问题。要回复对方再用对方的公钥加密，始终都不需要知道其他人的私钥，这就解决了对称加密体系中密钥分发不安全（不方便）的问题。<br><a name="rzTRu"></a></p>
<h4 id="比特币中的签名"><a href="#比特币中的签名" class="headerlink" title="比特币中的签名"></a>比特币中的签名</h4><p>加密货币是不加密的，前面学的非对称加密的公钥和私钥在比特币系统中就是用来做签名的。<br>比如A要向B转账，即A在区块链上发起一个交易，所有交易是公开的，但大家怎么判断这个交易确实是A发起的，而不是别人冒名顶替的，这就需要A用户用自己的私钥对交易进行签名。其他用户拿到签名和交易信息后，可以用A的公钥去验证签名的正确性。签名用的是私钥，验证签名用的是公钥。都是同一个用户的公钥和私钥。生成公钥私钥的过程是随机的，但要求选取一个好的随机源，否则前面的分析就不成立了（就有不足够小的可能生成重复的公钥私钥对）。比特币中使用的签名算法不仅在生成公钥私钥对时有好的随机源，在之后每次签名的时候也要有好的随机源。如果签名时使用的随机源不好，就有可能泄露私钥。<br>比特币系统中的签名，一般是先对message取一个哈希，然后再对哈希值签名。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avator.jpg" alt="Enoch"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Enoch</p><p class="is-size-6 is-block">有形非易测，无源讵可量。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>chengdu-SiChuan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Enochbest" target="_blank" rel="noopener">Follow</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/Enochbest" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Git-hub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="2658929241@qq.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">E-mail</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/dart/"><span class="tag">dart</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/three/"><span class="tag">three</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uniapp/"><span class="tag">uniapp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue3/"><span class="tag">vue3</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"><span class="tag">区块链</span><span class="tag">10</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Flutter/"><span class="level-start"><span class="level-item">Flutter</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Three-js%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">Three.js学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/dart%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">dart学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/react/"><span class="level-start"><span class="level-item">react</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/uniapp/"><span class="level-start"><span class="level-item">uniapp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/vue3/"><span class="level-start"><span class="level-item">vue3</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">前端安全</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">区块链基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">区块链系统实现</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">浏览器原理</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-14T06:27:20.000Z">2024-03-14</time></p><p class="title"><a href="/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/">vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法</a></p><p class="categories"><a href="/categories/vue3/">vue3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:52:35.000Z">2023-12-26</time></p><p class="title"><a href="/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/">初识着色器(包括着色器传参)</a></p><p class="categories"><a href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-25T05:50:41.000Z">2023-12-25</time></p><p class="title"><a href="/2023/12/25/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%8E%9F%E7%90%86/">渲染管线原理</a></p><p class="categories"><a href="/categories/Three-js%E5%AD%A6%E4%B9%A0/">Three.js学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-09T12:12:41.000Z">2023-09-09</time></p><p class="title"><a href="/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/">IM发送表情（基于quill富文本编辑器）</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-07T12:42:20.000Z">2023-09-07</time></p><p class="title"><a href="/2023/09/07/%E5%9C%A8Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/">在Vue3中使用quill富文本编辑器</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">March 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/avator.jpg" alt="Enoch&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Enoch</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>