{"posts":[{"title":"Dart学习---List的Remove方法小坑","text":"12345var L1=&lt;String&gt;['香蕉','苹果','西瓜','西瓜'];L1.addAll(['桃子','莆田']);print(L1);//[香蕉, 苹果, 西瓜, 桃子, 桃子, 莆田]L1.remove('桃子');print(L1);//[香蕉, 苹果, 西瓜, 桃子, 莆田] List 的remove()方法在移除重复数据的时候只会移除第一项","link":"/2022/11/28/Dart%E5%AD%A6%E4%B9%A0-List%E7%9A%84Remove%E6%96%B9%E6%B3%95%E5%B0%8F%E5%9D%91/"},{"title":"搞懂事件循环","text":"事件循环 文章参考地址:https://zh.javascript.info/event-loop#shi-jian-xun-huan 事件循环的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。 当有任务时： 从最先进入的任务开始执行。 休眠直到出现任务，然后转到第 1 步。 当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。 任务示例： 当外部脚本 &lt;script src=&quot;...&quot;&gt; 加载完成时，任务就是执行它。 当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。 当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。 ……诸如此类。当脚本/处理程序/事件激活时,js 引擎开始处理他们—处理完成后开始等待,(进入休眠，几乎不消耗 CPU 资源)一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序，依此类推。 两个注意点: 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。 例 1：拆分 CPU 过载任务通过一个例子来深入了解一下,假设我们有一个 CPU 过载任务。为了演示这种方法，简单起见，让我们写一个从 1 数到 1000000000 的函数如果你运行下面这段代码，你会看到引擎会“挂起”一段时间。对于服务端 JS 来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束之前不会处理其他事件。 123456789101112131415let i = 0;let start = Date.now();function count() { // 做一个繁重的任务 for (let j = 0; j &lt; 1e9; j++) { i++; } alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');}count(); 浏览器甚至可能会显示一个“脚本执行时间过长”的警告。让我们使用嵌套的 setTimeout 调用来拆分这个任务： 1234567891011121314151617181920let i = 0;let start = Date.now();function count() { // 做繁重的任务的一部分 (*) do { i++; } while (i % 1e6 != 0); if (i == 1e9) { alert(&quot;Done in &quot; + (Date.now() - start) + 'ms'); } else { setTimeout(count); // 安排（schedule）新的调用 (**) }}count(); 现在，浏览器界面在“计数”过程中可以正常使用。 单次执行 count 会完成工作 (*) 的一部分，然后根据需要重新安排（schedule）自身的执行 (**)： 首先执行计数：i=1...1000000。然后执行计数：i=1000001..2000000。……以此类推。现在，如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 onclick 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 count 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。 值得注意的是这两种变体 —— 是否使用了 setTimeout 对任务进行拆分 —— 在执行速度上是相当的。在执行计数的总耗时上没有多少差异。 为了使两者耗时更接近，让我们来做一个改进。 我们将要把调度（scheduling）移动到 count() 的开头： 1234567891011121314151617181920212223let i = 0;let start = Date.now();function count() { // 将调度（scheduling）移动到开头 if (i &lt; 1e9 - 1e6) { setTimeout(count); // 安排（schedule）新的调用 } do { i++; } while (i % 1e6 != 0); if (i == 1e9) { alert(&quot;Done in &quot; + (Date.now() - start) + 'ms'); }}count(); 现在，当我们开始调用 count() 时，会看到我们需要对 count() 进行更多调用，我们就会在工作前立即安排（schedule）它。 如果你运行它，你很容易注意到它花费的时间明显减少了。 为什么？ 这很简单：你应该还记得，多个嵌套的 setTimeout 调用在浏览器中的最小延迟为 4ms。即使我们设置了 0，但还是 4ms（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。 最后，我们将一个繁重的任务拆分成了几部分，现在它不会阻塞用户界面了。而且其总耗时并不会长很多。 例2：进度指示我们也可能想在任务执行期间展示一些东西，例如进度条。 如果我们使用 setTimeout 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。 这看起来更好看： 12345678910111213141516171819202122&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;&lt;script&gt; let i = 0; function count() { // 做繁重的任务的一部分 (*) do { i++; progress.innerHTML = i; } while (i % 1e3 != 0); if (i &lt; 1e7) { setTimeout(count); } } count();&lt;/script&gt; 现在 div 显示了 i 的值的增长，这就是进度条的一种。 宏任务和微任务除了 宏任务（macrotask） 外，还有在 微任务（Microtask 微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。 还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行。 每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。 看这个例子: 1234567setTimeout(() =&gt; alert(&quot;timeout&quot;));Promise.resolve() .then(() =&gt; alert(&quot;promise&quot;));alert(&quot;code&quot;); 这里的执行顺序是: 1.code 首先显示，因为它是常规的同步调用。 2.promise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行。 3.timeout 最后显示，因为它是一个宏任务。 更详细的事件循环图示如下（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）： 微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成。 这很重要，因为它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。 如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 queueMicrotask 来对其进行安排（schedule）。 这是一个与前面那个例子类似的，带有“计数进度条”的示例，但是它使用了 queueMicrotask 而不是 setTimeout。你可以看到它在最后才渲染。就像写的是同步代码一样： 12345678910111213141516171819202122&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;&lt;script&gt; let i = 0; function count() { // 做繁重的任务的一部分 (*) do { i++; progress.innerHTML = i; } while (i % 1e3 != 0); if (i &lt; 1e6) { queueMicrotask(count); } } count();&lt;/script&gt; 总结更详细的事件循环算法（尽管与 规范 相比仍然是简化过的）： 1.从 宏任务 队列（例如 “script”）中出队（dequeue）并执行最早的任务。 2.执行所有 微任务： *当微任务队列非空时： *出队（dequeue）并执行最早的微任务。 5.如果有变更，则将变更渲染出来。 6.如果宏任务队列为空，则休眠直到出现宏任务。 7.转到步骤 1。 安排（schedule）一个新的 宏任务： 使用零延迟的 setTimeout(f)。它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。 此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。 安排一个新的 微任务： 使用 queueMicrotask(f)。promise 处理程序也会通过微任务队列。在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。 所以，我们可以使用 queueMicrotask 来在保持环境状态一致的情况下，异步地执行一个函数。","link":"/2022/11/09/Event-Loop/"},{"title":"IM发送表情（基于quill富文本编辑器）","text":"首先 1npm install vue-quill-editor --save main.js 12345import VueQuillEditor from 'vue-quill-editor'//调用编辑器import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'Vue.use(VueQuillEditor) 最近公司在重构im项目，聊天中新增发送表情，有两种实现方法，由于公司现在的项目发送的时候用的不是富文本是输入框，第一种方法基于这种情况也可以实现原理都是一样的 就是把本地资源在以指定的key 字符串，在聊天信息中解析成富文本（含img标签） html 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;QuillEditor @getText=&quot;getText&quot; @getHtml=&quot;getHtml&quot; ref=&quot;MyQuillEditor&quot;&gt;&lt;/QuillEditor&gt; &lt;button @click=&quot;sendText&quot;&gt;发送消息&lt;/button&gt; &lt;div&gt; &lt;img v-for=&quot;(emojiItem, emojiKey, index) in emoji.map&quot; class=&quot;emoji-item&quot; :key=&quot;index&quot; :src=&quot;emoji.url + emojiItem&quot; @click=&quot;chooseEmoji(emojiKey)&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;div v-for=&quot;(msg,index) in messageList&quot; :key=&quot;index&quot;&gt; &lt;div v-html=&quot;emoji.decoder.decode(msg)&quot; style=&quot;text-align: center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js 12345678910111213141516171819202122// 定义子组件refconst MyQuillEditor = ref()const emojiUrl = 'https://imgcache.qq.com/open/qcloud/tim/assets/emoji/';const emojiMap = { '[么么哒]': 'emoji_3@2x.png', '[乒乓]': 'emoji_4@2x.png', '[便便]': 'emoji_5@2x.png', '[信封]': 'emoji_6@2x.png', '[偷笑]': 'emoji_7@2x.png', '[傲慢]': 'emoji_8@2x.png',};const emoji= reactive({ url: emojiUrl, map: emojiMap, visible: false, decoder: new EmojiDecoder(emojiUrl, emojiMap),})//将图片的key插入富文本const chooseEmoji = (emojiKey)=&gt;{ console.log(emojiKey) MyQuillEditor.value.insertText(emojiKey)} 将发送的字符串记录中替换成富文本信息 12345678910111213141516171819202122232425class EmojiDecoder { emojiMap = null; url = &quot;&quot;; patterns = []; metaChars = /[[\\]{}()*+?.\\\\|^$\\-,&amp;#\\s]/g; constructor(url,emojiMap) { this.url = url || ''; this.emojiMap = emojiMap || {}; for (let i in this.emojiMap) { // eslint-disable-next-line no-prototype-builtins if (this.emojiMap.hasOwnProperty(i)){ this.patterns.push('('+i.replace(this.metaChars, &quot;\\\\$&amp;&quot;)+')'); } } } decode (text) { return text.replace(new RegExp(this.patterns.join('|'),'g'), (match) =&gt; { return typeof this.emojiMap[match] != 'undefined' ? '&lt;img height=&quot;16px&quot; width=&quot;16px&quot; src=&quot;'+this.url+this.emojiMap[match]+'&quot; /&gt;' : match; }); }}export default EmojiDecoder 这种有个坏处富文本里面看不到图片，发送起来像这种”[便便]”, 第二种，我们重写一下插入内容的方法，在mainjs中 12345678910111213141516171819202122232425262728293031import VueQuillEditor , { Quill }from 'vue-quill-editor'// require stylesimport 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import imageResize from 'quill-image-resize-module' // 调整大小组件。import { ImageDrop } from 'quill-image-drop-module'; // 拖动加载图片组件。const Embed = Quill.import(&quot;blots/embed&quot;);console.log(Embed,'-------------666-----------------')///表情 重点部分class MsgEmoji extends Embed { static create(value) { console.log(&quot;create&quot;,value) ///通过id判断是否需要格式化，防止误伤 if(Object.prototype.toString.call(value)===&quot;[object HTMLImageElement]&quot;){ return value } let node = super.create(); node.setAttribute(&quot;src&quot;, value.src); node.style.width = &quot;16px&quot;; node.style.height = &quot;16px&quot;; node.style.backgroundColor = &quot;red&quot;; return node; } ///撤消操作 static value=node=&gt;node}MsgEmoji.blotName = &quot;MsgEmoji&quot;;MsgEmoji.tagName = &quot;img&quot;;//别忘了注册我们重写的方法Quill.register(MsgEmoji); 在页面上使用（选择表情的场景） 1234//获取富文本实例 let quill = this.$refs.myQuillEditor.quill //获取最近一次的光标位置 quill.insertEmbed(quill.selection.savedRange.index,&quot;MsgEmoji&quot;,{src: &quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;, code: &quot;0&quot; },Quill.sources.USER); quill很灵活，可自定义的非常多，还是比较推荐，像上面这种，需要自定义图片样式插入图片选择图片也是非常实用的！","link":"/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/"},{"title":"UviewPicker的数据渲染问题","text":"UviewPicker设计模式自我觉得真的很不理解,他的联级选择数据居然不是树形结构,需要自己去获取下一级的选项去设置,默认项是一个一维数组 拿到后端返回的树形接口前端操作起来算是比较麻烦需要几个工具函数进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//获取源数据的深度 function getDeep(obj) { let res = 1 // 递归函数 function fn(obj) { let arr = [] let arrLength = arr.length // 先遍历是不是里面还有对象类型，是就计数 for (let item in obj) { if (typeof (obj[item]) === 'object') { // 然后把这个再存到数组中下次遍历 // arr.push([...obj[item]]) // 要分别存入，否则下次死循环 for (let key in obj[item]) { arr.push(obj[item][key]) } } } // 循环结束后判断arr有没有增加 if (arr.length &gt; arrLength) { res++ arrLength = arr.length // 继续递归 return fn(arr) } else return res } return fn(obj) } //初始化默认展示的数据 function initModuleNumberFnc(data) { //获取第一项的深度用于遍历次数,处理出默认数据 const deepnum = getDeep(data[0]) console.log(deepnum) let firstArr = [] //初始化第一层数据 firstArr = data.map((item) =&gt; { return { id: item.id, name: item.nodeName } }) console.log(firstArr) let Arr = [] let initDataArr = data[0].children for (let index = 0; index &lt; deepnum - 2; index++) { if (index === 0) { Arr.push(data[0].children) console.log(Arr[index - 1]) } else { if (Arr[index - 1][0].children.length &gt; 0) { Arr.push(Arr[index - 1][0].children) console.log(Arr[index - 1][0].children) } } } console.log(Arr) return [firstArr, ...Arr] } initModuleNumberFnc(data) //已得到初始化数据作为默认渲染 //调用getNextData方法获取下一项的值 console.log(initModuleNumberFnc(data)) // 扁平化元数据 function cutTree(data, childName = 'children') { let result = []; while (data.length != 0) { let shift = data.shift(); let children = shift[childName] delete shift[childName] result.push(shift) if (children) { children.forEach(item =&gt; { data.push(item) }) } } return result } const result = cutTree(data) console.log(result) //根据传入的id获取下一项 function getNextData(id){ console.log(cutTree(data)) let res = result.filter((item)=&gt;{ return item.parentCode == id }) console.log(res) } getNextData('1496398135651430402')","link":"/2022/11/08/My-New-Post-1/"},{"title":"手写call、apply、bind","text":"Call12345const obj = {name: 'Enoch',say(prefix, age) {console.log(`${prefix},my name is ${this.name},i am ${age} year old`)} 上面我们定义了一个对象，对象中有个say方法，调用该对象上的方法后，我们得到了 1obj.say('hello',12) // 'hello,my name is Enoch,i am 12 year old' 这个时候问题来了，如果还有另外一个对象A，也想实现上面对象中的方法say，有两种 在A对象中也照搬不误的实现一个一模一样的say方法 能不能借用一下上面对象中的方法say 但是如果你选择了第二种，又会面临另外一个问题，因为方法中涉及到this指向的问题，而在上面，我就特意提出了理解this指向的前置条件。能不能做到把obj上面的say方法，借A用的同时，this指向也自然而然的指向A呢？其实上面这段话已经很好地道出了call的真正作用，改变函数的作用域。这里先说一下，不管是call,还是apply都是冒用借充函数。 123456789101112131415const obj = { name: 'Enoch', say(prefix, age) { console.log(`${prefix},my name is ${this.name},i am ${age} year old`) }}const A = { name:'小丁'}obj.say.call(A,'hello',3) // 'hello,my name is 小丁,i am 3 year old'} 通过以上代码片段，我们可以总结以下几点 A中确实没有再次定义一个重复的方法，并且say方法中的this指向确实指向了A call方法，可以接受任意多个参数，但是要求，第一个参数必须是待被指向的对象（A），剩下的参数，都传入借过来使用的函数（say）中 现在知道了call是什么东西，那么我们就开始来模仿实现以上两点，但模仿前，我们需要知道 不管是引用数据类型还是基本数据类型，它们的方法，都是定义在原型对象上面的 方法中的this指向 谁调用这个方法this就指向谁 手写Call先写个雏形，该自定义call方法接受N个参数，其中第一个参数是即将借用这个函数的对象，剩下的参数用rest参数表示，这就模仿出了上面的第二点的前半部分 123Function.prototype.myCall = function(target,...args){ } 我们都知道一个普通函数中的this是指向调用这个函数的对象的，那么我们想让上方say方法中的this指向调用该方法的对象，该怎么做呢？很简单，我在你这个对象上添加一个方法，当我们调用这个对象上的这个方法时，方法中的this自然就指向该对象 1234Function.prototype.myCall = function(target,...args){ const symbolKey = Symbol() target[symbolKey] = this} 这里我们做了两件事，首先就是给传入的第一个对象，添加了一个key，这里用symbolKey而不随便定义另外一个key名是因为，我随意添加的名字，可能target对象上面正好有呢？这不是扯犊子呢吗…而Symbol就是ES6中实现的，用来解决这种问题。其次，我们为这个属性，赋了一个值this，而这个this就正是借过来使用的函数，这样我们执行该函数时，其中的this，自然而然的就指向了target。到这里，已经模仿出了上面的第一点但是javascript要求，当我们target传入的是一个非真值的对象时，target指向window，这很好办 12345Function.prototype.myCall = function(target,...args){ target = target || window const symbolKey = Symbol() target[symbolKey] = this} 到这里，我们已经完全实现了上面提出的两点需要模仿实现的点，但是我们的目的是把别的方法，拿过来用用，用完了之后，肯定还是要删掉的。如果函数具备返回值的话，我们还是需要将返回值进行返回的。 12345678910Function.prototype.myCall = function(target,...args){ target = target || window const symbolKey = Symbol() target[symbolKey] = this const res = target[symbolKey](...args) // args本身是rest参数，搭配的变量是一个数组，数组解构后就可以一个个传入函数中 delete target[symbolKey] // 执行完借用的函数后，删除掉， return res}obj.say.myCall(A,'hello',3) // 'hello,my name is 小丁,i am 3 year old' 总结一下:就是将调用函数的this放在了传入的A对象身上,这样this就可以访问到A对象的值 Apply区别就是这里第二个参数直接就是个数组 123456789Function.prototype.myApply = function(target,args){ // 区别就是这里第二个参数直接就是个数组 target = target || window const symbolKey = Symbol() target[symbolKey] = this const res = target[symbolKey](...args) // args本身是个数组，所以我们需要解构后一个个传入函数中 delete target[symbolKey] // 执行完借用的函数后，删除掉， return res}obj.say.myCall(A,'hello',3) // 'hello,my name is 小丁,i am 3 year old' Bind先写了一个基础版 12345678910111213141516const obj = { name: 'Enoch', say() { console.log(`my name is ${this.name}`) }}obj.say() // 'my name is 麻不烧'const B = { name: '小丁丁'}const sayB = obj.say.bind(B)sayB() // 'my name is 小丁丁' bind本身是个方法，返回值也是个方法，一般调用bind方法的也是个方法…别懵 接受的第一个参数是一个对象，哪个方法调用bind方法，那么这个方法中的this，就是指向这个对象 手写Bind先写个基础架子 1234Function.prototype.myBind = function (target) { target = target || {} // 处理边界条件 return function () {} // 返回一个函数} 想要完成上面提到的第二个要素，还是和实现apply与call那样，给该target添加一个方法，这样方法中的this，就是指向该target 12345678910Function.prototype.myBind = function (target) { target = target || {} // 处理边界条件 const symbolKey = Symbol() target[symbolKey] = this return function () { // 返回一个函数 target[symbolKey]() delete target[symbolKey] } } 到这里，已经完成了bind的大部分逻辑，但是在执行bind的时候，是可以传入参数的，稍微改下上面的例子 1234567891011121314151617const obj = { name: 'Enoch', say(prefix, age) { console.log(`${prefix},my name is ${this.name},i am ${age} year old`) }}obj.say('hello',12) // 'hello,my name is 麻不烧,i am 12 year old'const B = { name: '小丁丁'}const sayB = obj.say.bind(B,'hello')sayB(3) // 'hello,my name is 小丁丁,i am 3 year old'' 这里，我们发现一个有意思的地方，不管是bind中传递的参数，还是调用bind的返回函数时传入的参数，都老老实实的传递到say方法中，其实很容易实现 12345678910Function.prototype.myBind = function (target,...outArgs) { target = target || {} // 处理边界条件 const symbolKey = Symbol() target[symbolKey] = this return function (...innerArgs) { // 返回一个函数 const res = target[symbolKey](...outArgs, ...innerArgs) // outArgs和innerArgs都是一个数组，解构后传入函数 // delete target[symbolKey] 这里千万不能销毁绑定的函数，否则第二次调用的时候，就会出现问题。 return res } } 由于myBind返回的函数会被多次调用，所以不应该在调用一次之后，就将里面的target[symbolKey]给销毁掉。因为这样会导致第二次调用的时候，出现问题。","link":"/2022/09/08/My-New-Post/"},{"title":"Vue在data中获取computed值为undefined","text":"直接看问题 12345678910data() { return { age:this.newAge //undefined }; }, computed: { newAge(){ return '18' } }, 这里的知识点和生命周期有关 首先created是最先执行的，初始化data里的值。 computed是界于created和mounted之间发生的 在data创建完成时 computed还没被创建,所以这个时候一定是undefined 解决方法 123456789101112data() { return { age:function () { return this.newAge } }; }, computed: { newAge(){ return '18' } },","link":"/2022/09/10/Vue-Article/"},{"title":"Vue通过dom导出excel表格","text":"一般业务中我们不会去通过这种方法去导出表格,这种不安全,一般会后端返回下载链接进行参数加密,并只能下载一次,每次下载前更新链接,这里只是介绍一种思路 安装xlsx库1npm install xlsx 安装file-saver库1npm install file-saver 编写保存函数，文件位置：src/utils/htmlToExcel.js123456789101112131415161718192021222324import FileSaver from &quot;file-saver&quot;;import * as XLSX from 'xlsx/xlsx.mjs';const htmlToExcel = { getExcel(dom,title='默认标题',){ var excelTitle = title; var wb = XLSX.utils.table_to_book(document.querySelector(dom)); /* 获取二进制字符串作为输出 */ var wbout = XLSX.write(wb, {bookType: &quot;xlsx&quot;,bookSST: true,type: &quot;array&quot;}); try { FileSaver.saveAs( new Blob([wbout], { type: &quot;application/octet-stream&quot; }), excelTitle + &quot;.xlsx&quot; ); } catch (e) { if (typeof console !== &quot;undefined&quot;) console.log(e, wbout); } return wbout; }};export default htmlToExcel; 使用函数，文件位置src/views/TablePage.vue注:表格导出实现解释，给展示表格添加选择功能，通过handleSelectionChange函数将选中数据与selectData绑定，在选中需要导出数据后点击导出按钮，展示el-dialog并将selectData数据展示在el-dialog中的表格，此表格为最后导出的表格，所以id赋值selectTable，最后确认打印调用exportExcel函数，通过htmlToExcel.getExcel('#selectTable','导出的自定义标题')导出Excel文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;template&gt; &lt;div&gt; &lt;!--导出按钮--&gt; &lt;el-button type=&quot;primary&quot; style=&quot;margin:20px;&quot; @click=&quot;exportExcelSelect&quot;&gt;导出Excel&lt;/el-button&gt; &lt;!--原始表格--&gt; &lt;el-table :data=&quot;tableData&quot; @selection-change=&quot;handleSelectionChange&quot; &gt; &lt;el-table-column type=&quot;selection&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;详细地址&quot;&gt; &lt;el-table-column prop=&quot;province&quot; label=&quot;省份&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;city&quot; label=&quot;市区&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;zip&quot; label=&quot;邮编&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; &gt; &lt;template&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;查看&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;编辑&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--预览弹窗表格--&gt; &lt;el-dialog title=&quot;表格保存预览&quot; width=&quot;70%&quot; :visible.sync=&quot;selectWindow&quot;&gt; &lt;el-table :data=&quot;selectData&quot; id=&quot;selectTable&quot; height=&quot;380px&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;详细地址&quot;&gt; &lt;el-table-column prop=&quot;province&quot; label=&quot;省份&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;city&quot; label=&quot;市区&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;zip&quot; label=&quot;邮编&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;exportExcel&quot;&gt;确定保存&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import htmlToExcel from '@/utils/htmlToExcel' export default { name: &quot;ExcelPage&quot;, data(){ return{ //表格数据 tableData: [ { date: '2016-05-03', name: '王小天', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-02', name: '王小明', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-04', name: '王小智', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-01', name: '王小红', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-08', name: '王小华', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-06', name: '王小丽', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-07', name: '王小花', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 } ], //表格中选中的数据 selectData:[], selectWindow:false, } }, methods:{ //导出 exportExcel() { htmlToExcel.getExcel('#selectTable','导出的自定义标题') }, //显示预览弹窗 exportExcelSelect(){ if (this.selectData.length &lt; 1){ this.$message.error('请选择要导出的内容！'); return false; } this.selectWindow = true; }, //选中数据 handleSelectionChange(val) { this.selectData = val; } } }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","link":"/2022/07/08/Vue%E9%80%9A%E8%BF%87dom%E5%AF%BC%E5%87%BAexcel%E8%A1%A8%E6%A0%BC/"},{"title":"docker安装以及简单前端项目部署","text":"centos 7.9 docker-compose根据自己情况安装 yum选择自己合适的 安装流程卸载旧版本12345678910111213 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#卸载 Docker Engine、CLI、Containerd 和 Docker Compose 软件包：yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin#主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷：sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 开始安装设置存储库。安装yum-utils包（提供yum-config-manager 实用程序）并设置存储库。 1234567891011121314 sudo yum install -y yum-utils#配置源#可以使用阿里源，最好选这个yum-config-manager --add-repo=http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#官方sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum makecache #重新构建缓存yum repolist {all|enabled|disabled} #列出所有/已启用/已禁用的yum源yum --disablerepo=repo #临时禁用某个repo源yum --enablerepo=repo #解除禁用某个repo源 安装 Docker 引擎。安装最新版本的 Docker Engine、containerd 和 Docker Compose 1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin #解除禁用某个repo源 要安装特定版本的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装 1234567891011yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:20.10.19-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.18-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.17-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.16-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.15-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.14-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.13-3.el7 docker-ce-stable 安装。 12345#默认安装sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin#可以选择版本sudo yum install docker-ce-20.10.14 docker-ce-cli-20.10.14 containerd.io docker-compose-plugin 结束 12345sudo systemctl start docker #启动sudo systemctl enable docker #开机启动docker version #查看版本docker run hello-world #示例进项 前端项目部署准备好阿里云服务器 CentOS 7.6 64位 下载xShell 7 和 Xftp 7 xShell连接服务器这里有两种方案 A.在Xshell客户端创建密匙，导入到阿里云中 B.在阿里云创建密匙，保存，然后导入到客户端 此处选择B方案，具体步骤如下： ①、登录阿里云ECS服务控制台，在【网络与安全】菜单下选择【秘钥对】，进入秘钥对管理界面。 ②、点击【创建秘钥对】进入创建密钥对界面，如下，填写密钥对名称，选择字段创建密钥对，再点击确认即可。此时会弹出下载当前创建秘钥对的提示，下载后保存到本地即可（链接shell时需要用到）。 ③、创建好后，执行【绑定密钥对】，将新建的密钥对绑定阿里云服务器，然后【一定要重启阿里云服务器才能绑定生效】。 ④、打开Xshell，点击新建，填写名称，主机IP（即阿里云ECS对应实例的对公IP地址） ⑤、点击用户身份验证，选择【Public Key】，用户名为【root】，用户秘钥处点击浏览，将之前下载下来的秘钥文件选择到此处，执行连接，即可正常连接至阿里云服务。 Xftp 也是同样的方法建立会话 在会话中看到 Welcome to Alibaba Cloud Elastic Compute Service ! 成功了 构建镜像cd / 切换到根目录下ll 给出当前目录下所有文件的一个长列表 mkdir appmkdir mycodes 设置当前工作目录， 首先我们需要在 demo 工程的根目录下创建一个 Dockerfile 把我们的工程文件拖进mycodes(Xftp) 在mycodes工作目录下开始构建(打包) 12docker build -f Dockerfile -t mycodes . 执行构建命令 运行容器 12docker run -d --name mycodes -p 9001:80 mycodes 访问 http://39.106.27.165:9001/","link":"/2022/10/09/docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"title":"vue+element实现横向树状表格组件","text":"首先使用的demo数据,根据树状数据进行组件递归渲染除每一层的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183menu:{ &quot;name&quot;: &quot;系统后台&quot;, &quot;id&quot;: 1, &quot;showRow&quot;:true, &quot;indeterminate&quot;:false, &quot;checked&quot;:false, &quot;isRoot&quot;:true, &quot;children&quot;:[ { &quot;name&quot;: &quot;系统管理&quot;, &quot;id&quot;: 20, &quot;children&quot;: [ { &quot;id&quot;: 21, &quot;name&quot;: &quot;人员管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 22, &quot;name&quot;: &quot;岗位管理&quot;, &quot;children&quot;:[], &quot;checked&quot;:true }, { &quot;id&quot;: 23, &quot;name&quot;: &quot;部门管理&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;患者管理&quot;, &quot;id&quot;: 30, &quot;children&quot;: [] }, { &quot;name&quot;: &quot;医院管理&quot;, &quot;id&quot;: 40, &quot;children&quot;: [ { &quot;id&quot;: 41, &quot;name&quot;: &quot;医院列表&quot;, &quot;children&quot;:[], }, { &quot;id&quot;: 42, &quot;name&quot;: &quot;工作室管理&quot;, &quot;children&quot;:[], }, ] }, { &quot;name&quot;: &quot;产品管理&quot;, &quot;id&quot;: 50, &quot;children&quot;: [ { &quot;id&quot;: 55, &quot;name&quot;: &quot;产品服务&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;订单管理&quot;, &quot;id&quot;: 60, &quot;children&quot;: [ { &quot;id&quot;: 61, &quot;name&quot;: &quot;订单管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 62, &quot;name&quot;: &quot;劳务协议&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;公司管理&quot;, &quot;id&quot;: 70, &quot;children&quot;: [ { &quot;id&quot;: 71, &quot;name&quot;: &quot;公司账户&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 72, &quot;name&quot;: &quot;医生工作室&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 73, &quot;name&quot;: &quot;备案审核&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;运营配置&quot;, &quot;id&quot;: 80, &quot;children&quot;: [ { &quot;id&quot;: 81, &quot;name&quot;: &quot;术后管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 82, &quot;name&quot;: &quot;患教中心&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 83, &quot;name&quot;: &quot;意见反馈&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;知识库&quot;, &quot;id&quot;: 90, &quot;children&quot;: [ { &quot;id&quot;: 91, &quot;name&quot;: &quot;药品库&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 92, &quot;name&quot;: &quot;问卷库&quot;, &quot;children&quot;:[ { &quot;id&quot;: 94, &quot;name&quot;: &quot;分类管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 95, &quot;name&quot;: &quot;问卷管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 96, &quot;name&quot;: &quot;题目管理&quot;, &quot;children&quot;:[] }, ] }, { &quot;id&quot;: 93, &quot;name&quot;: &quot;话术问题管理&quot;, &quot;children&quot;:[ { &quot;id&quot;: 97, &quot;name&quot;: &quot;问题管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 98, &quot;name&quot;: &quot;问题分类&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 99, &quot;name&quot;: &quot;未知问题&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 100, &quot;name&quot;: &quot;话术管理&quot;, &quot;children&quot;:[] }, ] }, ] }, ] }, 第一级的根节点的数据是手动加的(写个方法遍历一下第一层数据加上就行,) 1234&quot;showRow&quot;:true,//当前子节点下是否还有子节点&quot;indeterminate&quot;:false,//当前是否支持半选&quot;checked&quot;:false,//选中绑定的值&quot;isRoot&quot;:true,//是否为第一级节点,后续样式判断 使用两个组件嵌套使用treeTable 和 subTable, treeTable是入口组件主要是在这里处理数据,subTable是进行递归的组件,主要是在这个组件里进行节点监听,改变数据渲染对应ui treeTable.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237 &lt;template&gt; &lt;subTable :menu=&quot;menu&quot; @chooseFirstLevel=&quot;chooseFirstLevel&quot;/&gt;&lt;/template&gt;&lt;script&gt;import subTable from &quot;./subTable&quot;;export default { name: &quot;treeTable&quot;, // 递归的终止条件 用于判断当前项的子级的子级是否存在，存在为true，继续递归，不存在就终止 components:{subTable,}, props: { menu: { type: Object, default: () =&gt; ({}), }, }, data(){ return{ // menu:{ // &quot;name&quot;: &quot;系统后台&quot;, // &quot;id&quot;: 1, // &quot;showRow&quot;:true, // &quot;indeterminate&quot;:false, // &quot;checked&quot;:false, // &quot;isRoot&quot;:true, // &quot;children&quot;:[ // { // &quot;name&quot;: &quot;系统管理&quot;, // &quot;id&quot;: 20, // &quot;children&quot;: [ // { // &quot;id&quot;: 21, // &quot;name&quot;: &quot;人员管理&quot;, // &quot;children&quot;:[] // // }, // { // &quot;id&quot;: 22, // &quot;name&quot;: &quot;岗位管理&quot;, // &quot;children&quot;:[], // &quot;checked&quot;:true // }, // { // &quot;id&quot;: 23, // &quot;name&quot;: &quot;部门管理&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;患者管理&quot;, // &quot;id&quot;: 30, // &quot;children&quot;: [] // }, // { // &quot;name&quot;: &quot;医院管理&quot;, // &quot;id&quot;: 40, // &quot;children&quot;: [ // { // &quot;id&quot;: 41, // &quot;name&quot;: &quot;医院列表&quot;, // &quot;children&quot;:[], // }, // { // &quot;id&quot;: 42, // &quot;name&quot;: &quot;工作室管理&quot;, // &quot;children&quot;:[], // }, // ] // }, // { // &quot;name&quot;: &quot;产品管理&quot;, // &quot;id&quot;: 50, // &quot;children&quot;: [ // { // &quot;id&quot;: 55, // &quot;name&quot;: &quot;产品服务&quot;, // &quot;children&quot;:[] // // }, // ] // }, // { // &quot;name&quot;: &quot;订单管理&quot;, // &quot;id&quot;: 60, // &quot;children&quot;: [ // { // &quot;id&quot;: 61, // &quot;name&quot;: &quot;订单管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 62, // &quot;name&quot;: &quot;劳务协议&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;公司管理&quot;, // &quot;id&quot;: 70, // &quot;children&quot;: [ // { // &quot;id&quot;: 71, // &quot;name&quot;: &quot;公司账户&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 72, // &quot;name&quot;: &quot;医生工作室&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 73, // &quot;name&quot;: &quot;备案审核&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;运营配置&quot;, // &quot;id&quot;: 80, // &quot;children&quot;: [ // { // &quot;id&quot;: 81, // &quot;name&quot;: &quot;术后管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 82, // &quot;name&quot;: &quot;患教中心&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 83, // &quot;name&quot;: &quot;意见反馈&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;知识库&quot;, // &quot;id&quot;: 90, // &quot;children&quot;: [ // { // &quot;id&quot;: 91, // &quot;name&quot;: &quot;药品库&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 92, // &quot;name&quot;: &quot;问卷库&quot;, // &quot;children&quot;:[ // { // &quot;id&quot;: 94, // &quot;name&quot;: &quot;分类管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 95, // &quot;name&quot;: &quot;问卷管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 96, // &quot;name&quot;: &quot;题目管理&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;id&quot;: 93, // &quot;name&quot;: &quot;话术问题管理&quot;, // &quot;children&quot;:[ // { // &quot;id&quot;: 97, // &quot;name&quot;: &quot;问题管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 98, // &quot;name&quot;: &quot;问题分类&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 99, // &quot;name&quot;: &quot;未知问题&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 100, // &quot;name&quot;: &quot;话术管理&quot;, // &quot;children&quot;:[] // }, // ] // }, // ] // }, // // ] // }, realMenu:{} } }, created() { this.showRow(this.menu.children) console.log(this.menu) }, mounted() { }, methods: { // 加入showRow属性,用于递归组件 showRow (list) { list.forEach(item =&gt; { item.showRow = this.hasThreeChild(item.children) if (item.children &amp;&amp; item.children.length !== 0) { this.showRow(item.children); } }) }, hasThreeChild (list) { return list.some(item =&gt; item.children.length !== 0) }, //选中第一层数据变化 chooseFirstLevel(val){ console.log(val,'父组件里的变化') console.log(this.menu,'=========父组件里的值============') } }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; subTable.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195 &lt;template&gt; &lt;div class=&quot;permission-subTable&quot;&gt; &lt;div v-if=&quot;!menu.showRow&quot; class=&quot;content-item&quot;&gt; &lt;div class=&quot;cell&quot;&gt; &lt;el-checkbox v-model=&quot;menu.checked&quot; class=&quot;hasEllipsis&quot; :indeterminate=&quot;menu.indeterminate&quot; @change=&quot;(checked) =&gt; handleCheck(checked, menu)&quot;&gt; {{ menu.name }} &lt;/el-checkbox&gt; &lt;/div&gt; &lt;div class=&quot;last-content&quot;&gt; &lt;template v-if=&quot;menu.children &amp;&amp; menu.children.length&quot;&gt; &lt;div v-for=&quot;(child,index) in menu.children&quot; :key=&quot;child.id&quot; class=&quot;last-child-item&quot;&gt; &lt;el-checkbox v-model=&quot;child.checked&quot; @change=&quot;(checked) =&gt; handleCheck(checked, child)&quot;&gt; {{ child.name }} &lt;/el-checkbox&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-else class=&quot;table&quot;&gt; &lt;div :class=&quot;{title:menu.isRoot,secondTitle:!menu.isRoot}&quot;&gt; &lt;div&gt; &lt;el-checkbox v-model=&quot;menu.checked&quot; class=&quot;hasEllipsis&quot; :indeterminate=&quot;menu.indeterminate&quot; @change=&quot;(checked) =&gt; checkChild(checked, menu)&quot;&gt; {{ menu.name }} &lt;/el-checkbox&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;SubTable v-for=&quot;item in menu.children&quot; :key=&quot;item.id&quot; :menu=&quot;item&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'SubTable', props: { menu: { type: Object, default: () =&gt; ({}), }, }, data () { return { }; }, created() { }, watch: { 'menu.children': { handler (data) { console.log(data,'======我监听到了======') if (data) { if (!data.length) return; const checkedAll = !data.some(item =&gt; !item.checked); const menu = this.menu; this.$set(menu, 'checked', checkedAll); const isIndeterminate = data.filter(item =&gt; (item.indeterminate)); if (isIndeterminate.length) { this.$set(menu, 'indeterminate', true); } else { const checkChild = data.filter(item =&gt; (item.checked)); const indeterminate = checkChild.length &lt; data.length &amp;&amp; checkChild.length &gt; 0; this.$set(menu, 'indeterminate', indeterminate); } } }, deep: true, immediate: true, }, }, mounted () { }, methods: { handleCheck (checked, item) { this.checkChild(checked, item); }, checkChild (checked, data) { if (data.children &amp;&amp; data.children.length) { data.children.forEach(item =&gt; { // data.checked = checked; 这里和else一定要用this.$set不然节点会失去响应式,改了很久 this.$set(data, 'checked', checked); this.checkChild(checked, item); }); } else { this.$set(data, 'checked', checked); } this.$forceUpdate() }, }};&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.table { display: flex; overflow: auto;}/deep/.title { width: 156px; display: flex; align-items: center; text-align: center; justify-content: center; border-bottom: 0.5px solid #D8D8D8; background-color: #FAFAFA; .el-checkbox{ color: #000000; .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner{ background-color:#0C88BE; border-color:#0C88BE; } .el-checkbox__input.is-checked+.el-checkbox__label{ color: #000000; } }}/deep/.secondTitle{ width: 156px; display: flex; align-items: center; text-align: center; justify-content: center; border-left: 0.5px solid #D8D8D8; border-bottom: 0.5px solid #D8D8D8; .el-checkbox{ color: #000000; .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner{ background-color:#0C88BE; border-color:#0C88BE; } .el-checkbox__input.is-checked+.el-checkbox__label{ color: #000000; } }}.content { flex: 1;}.item-content { display: flex;}.cell { width: 156px; border-bottom: 0.5px solid #D8D8D8; border-left: 0.5px solid #D8D8D8; border-right: 0.5px solid #D8D8D8; display: flex; align-items: center; justify-content: center; height: 54px;}.last-content { flex: 1; border-bottom: 0.5px solid #D8D8D8; overflow: auto; padding: 16px 14px; justify-content: flex-start; text-align: left; display: flex; border-left: none;}.last-child-item { //flex: 40%; margin-right: 34px;}.content-item { display: flex;}/deep/.permission-subTable{ .el-checkbox{ color: #000000; .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner{ background-color:#0C88BE; border-color:#0C88BE; } .el-checkbox__input.is-checked+.el-checkbox__label{ color: #000000; } }}&lt;/style&gt;&lt;style lang=&quot;less&quot;&gt;.permission-subTable { font-size: 12px; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #000000;}&lt;/style&gt; 重要的逻辑是在watch里面,监听的是每个节点下面的children,做的逻辑是判断下面的的所有节点是否全部选中和部分选中,全部选照片那个这设置当前节点的checked为true,全部未选中设置checked属性为false,选中节点数量在0-children.length之间则设置indeterminate为true。 最终效果","link":"/2023/02/28/vue-element%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%A0%91%E7%8A%B6%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6/"},{"title":"vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法","text":"问题:发现控制台一直输出的是热更新失效 1[vite] page reload src/pages/Login/index.vue (circular imports) 此时路由的写法是这样的 router.ts 1234567891011121314151617181920212223242526272829303132333435363738394041import { createRouter, createWebHashHistory } from 'vue-router';import { RouteRecordRaw } from 'vue-router';const routes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Index', redirect: '/login', }, { path: '/login', name: 'Login', meta: { title: '登录', }, component: () =&gt; import('@/pages/Login/index.vue'), }, { path: '/workbench', name: 'Workbench', meta: { title: '首页', }, component: () =&gt; import('../pages/Workbench/index.vue'), }, { path: '/intern', name: 'Intern', meta: { title: '实习生', }, component: () =&gt; import('@/pages/Intern/index.vue'), },];const router = createRouter({ history: createWebHashHistory(), routes: routes,});export default router; 入口文件是这样的 main.ts 12345678910111213141516171819202122232425import { createApp, type Directive } from 'vue';import App from './App.vue';import bus from './lib/bus';import router from './router';import routes from './router/route';import { setupStore } from '@/store/store';import './styles/index.css';import './styles/tailwind.css';const app = createApp(App);// 自定义指令import * as directives from '@/directives';Object.keys(directives).forEach(key =&gt; { app.directive(key, (directives as { [key: string]: Directive })[key]);});// routes.forEach(route =&gt; {// router.addRoute(route);// });setupStore(app);app.use(router);app.config.globalProperties.$bus = bus;app.mount('#app'); 经过问题排查发现是排除发现是循环引用导致的热更新失效 在接口文件xxxStore.ts中引入了router，router中引用了组件，在接口文件xxxStore.ts，导致了 循环引用 解决办法: router目录下新建route.ts 1234567891011121314151617181920212223242526272829303132333435import { RouteRecordRaw } from 'vue-router';const routes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Index', redirect: '/login', }, { path: '/login', name: 'Login', meta: { title: '登录', }, component: () =&gt; import('@/pages/Login/index.vue'), }, { path: '/workbench', name: 'Workbench', meta: { title: '首页', }, component: () =&gt; import('../pages/Workbench/index.vue'), }, { path: '/intern', name: 'Intern', meta: { title: '实习生', }, component: () =&gt; import('@/pages/Intern/index.vue'), },];export default routes; index.ts 123456789import { createRouter, createWebHashHistory } from 'vue-router';const router = createRouter({ history: createWebHashHistory(), routes: [],});export default router; main.ts 1234567891011121314151617181920212223242526import { createApp, type Directive } from 'vue';import App from './App.vue';import bus from './lib/bus';import router from './router';import routes from './router/route';import { setupStore } from '@/store/store';import './styles/index.css';import './styles/tailwind.css';const app = createApp(App);// 自定义指令import * as directives from '@/directives';Object.keys(directives).forEach(key =&gt; { app.directive(key, (directives as { [key: string]: Directive })[key]);});routes.forEach(route =&gt; { router.addRoute(route);});setupStore(app);app.use(router);app.config.globalProperties.$bus = bus;app.mount('#app'); 重新启动项目可以看到现在已经生效了,解决 114:31:58 [vite] hmr update /src/pages/Login/index.vue, /src/styles/tailwind.css","link":"/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/"},{"title":"什么是闭包-从词法作用域角度分析","text":"在 学习这部分的知识之前我们一定要对变量作用域,let，const（现代方式），var（过去留下来的方式）。这三种声明变量的方式有所了解才行。 在很多地方我们会看到这么一句话：外部函数返回一个持有外部函数变量的内部函数，这种情况就会产生闭包，像下面这种： 12345678910111213function makeCounter() { let count = 0; return function() { return count++; };}let counter = makeCounter();alert( counter() ); // 0alert( counter() ); // 1alert( counter() ); // 2 我们在对词法环境有所了解后，就会对闭包这个东西有更深层次的理解。可以继续往下看一下- 代码块如果我们在代码块{...}内声明了一个变量,那么这个变量只在该代码块内生效。看下面的例子。 123456789{ // 使用在代码块外不可见的局部变量做一些工作 let message = &quot;Hello World&quot;; // 只在此代码块内可见 alert(message); // Hello World}alert(message); // 报错,访问不到message,Error: message is not defined 我们可以用{...}和let一起使用来隔离代码，每段代码执行自己的任务，拥有并使用自己的变量，像下面这样 1234567891011{ // 显示 message let message = &quot;Hello&quot;; alert(message);}{ // 显示另一个 message let message = &quot;World&quot;; alert(message);} 注意在没有相应的代码块的情况下let声明的变量重复声明会报错！！！ 1234567// 显示 messagelet message = &quot;Hello&quot;;alert(message);// 显示另一个 messagelet message = &quot;Goodbye&quot;; // Error: variable already declaredalert(message); 对于 if，for 和 while 等，在 {…} 中声明的变量也仅在内部可见： 123456for (let i = 0; i &lt; 3; i++) { // 变量 i 仅在这个 for 循环的内部可见 alert(i); // 0，然后是 1，然后是 2}alert(i); // Error, no such variable 词法环境1.变量在js 中，每个运行的函数，代码块{...}以及整个脚本，都有一个都有一个被称为 词法环境（Lexical Environment） 的内部（隐藏）的关联对象。 词法环境对象由两部分组成： 1.环境记录（Environment Record） —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。 2.对外部词法环境的引用，与外部代码相关联。 我们可以在代码块中声明很多的变量，这些变量就是环境记录这个特殊的内部关联对象的属性，我们获取修改这些变量就意味着我们在获取或者修改词法环境中的属性。看下面这段简单的代码代码这个图片，出自（https://zh.javascript.info/） 在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 null。很容易理解句号。 再看下面这段代码，随着代码开始并继续运行，词法环境发生了变化。 1.当脚本开始运行，词法环境预先填充了所有声明的变量。 最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 let 声明前，不能引用它。几乎就像变量不存在一样。 换句话说在这个代码块里面js引擎扫了一边，知道你有哪些变量了，但是js引擎要按照流程办事，这个变量必须用let 给他安个名字，我才能对它进行操作 2.然后 let phrase 定义出现了。它尚未被赋值，因此它的值为 undefined。从这一刻起，我们就可以使用变量了。 3.phrase 被赋予了一个值。 4.phrase 的值被修改。 总结一下 变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。 操作变量实际上是操作该对象的属性。 2.函数声明一个函数其实也是一个值，就像变量一样。 但是不同的是 函数声明的初始化会被立即完成。 可以这样理解 js 引擎先预先扫描一个代码块，里面有变量有属性，在代码运行的阶段，我要使用它，变量必须要用let去初始化，但是函数不需要了，js引擎已经在第一次扫描的时候，函数就初始化完成了看下面的图 这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 let say = function(name)...。 3.内部和外部的词法环境在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。 例如，对于 **say(“John”)**，它看起来像这样（当前执行位置在箭头标记的那一行上）： 在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）： 内部词法环境与 say 的当前执行相对应。它具有一个单独的属性：name，函数的参数。我们调用的是 say(“John”)，所以 name 的值为 “John”。外部词法环境是全局词法环境。它具有 phrase 变量和函数本身。 这样看在函数say(&quot;John&quot;)没调用之前只有一个全局的词法环境 环境记录中保存着两个属性 phrase：hello和 say：function，外部的引用为null，没有地方引用当前这个词法环境。 现在say(&quot;John&quot;)开始调用，新建了一个词法环境（内部），内部词法环境记录中有一个属性单独的属性：name，函数的参数。我们调用的是 say(&quot;John&quot;)，所以 name 的值为 “John”，这个时候这段代码alert(`${pharse}`)的执行他在自己的词法环境中找不到变量pharse，所以引用了外部，在这里内部词法环境就有了对外部的引用了，看一下这个搜索过程 总结一下： 当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。 4.返回函数让我们现在再用词法环境来探索一下闭包这个例子 12345678910111213function makeCounter() { let count = 0; return function() { return count++; };}let counter = makeCounter();alert( counter() ); // 0alert( counter() ); // 1alert( counter() ); // 2 上面函数调用的例子让我们现在可以知道，在每次 makeCounter() 调用的开始，都会创建一个新的词法环境对象，以存储该 makeCounter 运行时的变量。c 在这里有点不一样的地方，在执行 makeCounter() 的过程中创建了一个仅占一行的嵌套函数：return count++。我们尚未运行它，仅创建了它。在这里我们创建了一个函数。 这里有个十分重要的概念：所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。 这个概念非常重要，在知道这个概念之后，我们大概可以解释一下闭包的情况了， counter.[[Environment]] 有对 {count: 0} 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。[[Environment]] 引用在函数创建时被设置并永久保存。 新的counter函数在诞生的时候就有了对{count: 0}词法环境的引用。 稍后，当调用 counter() 时，会为该调用创建一个新的词法环境，在执行counter++的时候本身是没有counter这个变量的，但是她诞生的时候她的[[Environment]]有对外部词法环境{count: 0}的引用，向上查找就找到了count变量执行了count++ 看，现在，当 counter() 中的代码查找 count 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 makeCounter() 的词法环境，并且在哪里找到就在哪里修改。在变量所在的词法环境中更新变量。 继续执行 如果我们调用 counter() 多次，count 变量将在同一位置增加到 2，3 等。 总结外部函数返回一个持有外部函数变量的内部函数，返回一个内部函数 即内部函数在诞生的时候都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用—–持有外部函数的变量。内部函数诞生后在调用时，会沿着词法环境对外部的引用去查找变量如果在外部词法环境中找到了该变量，那么就在那个地方进行修改，这样就产生了闭包。","link":"/2022/08/29/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E4%BB%8E%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90/"},{"title":"全方位理解React类式组件新旧生命周期","text":"只有在react类式组件中才会有生命周期的概念,因为 class 组件会创建对应的实例，而函数组件不会(函数式组件是用useEffect来体现生命周期的)。组件实例从被创建到被销毁的过程称为组件的生命周期。我们每一次状态的更改都会执行render()阶段和commit阶段,在新版废弃了一些钩子,又新增了一些钩子,我们从旧版到新版来看每一个钩子,然后分析页面渲染时执行的顺序。 一、旧版生命周期 constructor 该方法只会执行一次，调用该方法会返回一个组件实例。在这个阶段我们可以对组件this.state进行赋值,也可以直接获取到props,在其他地方我们不能直接赋值,只能通过this.setState进行状态修改 componentWillMount（UNSAFE） 这个钩子我们用的比较少,是在render渲染之前调用,在这个钩子里修改state是不会触发重新渲染页面,因为此时页面还未挂在到Dom上我们一般不会在这里初始化state,一般是在constructor中初始化 state,在componentDidMount发起异步请求 render（） render 函数是纯函数，也就是对于相同的 state 和 props，它总是返回相同的渲染结果。如果 shouldComponentUpdate(后面会提到) 生命周期钩子返回 false，则 render 方法不会执行。 componentDidMount 在组件挂载之后执行，也只会执行一次,在浏览器更新视图之前调用,在 componentDidMount钩子中调用this.setState,会触发额外的渲染，会再一次调用 render 函数，但是浏览器中视图的更新只会执行一次。我们一般会在这个钩子里发起请求,添加订阅等 componentWillReceiveProps()（UNSAFE） 在组件嵌套,传入props时,组件在接收到新的props的时候调用,第一次调用不算,不会更新,可以接收props参数,是父组件传过来最新的props shouldComponentUpdate() 在修改状态后会调用该生命周期,该生命周期的必须有返回值,默认是true,如果改成false则在状态更新后,不会调用后续的componentWillUpdate(),render(),componentDidUpdate(), componentWillUpdate()（UNSAFE） 在组件即将更新之前调用，如果 shouldComponentUpdate阀门 函数返回 false，则不会调用 componentWillUpdate 方法。这个生命周期钩子和 componentWillMount 类似，调用的时机是相同的，只不过 componentWillMount 在组件首次渲染时执行，而 componentWillUpdate 在组件后续更新时执行。这两个生命周期函数都不经常使用。 componentDidUpdate() 在组件更新后立即调用，首次渲染不会调用该方法。和 componentDidMount 一致，只是 componentDidMount 在首次渲染时调用，而 componentDidUpdate 在后续的组件更新时调用。可以在这个生命周期中直接调用 this.setState，componentDidUpdate 接收三个参数，分别是 prevProps、prevState、snapshot，即：前一个状态的 props，前一个状态的 state、getSnapshotBeforeUpdate 的返回值。如果组件实现了 getSnapshotBeforeUpdate 生命周期函数，则 getSnapshotBeforeUpdate 的返回值将作为 componentDidUpdate 的第三个参数。使用场景：在这个生命周期方法中，可以对 DOM 进行操作或者进行网络请求。 componentWillUnmount() 这个生命周期函数会在组件卸载以及销毁之前调用。使用场景： 通常用来执行组件的清理操作，例如：清除 timer、取消网络请求、清除订阅等。 在新版中,这三个钩子被废弃1.componentWillMount2.componentWillReceiveProps3.componentWillUpdate他们很容易被程序员滥用和误用 二、新版生命周期 static getDerivedStateFromProps() 它会在调用 render 方法之前被调用，不管是在初始挂载时还是在后续组件更新时都会被调用。它是一个静态方法，接收 props 和 state 两个参数。它的调用时机和 componentWillMount、componentWillUpdate、componentWillReceiveProps 一样都是在 render 方法被调用之前，它可以作为 componentWillMount、componentWillUpdate 和 componentWillReceiveProps 的替代方案。它可以返回一个对象，用来更新 state，就像它的名字一样，从 props 中获取衍生的 state。如果不需要更新 state 则可以返回 null。如果子组件的更新依赖于父组件的props,那么我们可以在这个生命周期中做处理,在封装组件时可以用到 static getSnapshotBeforeUpdate() 此生命周期函数在最近一次渲染提交至 DOM 树之前执行，此时 DOM 树还未改变，我们可以在这里获取 DOM 改变前的信息，例如：更新前 DOM 的滚动位置。它接收两个参数，分别是：prevProps、prevState，上一个状态的 props 和上一个状态的 state。它的返回值将会传递给 componentDidUpdate 生命周期钩子的第三个参数。使用场景： 需要获取更新前 DOM 的信息时。比如state状态修改之前滚动条的位置。 三、旧版生命周期执行顺序 初始化阶段 1.constructor()2.componentWillMount()3.render()4.componentDidMount() 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1.shouldComponentUpdate()2.componentWillUpdate()3.render()4.componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1.componentWillUnmount() 四、新版生命周期执行顺序 初始化阶段: 由ReactDOM.render()触发—初次渲染 1.constructor() 2.getDerivedStateFromProps 3.render() 4.componentDidMount() 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1.getDerivedStateFromProps 2.shouldComponentUpdate() 3.render() 4.getSnapshotBeforeUpdate 5.componentDidMount() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1.componentWillUnmount() 五、父子组件嵌套生命周期执行顺序 初始化阶段:父子组件第一次进行渲染加载时： 1.Parent 组件： constructor()2.Parent 组件： getDerivedStateFromProps()3.Parent 组件： render()4.Child 组件： constructor()5.Child 组件： getDerivedStateFromProps()6.Child 组件： render()7.Child 组件： componentDidMount()8.Parent 组件： componentDidMount() 子组件修改自身状态 state 1.Child 组件： getDerivedStateFromProps()2.Child 组件： shouldComponentUpdate()3.Child 组件： render()4.Child 组件： getSnapshotBeforeUpdate()5.Child 组件： componentDidUpdate() 修改父组件中传入子组件的 props state 1.Parent 组件： getDerivedStateFromProps()2.Parent 组件： shouldComponentUpdate()3.Parent 组件： render()4.Child 组件： getDerivedStateFromProps()5.Child 组件： shouldComponentUpdate()6.Child 组件： render()7.Child 组件： getSnapshotBeforeUpdate()8.Parent 组件： getSnapshotBeforeUpdate()9.Child 组件： componentDidUpdate()10.Parent 组件： componentDidUpdate() 卸载子组件 1.Parent 组件： getDerivedStateFromProps()2.Parent 组件： shouldComponentUpdate()3.Parent 组件： render()4.Parent 组件： getSnapshotBeforeUpdate()5.Child 组件： componentWillUnmount()6.Parent 组件： componentDidUpdate() 重新挂载子组件 1.Parent 组件： getDerivedStateFromProps()2.Parent 组件： shouldComponentUpdate()3.Parent 组件： render()4.Child 组件： constructor()5.Child 组件： getDerivedStateFromProps()6.Child 组件： render()7.Parent 组件： getSnapshotBeforeUpdate()8.Child 组件： componentDidMount()9.Parent 组件： componentDidUpdate()","link":"/2022/05/25/%E5%85%A8%E6%96%B9%E4%BD%8D%E7%90%86%E8%A7%A3React%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"利用MessageChannel深拷贝","text":"平时做对象深拷贝我们一般回想到用JSON,像这种 12345let obj = { a:1, b:2 } let _obj = JSON.parse(JSON.stringify(obj)) 但是这种会有问题,遇到循环引用对象就会解析错误 123456let obj = { a:1, b:2 } obj.c=obj let _obj = JSON.parse(JSON.stringify(obj)) 我们可以用MessageChannel()来实现深拷贝,我们先实例化MessageChannel构造函数会得到port1,port2,两个端点,一个用来发送信息一个用来接收信息,通过打印发现我们已经实现了深拷贝 12345678910let obj={ a:1, b:2 } const {port1,port2} = new MessageChannel() port1.postMessage(obj) port2.onmessage=(msg)=&gt;{ console.log(msg.data) console.log(msg.data==obj)//fasle } 循环引用的数据也是可以的,没什么问题 1234567891011let obj={ a:1, b:2 } const {port1,port2} = new MessageChannel() obj.c=obj port1.postMessage(obj) port2.onmessage=(msg)=&gt;{ console.log(msg.data) console.log(msg.data==obj)//fasle } 那么我们可以封装一个函数 123456789function deepClone(obj) { return new Promise((resolve)=&gt;{ const {port1,port2} = new MessageChannel() port1.postMessage(obj) port2.onmessage=(msg)=&gt;{ resolve(msg.data) } }) }","link":"/2022/12/27/%E5%88%A9%E7%94%A8MessageChannel%E6%B7%B1%E6%8B%B7/"},{"title":"在Vue3中使用quill富文本编辑器","text":"首先安装 1npm install @vueup/vue-quill@latest --save main.js 123456789101112131415161718import { createApp } from 'vue'import App from './App.vue'import { QuillEditor } from '@vueup/vue-quill'import '@vueup/vue-quill/dist/vue-quill.snow.css';import '@vueup/vue-quill/dist/vue-quill.bubble.css'import 'element-plus/dist/index.css'import ElementPlus from 'element-plus'import router from './router'import store from './store'const app = createApp(App)app.use(store)app.use(router)app.use(ElementPlus)app.component('QuillEditor', QuillEditor)app.mount('#app') Myeditor.vue简单封装一下， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;div&gt; &lt;!-- 注意区别，content 和 contentType --&gt; &lt;QuillEditor ref=&quot;quillEditor&quot; v-model:content=&quot;content&quot; contentType=&quot;html&quot; :options=&quot;editorOption&quot; @blur=&quot;onEditorBlur($event)&quot; @focus=&quot;onEditorFocus($event)&quot; @editorChange=&quot;onEditorChange($event)&quot; @ready=&quot;onEditorReady($event)&quot; /&gt; &lt;button v-on:click=&quot;insertImg&quot;&gt;插入一张图片&lt;/button&gt; &lt;button v-on:click=&quot;insertText&quot;&gt;插入文字&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import { ref,toRaw,defineEmits,defineExpose } from 'vue';// import {Quill} from &quot;@vueup/vue-quill&quot;;//富文本初始化配置// eslint-disable-next-line no-unused-varslet myQuillconst quillEditor = ref(null)let content = ref(&quot;&quot;);//定义content//获取ref实例//富文本面板配置const editorOption= { modules: { toolbar: false, // 这里将工具栏隐藏 }, placeholder: '请输入内容...'}//富文本准备完成const onEditorReady =(quill)=&gt;{ myQuill = quill}//给父元素传值const emit = defineEmits(['getText','getHtml'])const onEditorChange = ()=&gt;{ const html = toRaw(quillEditor.value).getHTML() const myText = toRaw(quillEditor.value).getText() const quill = toRaw(quillEditor.value).getQuill() emit('getText',myText) emit('getHtml',html) console.log(content.value,'-----content----') // console.log(myText,'-----html----') console.log(quill,'-------quillEditor----------')}const onEditorFocus = (e)=&gt;{ console.log(e,'--------onEditorFocus--------')}const onEditorBlur = (e)=&gt;{ console.log(e,'--------onEditorBlur--------')}const insertImg = ()=&gt;{ const quill = toRaw(quillEditor.value).getQuill() quill.insertEmbed(length, 'image', &quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;) quill.setSelection(length + 1) // quill.insertEmbed(quill.selection.savedRange.index,&quot;MsgEmoji&quot;,{src: &quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;, code: &quot;0&quot; },Quill.sources.USER);}const insertText = (value)=&gt;{ const quill = toRaw(quillEditor.value).getQuill() //插入指定表情转移文字 quill.insertEmbed(quill.selection.savedRange.index, 'text', value) quill.setSelection(quill.selection.savedRange.index+value.length)}//将插入表情的方法暴露给父组件defineExpose({ insertText })&lt;/script&gt;&lt;style&gt;.ql-editor{ height: 300px;}&lt;/style&gt;","link":"/2023/09/07/%E5%9C%A8Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"深入理解js继承","text":"在理解继承之前,懂得什么是原型链是非常重要的,必须熟练掌握,__prote__,prototype,constructor这几个属性,并且清楚他们之间的关系。 1.原型链继承先看一个例子 123456789101112131415161718function Parent() { this.name='父亲' } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //儿子身上并没有定义任何属性和方法,现在儿子也想当爸爸,访问到Parent上的属性和方法 function Child() { } //我们让child实例的原型等于 Parent实例 Child.prototype = new Parent() let child = new Child() let parent = new Parent() //这样孩子就能做爸爸了 console.log(child.name)//父亲 child.Say()//我是你爸爸 child实例化对象—&gt;Child.prototype(也是Parent的实例对象)—-&gt;Parent.prototype 实例化出来的child 可以访问到他构造函数Child.prototype,这时,我们的Child.prototype是构造函数Parent的实例对象时Parent new出来的,那么Child.prototype就可以通过原型访问到Parent.prototype,这就是原型链继承 注意:原型链继承在访问引用类型数据上可能会出现问题,我们来看下面的例子 1234567891011121314151617181920function Parent() { this.name=['父亲','打篮球'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //儿子身上并没有定义任何属性和方法,现在儿子也想当爸爸,访问到Parent上的属性和方法 function Child() { } //我们让child实例的原型等于 Parent实例 Child.prototype = new Parent() let child1 = new Child() let child2 = new Child() //改变name值 child1.name.push('哈哈哈') console.log(child1.name)//['父亲', '打篮球', '哈哈哈'] console.log(child2.name)//['父亲', '打篮球', '哈哈哈'] // 两个实例的的name值相互影响了(引用类型数据) 两个实例的的name值相互影响了(引用类型数据) 这是因为由于基本类型和引用类型数据的保存方式不同引起的,引用类型保存的都是指针,child1child2指针不同但是指向同一地址,现在把地址里的内容改了,所以导致访问的值都变了 这里我们都是是通过Parent的实例对象进行继承的所以都指向了同一个地址 我们可以用构造函数继承解决这个问题 2.构造函数继承1234567891011121314151617181920212223242526function Parent() { this.name='父亲' this.hobby=['唱','跳','rap'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //利用call改变this指向,将Parent的this.指向Child function Child() { Parent.call(this) } let child1 = new Child() let child2 = new Child() //改变name 基本数据类型的值没有影响 child1.name='儿子' console.log(child1.name)//儿子 console.log(child2.name)//父亲 //改变hobby 引用类型数据的值没有影响 child1.hobby.push('篮球') console.log(child1.hobby)//['唱','跳','rap','篮球'] console.log(child2.hobby)//['唱','跳','rap'] 我们在Child函数中利用call借用Parent的this,改变Child的this,就可以访问到Parent 身上的属性, 注意:构造函数继承不能让child访问到Parent原型身上的方法的,这是他的缺陷 3.组合继承(伪经典继承)123456789101112131415161718192021222324252627function Parent() { this.name='父亲' this.hobby=['唱','跳','rap'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //利用call改变this指向,将Parent的this.指向Child function Child() { //执行了一次Parent() Parent.call(this) } //执行了一次Parent() Child.prototype = new Parent() let child1 = new Child() let child2 = new Child() //改变name 基本数据类型的值没有影响 child1.name='儿子' console.log(child1.name)//儿子 console.log(child2.name)//父亲 //改变hobby 引用类型数据的值没有影响 child1.hobby.push('篮球') console.log(child1.hobby)//['唱','跳','rap','篮球'] console.log(child2.hobby)//['唱','跳','rap'] 这种继承方式相当于将前面两种方式结合了一下,同时用原型链继承和改变this指向,但是这种方式执行了调用了两次Parent(),所以不好 4.寄生组合继承(经典继承)123456789101112131415161718192021222324252627282930function Parent() { this.name='父亲' this.hobby=['唱','跳','rap'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //利用call改变this指向,将Parent的this.指向Child function Child() { //执行了一次Parent() Parent.call(this) } //执行了一次Parent() // Child.prototype = new Parent() //寄生组合继承的核心,让Child原型继承到Parent的原型 //Object.create(Parent.prototype)会返回一个对象,根据传入的参数觉得 Child.prototype = Object.create(Parent.prototype) let child1 = new Child() let child2 = new Child() //改变name 基本数据类型的值没有影响 child1.name='儿子' console.log(child1.name)//儿子 console.log(child2.name)//父亲 //改变hobby 引用类型数据的值没有影响 child1.hobby.push('篮球') console.log(child1.hobby)//['唱','跳','rap','篮球'] console.log(child2.hobby)//['唱','跳','rap'] 寄生组合继承的核心就是让Child原型继承到Parent的原型,这里用Object.create(Parent.prototype)返回Parent的原型对象,这样就解决了调用两次的问题","link":"/2022/01/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%BB%A7%E6%89%BF/"},{"title":"CSRF-跨站请求伪造攻击","text":"参考链接[https://blog.csdn.net/u011397981/article/details/132871362](https://blog.csdn.net/u011397981/article/details/132871362) 什么是CSRF攻击CSRF（Cross-Site Request Forgery）的全称是“跨站请求伪造”，也被称为“One Click Attack”或者“Session Riding”，通常缩写为CSRF或者XSRF。CSRF的中文名称尽管听起来像跨站脚本攻击（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来攻击受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 我们可以这么理解CSRF攻击：攻击者首先盗用了你的身份，然后以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的账户购买商品等。CSRF攻击其实是利用了web中用户身份认证验证的一个漏洞：简单的身份验证仅仅能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 CSRF攻击的流程 CSRF攻击攻击原理及过程如下： 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 从上面的流程可以看出，想要达成CSRF攻击，必须达到两个基本条件： 登录受信任站点A，并在本地生成Cookie。 在不登出A的情况下，訪问危急站点B。 常见的CSRF攻击类型GET类型的CSRF仅仅须要一个HTTP请求。就能够构造一次简单的CSRF。 样例： 12银行站点A：它以GET请求来完毕银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危急站点B：它里面有一段HTML的代码例如以下： 12&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先,你登录了银行站点A,然后訪问危急站点B,这时你会发现你的银行账户少了1000块。为什么会这样呢？原因是银行站点A违反了HTTP规范，使用GET请求更新资源。在訪问危急站点B的之前，你已经登录了银行站点A，而B中的 一个合法的请求，但这里被不法分子利用了）。所以你的浏览器会带上你的银行站点A的Cookie发出Get请求，去获取资源以GET的方式请求第三方资源（这里的第三方就是指银行站点了，原本这是http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 ，结果银行站点服务器收到请求后，觉得这是一个更新资源操作（转账操作），所以就立马进行转账操作。 POST类型的CSRF这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单，如： 1234&lt;form action=http://wooyun.org/csrf.php method=POST&gt; &lt;input type=&quot;text&quot; name=&quot;xx&quot; value=&quot;11&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 CSRF 攻击实例：受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 bank.example/withdraw?ac… 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：bank.example/withdraw?ac… Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”bank.example/withdraw?ac… ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 预防CSRF攻击 1. 验证HTTP Referer字段根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。验证Referer方式总结 优点：使用方便，开发简单，一定程度上能预防CSRF攻击； 缺点：这种机制完全依托于浏览器，Referer字段容易被故意篡改，或者被或者被禁用 2. 请求中添加token并验证token就是服务端返回给客户端类似sessionid那样一长串的类值（长是为了防暴力猜解）。csrf依赖于浏览器该问链接时自动对应网站的cookie带上，token不放cookie（一般form表单加个hidden属性的input标签来存放）csrf就没法获取token，这样我们就可以通过检测发送过来的数据包中是否有正确的token值来决定是否响应请求。在讲清token防御的原理后，我们再来讲token的设计，因为token方式给人的感觉很复杂令人望而生畏。 我们首先明确一个问题，就是能够防止csrf攻击的token，并不需要每次请求都不一样，在用户登录后到退出前的这整个过程中的所有请求token完全可以是一样。因为（在基于没有其他漏洞会泄漏本次会话的token的设想下）黑客是无法获取用户的tokne，所以又何必每个请求都要生成一个新的token呢。（token每次请求都要不一样的想法是受防重放攻击的影响）只考滤防csrf不考滤防重放的情况下，token设计就简单多了。 验证token方式总结 安全程度比Referer的方式要高； 实现方式上稍微复杂； 需要保证token存储的安全性。 3. 在 HTTP 头中自定义属性并验证这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。验证Head属性方式总结 使用方式较简单，而且token不容易泄露 使用场合较少，局限性较大。","link":"/2023/05/27/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"},{"title":"XSS-跨站脚本攻击","text":"什么是XSS攻击XSS （Cross-site scripting）攻击，即跨站脚本攻击。攻击者通过在受害者的浏览器中注入恶意代码，攻击受害者的登录凭证、盗取敏感信息或控制受害者的会话等。根据恶意脚本的注入方式的不同可以分为 反射性xss攻击，存储型xss攻击，dom型xss攻击 反射型XSS攻击 1. 什么是反射型XSS攻击反射型XSS攻击是将注入的恶意脚本添加到一个网址中，然后给用户发送这个网址。一旦用户打开这个网址，就会执行脚本并导致攻击。攻击负载和脚本跟随用户点击链接，并被嵌入到响应中，在浏览器上执行。 2. 反射型XSS攻击的原理&amp;步骤 攻击者构造一个带有恶意脚本的链接，其链接参数包含用户的输入。 将链接发送给受害者。 受害者点击链接时，恶意脚本会被浏览器解析并执行，从而执行攻击者的意图。 3. 反射型XSS攻击的示例（1） 攻击者针对http://www.example.com的一个搜索页定制下面链接 1http://www.example.com/search?query=&lt;script&gt;alert('XSS')&lt;/script&gt; （2） 攻击者将连接发送给被攻击者（3） 被攻击者点开链接后，会执行嵌入的XSS脚本，从而实现攻击者的意图。（比如后去用户Session） 4. 如何防御反射型XSS攻击从Web应用搭建的维度，可以通过下列措施防范XSS攻击 入参的强校验&amp;过滤： 服务器端对参数进行强校验，检查是否存在不安全的字符或脚本（carrot, &lt;,&gt;,/等），并过滤掉它们。所有恶意代码将被替换为相应的字符，它们将被禁止对用户浏览器执行。 输出编码/转义：将用户的输入作为消息从服务器返回时，确保将HTML标签和JavaScript等脚本代码中的特殊字符转义或编码。例如，将&lt;&gt;等字符编码为 &lt;和&gt;以避免它们被浏览器解释为HTML标签。 使用HTTPOnly cookie：HTTPOnly cookie在请求不被攻击者利用基于脚本的执行语言时无法访问，也不能通过document.cookie来访问。这一点可以有效的降低反射型XSS的压力。 使用安全控件：对于特殊页面（例如登录页面），使用验证码和其他安全性控件。 从用户的角度，可以通过下列措施防范XSS攻击 提示用户小心恶意链接的存在，防止用户在没有意识到危险的情况下点击恶意链接。 浏览器端X-XSS-Protection：这是一个现代浏览器提供的防御措施，可以在发现反射型XSS攻击时自动阻止并提供阻止攻击的选项。使用此功能的网站需要设置X-XSS-Protection标头，并将其设置为1来启用此功能：X-XSS-Protection: 1; mode=block。 存储型XSS攻击 1. 什么是存储型XSS攻击存储型 XSS 攻击指的是攻击者将恶意脚本提交到受害网站的数据库中，当其他用户浏览包含该恶意脚本链接的页面时，就会执行该脚本，从而导致攻击者的目的得以实现。由于是将恶意脚本保存在数据库中，所有访问包含恶意代码的页面的用户都受到攻击。而且这种攻击方式难解决。 2. 存储型XSS攻击的原理&amp;步骤（1）攻击者在受害网站上查找存在漏洞的输入表单，例如评论框或搜索框等。（2）攻击者将恶意代码或脚本插入到输入表单中，以便在提交表单时存储到数据库中。例如，攻击者可以在评论框中插入一段 JavaScript 代码，用于窃取存储在 Cookie 中的会话标识符。（3）网站接收到含有恶意代码的表单数据，将其存储到数据库中。此时，攻击者的恶意代码已经写入到数据库中并保存下来。（4）受害用户访问这个包含恶意代码的页面时，恶意代码从数据库中提取出来并在受害用户的浏览器上执行，触发攻击者设定的操作。（5）攻击者利用受害用户的会话标记等获取受害者的身份和敏感信息。例如，可以利用恶意脚本窃取用户的个人信息、登录凭据或信用卡信息，并发送给攻击者。 3. 如何防御存储型XSS攻击 存储型 XSS 攻击通常比反射型 XSS 攻击更难防止。以下是几种常见的防御措施： 输入过滤和验证：对用户的输入进行强校验。过滤不安全的字符，校验数据类型、长度和格式等是否合法，防止不安全的数据被存储。 输出编码/转义：在输出用户数据之前，对数据进行编码转义，可以使用 HTML 或 URL 编码来处理特殊字符、脚本和标记，以防止恶意代码被执行。 防御性编程：使用安全的 API、利用验证机制、进行限制访问控制。 CSP：Content Security Policy 可以设置白名单和黑名单，限制页面加载的资源类型和来源，防止恶意脚本和样式被加载。 *使用 HTTPS：***使用 HTTPS 可以防止攻击者在传输过程中窃取会话标识符和敏感数据等信息。 限制和控制用户输入：限制用户可以输入的数据内容、长度和格式。例如，可以使用 HTML5 的 input 标签提供的 pattern 属性限制用户输入的数据类型和格式。 存储型XSS攻击最好的防御措施是：永远不要相信前端，永远不要相信用户的输入。 DOM型XSS攻击 1. 什么是DOM型XSS攻击DOM 型 XSS 攻击是一种利用 DOM 基于 HTML 解析过程中的安全漏洞进行的跨站攻击。DOM 型 XSS 攻击不涉及服务器的参与，完全基于客户端的机制，攻击者通过篡改网页中的 DOM 元素和属性，注入恶意代码进而达到攻击目的。 2. DOM型XSS攻击的原理和步骤DOM型XSS攻击的过程与反射型XSS攻击极其类似，主要差异在于反射型XSS会把攻击脚本传递给服务器，而DOM型XSS不需要，从而可以达到绕过WAF、躲避服务端的检测效果。DOM型XSS攻击通常分为以下几个步骤： 攻击者诱导用户访问一个恶意网站或者跨站点的合法网站。 网站中的 JavaScript 脚本将用户输入的数据组合成 DOM 片段。 攻击者篡改了 DOM 片段或者修改了 DOM 的属性，注入恶意的脚本，从而执行了非法行为。 当浏览器解析 DOM 片段时，执行了恶意脚本，使恶意代码被执行。 攻击者成功地窃取了用户敏感信息或者完成了其他非法操作。 3. 如何防御DOM型XSS攻击 输入过滤和验证：对用户的输入进行强校验。过滤不安全的字符，校验数据类型、长度和格式等是否合法，防止不安全的数据被存储。 输出编码/转义：在输出用户数据之前，对数据进行编码转义，可以使用 HTML 或 URL 编码来处理特殊字符、脚本和标记，以防止恶意代码被执行。 使用 innerText 或 textContent 而不是 innerHTML：避免将用户输入的数据直接插入到 innerHTML 中。可以使用白名单机制过滤不安全的标记，或使用innerText、textContent 等安全的API。 使用Content Security Policy（CSP）：CSP 可以设置白名单和黑名单，限制页面加载的资源类型和来源，从而防止恶意脚本和样式被加载。 使用安全沙箱：应用沙盒技术限制 JavaScript 运行的环境，从而可以防止恶意 JS 脚本操作或者篡改文档 DOM 等。 更新和升级浏览器：定期升级浏览器，减少已知红旗漏洞的影响。","link":"/2023/05/28/XSS-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"},{"title":"cookie sessionStorage LocalStorage","text":"三者的异同： 生命周期：cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效localStorage：除非被手动清除，否则将会永久保存。sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。 存放数据大小：cookie：4KB左右localStorage和sessionStorage：可以保存5MB的信息。 http请求：cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性：cookie：需要程序员自己封装，源生的Cookie接口不友好localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景：从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比Storage更好用的。其他情况下，可以使用storage，就用storage。 storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的，哈哈哈你们懂得。 localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。","link":"/2022/05/27/cookie-sessionStorage-LocalStorage/"},{"title":"Promise","text":"promise是什么东西？官方解释 ：Promise是异步编程的一种解决方案，可以替代传统的解决方案–回调函数和事件。ES6统一了用法，并原生提供了Promise对象。作为对象，Promise有以下两个特点： 对象的状态不受外界影响。 一旦状态改变了就不会再变，也就是说任何时候Promise都只有一种状态。 我的解释：Promise 实际上就是作为一个容器，这个容器放着会在未来产生结果的代码，未来的结果一旦产生Promise的状态就会被定下来，我们就可以根据这个状态或者未来代码执行的结果进行下一步的操作。 Promise的三种状态Promise有三种状态，分别是 Pending (进行中)、Resolved (已完成)、Rejected (已失败)。注意Pending状态是从Promise对象被创建开始时就会开始执行其内部代码，所以从创建开始他就是pending状态，同时Priomise对象内部代码的执行机制时从创建就开始执行。Promise从Pending状态开始，如果成功就转到成功态，并执行resolve回调函数；如果失败就转到失败状态并执行reject回调函数。这个状态时不可逆的，下面看这个例子， 1234567891011121314151617181920212223242526272829// 创建一个Promise对象const promiseExample = new Promise((resolve, reject) =&gt; { const randomNumber = Math.random(); if (randomNumber &gt; 0.5) { // 模拟异步操作成功 setTimeout(() =&gt; { resolve(&quot;Promise resolved successfully!&quot;); }, 1000); } else { // 模拟异步操作失败 setTimeout(() =&gt; { reject(new Error(&quot;Promise rejected!&quot;)); }, 1000); }});// 打印Promise状态：进行中console.log(promiseExample,&quot;Promise状态：进行中&quot;);// 使用.then()方法处理异步操作成功的情况promiseExample.then((result) =&gt; { // 打印Promise状态：已成功 console.log(promiseExample,&quot;Promise状态：已成功&quot;); console.log(&quot;成功的结果：&quot;, result);}).catch((error) =&gt; { // 打印Promise状态：已失败 console.log(promiseExample,&quot;Promise状态：已失败&quot;); console.error(&quot;失败的原因：&quot;, error);}); 我们看一下这个例子，用一个随机数模拟出从pending-fulfilled,pending-reject,我们看以下打印来验证以下promise装填变化过程中的代码执行顺序失败的过程成功的过程 excutor ， resolve ，reject上面的例子涉及到三个PromiseApi参数 executor 称为执行器，为一回调函数 (resolve, reject) =&gt; {}：调用 resolve，Promise 实例的状态会从 pending 变为 fulfilled如果不调用 resolve / reject，则 Promise 实例的状态将一直是 pending。 调用 resolve / reject 改变 Promise 实例状态时，可传入 1 个参数作为该 Promise 实例的值： 123456const pro1 = new Promise(resolve =&gt; resolve('pro1Resolve'));console.log('pro1', pro1); // pro1 Promise { &lt;fulfilled&gt;: 'pro1Resolve' }const pro2 = new Promise((_, reject) =&gt; reject('pro2Reject'));console.log('pro2', pro2); // pro2 Promise { &lt;rejected&gt;: 'pro2Reject' } 除了调用 resolve / reject ，抛出错误也会改变 Promise 实例的状态。抛出错误，Promise 实例的状态从 pending 变为 rejected： 12345const pro3 = new Promise(() =&gt; { throw 'errorMsg';});console.log('pro3', pro3); // pro3 Promise { &lt;rejected&gt;: 'errorMsg' } 状态只能从 pending 变为 fulfilled / rejected，且状态一旦更新就不会再改变：d 123456const pro = new Promise((resolve, reject) =&gt; { resolve(); // resolve 写在前面，生效 throw 'error'; // 后面的 throw 无效});console.log('pro', pro); // pro1 Promise { &lt;fulfilled&gt;: undefined } then &amp; catch &amp; finally：上个例子中我们还涉及到Promise对象上的两个方法 then，catch，实际上还有很多，一一理解 pro.then ( onResolve, onReject )接收两个回调函数作为参数， 回调函数 onResolve：处理状态为 fulfilled 的 Promise 实例。 回调函数 onReject：处理状态为 rejected 的 Promise 实例 (可选) 。 onReject &amp; onResolve 都可以接收 1 个参数，参数值为调用该方法的 Promise 实例的值： 12345678910let pro1 = Promise.resolve('Fulfilled');pro1.then(value =&gt; { console.log('pro1', value); // pro1 Fulfilled});let pro2 = Promise.reject('Rejected');pro2.then(null, reason =&gt; { console.log('pro2', reason); // pro2 Rejected}); 像平时我们自己用的时候一般用的比较多的时第一个参数，去处理成功的（fulfilled）的Promise实例我们也可以像上面那样去处理失败的Promise实例onResolve &amp; onReject 会返回一个新的 Promise 实例，这是实际上就是为什么then可以进行链式调用： 1234567891011121314let pro = Promise.resolve('Fulfilled');console.log('pro', pro); // proThen Promise {&lt;pending&gt;}let proThen = pro.then(value =&gt; { console.log('value', value); return Promise.resolve('proThen代码执行完了')});console.log('proThen', proThen); // proThen Promise {&lt;pending&gt;}proThen.then(res=&gt;{ console.log('res', res); // value Fulfilled console.log('proThen', proThen); // proThen Promise {&lt;fulfilled&gt;}}) 我们看一下两此打印 prothen对象的结果 再让我们来看一个例子 123456789101112131415161718const pro = Promise.resolve('pro');const then1 = pro.then(val1 =&gt; { console.log('val1', val1); // val1 pro return Promise.resolve('then1Resolve');});setTimeout(() =&gt; { console.log('then1', then1); // then1 Promise {&lt;fulfilled&gt;: 'then1Resolve'}}, 0);const then2 = pro.then(val2 =&gt; { console.log('val2', val2); // val2 pro return Promise.reject('then2Reject');});setTimeout(() =&gt; { console.log('then2', then2); // then2 Promise {&lt;rejected&gt;: 'then2Reject'}}, 0); 上例的输出顺序为：val1 pro - val2 pro - then1 Promise {: ‘then1Resolve’} - then2 Promise {: ‘then2Reject’}（这里是和js的事件循环机制息息相关的，这个例子中pro.then属于微任务，setTimeout是宏任务，都是异步任务，宏任务和微任务的执行顺序：总方针是先同步再异步，异步中先微任务，在宏任务） 如果 return 的数据不是 Promise 实例，会自动创建 fulfilled 状态的 Promise 实例，并将 return 的数据设置为 Promise 实例的值如果没有 return 语句，则该 Promise 实例的值为 undefined： 1234567891011121314151617const pro = Promise.resolve('proFulfilled');const then1 = pro.then(value =&gt; { console.log('value', value); // value proFulfilled return 'superman';});setTimeout(() =&gt; { console.log('then1', then1); // then1 Promise {&lt;rejected&gt;: 'superman'}}, 0);const then2 = pro.then(value =&gt; { console.log('value', value); // value proFulfilled});setTimeout(() =&gt; { console.log('then2', then2); // then2 Promise {&lt;fulfilled&gt;: undefined}}, 0); 1234567891011121314151617181920212223242526272829303132333435363738export default class QuickSort extends Sort { sort(originalArray) { const array = [...originalArray]; if (array.length &lt;= 1) { return array; } // Init left and right arrays. const leftArray = []; const rightArray = []; // Take the first element of array as a pivot. const pivotElement = array.shift(); const centerArray = [pivotElement]; // Split all array elements between left, center and right arrays. while (array.length) { const currentElement = array.shift(); // Call visiting callback. this.callbacks.visitingCallback(currentElement); if (this.comparator.equal(currentElement, pivotElement)) { centerArray.push(currentElement); } else if (this.comparator.lessThan(currentElement, pivotElement)) { leftArray.push(currentElement); } else { rightArray.push(currentElement); } } // Sort left and right arrays. const leftArraySorted = this.sort(leftArray); const rightArraySorted = this.sort(rightArray); return leftArraySorted.concat(centerArray, rightArraySorted); }} pro.catch ( onReject )catch(onReject) 是 then(null, onRejected) 的语法糖： 123456789const pro = new Promise((_, reject) =&gt; reject('error'));const proCatch = pro.catch(reason =&gt; { console.log('reason', reason); // reason error});setTimeout(() =&gt; { console.log('proCatch', proCatch); // proCatch Promise {&lt;fulfilled&gt;: undefined}}, 0); pro.finally ( callback ) 状态为 fulfilled 和 rejected 的 Promise 实例都会被 finally 的回调函数处理 但是 pending 状态的 Promise 实例不会被 finally 的回调函数处理 finally 的回调函数不接收参数 123456789const pro1 = Promise.resolve();pro1.finally(_ =&gt; console.log('pro1 resolve')); // pro1 resolveconst pro2 = Promise.reject();pro2.finally(_ =&gt; console.log('pro2 reject')); // pro2 rejectconst pro3 = new Promise(() =&gt; {});pro3.finally(_ =&gt; console.log('pro3 pending')); finally 方法默认返回新的 Promise 实例，新的 Promise 实例的 [状态] 和 [值] 与调用 finally 的 Promise 实例一致 即使显式重写了新的 return 语句，该 return 语句也不会生效 12345678910111213const pro = Promise.resolve('pro');console.log('pro', pro); // pro Promise {&lt;fulfilled&gt;: 'pro'}const fin = pro.finally(_ =&gt; { console.log('finally'); // finally return Promise.resolve('finally'); // return 语句无效});setTimeout(() =&gt; { console.log('fin', fin); // fin Promise {&lt;fulfilled&gt;: 'pro'} console.log(fin === pro); // false}, 0); 重要必掌握知识点 链式调用 因为 then / catch / finally 返回的还是一个 Promise 实例，所以可以链式调用 123456789const pro = Promise.resolve('first');pro.then(val1 =&gt; { console.log('val1', val1); // val1 first return 'second';}) .then(val2 =&gt; console.log('val2', val2)) // val2 second .then(val3 =&gt; console.log('val3', val3)); // val3 undefined 上例中，第 1 个 then 返回了 “second”，所以 val2 为 second；第 2 个 then 没有返回值，所以 val3 为 undefined 123456789const pro = Promise.reject('first');pro.then(val1 =&gt; { console.log('val1', val1); return 'second';}) .catch(reason =&gt; console.log('reason', reason)) // reason first .then(val2 =&gt; console.log('val2', val2)); // val2 undefined 上例中，因为 pro 的状态是 rejected，所以跳过第一个 then 方法，直接到 catch 方法执行；因为 catch 方法没有 return 语句，所以 val2 为 undefined 在链式调用中，没有按照规则传入回调函数的 then、catch、finally 方法，都会被直接跳过： 1234567891011const p1 = Promise.resolve('p1');p1.then(res1 =&gt; console.log('res1', res1)) // res1 p1 .then(res2 =&gt; { console.log('res2', res2); // res2 undefined return 'string'; }) .then() .then('我是字符串') // 这里有两个没写回调函数的 then 方法, 会被直接跳过 .then(res3 =&gt; console.log('res3', res3)); // res3 string —— 这里 res3 接收的是前面的合法返回值 Promise 异常穿透使用 Promise 的链式调用时，可以在最后设置 catch 方法，并指定失败的回调函数这样，前面任何操作出现异常，都会传到最后的 catch 中，执行其回调函数，这是我们写业务代码最常用的操作 123456789101112const pro = Promise.resolve('pro');pro.then(val1 =&gt; { console.log('val1', val1); // val1 pro return Promise.reject('reject');}) .then(val2 =&gt; { console.log('val2', val2); return &quot;then2' return&quot;; }) .catch(reason =&gt; console.log('reason', reason)); // reason reject 上例中，因为第一个 then 方法返回的是 rejected 状态的 Promise 实例，所以不会走后面的 then 方法这样，就直接跳到了最后的 catch 方法中 123456789const pro = Promise.resolve('ok');pro.then(val1 =&gt; { console.log('val1', val1); // val1 ok throw 'error';}) .then(val2 =&gt; console.log('val2', val2)) .catch(reason =&gt; console.log('reason', reason)); // reason error 上例中，因为第 1 个 then 方法抛出了错误，所以不会执行第二个 then 方法，直接跳到了最后的 catch 方法 中断 Promise 链 中断 Promise 链，就是说在使用 then 的链式调用时，在中间断开，不再执行后面的回调函数 办法：在回调函数中，返回一个 pendding 状态的 Promise 对象(巧妙) 123456789const pro = Promise.resolve('ok');pro.then(val1 =&gt; { console.log('val1', val1); // val1 ok return new Promise(() =&gt; {});}) .then(val2 =&gt; console.log('val2', val2)) .catch(reason =&gt; console.log('reason', reason)); 上述代码中，因为第 1 个 then 返回 pendding 状态的 Promise 对象，所以 Promise 链没有继续往下执行 resolve &amp; reject Promise.resolve ( value ) Promise构造函数上的静态方法，用于创建 fulfilled 状态的 Promise 实例 参数 value 为 Promise 实例的值；不传参数的话， Promise 实例的值为 undefiend 123456const pro1 = Promise.resolve(123);console.log('pro1', pro1); // pro1 Promise {&lt;fulfilled&gt;: 123}const pro2 = Promise.resolve();console.log('pro2', pro2); // pro2 Promise {&lt;fulfilled&gt;: undefined} 如果参数 value 是 Promise 实例，则直接返回该实例 12345const pro1 = new Promise(resolve =&gt; resolve('resolve'));const pro2 = Promise.resolve(pro1);console.log(pro2); // Promise {&lt;fulfilled&gt;: 'resolve'}console.log(pro1 === pro2); // true Promise.reject ( reason ) 用于创建 rejected 状态的 Promise 实例 参数 reason 为 Promise 实例的值；不传参的话，Promise 实例的值为 undefiend 123456const pro1 = Promise.reject('reason');console.log('pro1', pro1); // pro1 Promise {&lt;rejected&gt;: 'reason'}const pro2 = Promise.reject();console.log('pro2', pro2); // pro2 Promise {&lt;rejected&gt;: undefined} 与 Promise.resolve(value) 不同的是：即使参数 reason 是 Promise 实例，也会成为新创建的 Promise 实例的值 1234const pro1 = new Promise(resolve =&gt; resolve('pro'));const pro2 = Promise.reject(pro1);console.log('pro2', pro2); // pro2 Promise {&lt;rejected&gt;: Promise} all &amp; race &amp; allSettled &amp; any Promise.all ( promiseArr ) Promise.all(promiseArr) 接收一个 Promise 对象数组作为参数 该方法返回一个新的 Promise 对象 当所有的 Promise 都 fulfilled 后，按照传入的 Promise 数组的顺序 将每个 Promise 对象的 resolve 值存储在一个新的数组中，并将该数组作为 Promise.all 方法返回的 Promise 对象的 resolve 值结果 1234567891011121314151617181920const p1 = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('resolve p1'); }, 500);});const p2 = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('resolve p2'); }, 1000);});const p3 = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('resolve p3'); }, 1500);});Promise.all([p1, p3, p2]).then(res =&gt; { console.log('res', res); // res ['resolve p1', 'resolve p2', 'resolve p3'] ( 1.5s 后输出 )}); 只要有一个 Promise 被 rejected，就会立即返回一个 rejected 的 Promise 对象(巧妙)，其中包含第一个被 rejected 的 Promise 对象的错误信息(有点像数组的some方法) 1234567891011121314151617181920const p1 = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('resolve p1'); }, 1000);});const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('reject p2'); }, 2000);});const p3 = new Promise(resolve =&gt; { setTimeout(() =&gt; { reject('reject p3'); }, 10000);});Promise.all([p1, p3, p2]).catch(err =&gt; { console.log('err', err); // err reject p2 ( 2s 后输出 )}); Promise.any ( promiseArr ) Promise.any(promiseArr) 接收一个 Promise 对象数组作为参数 该方法返回一个新的 Promise 对象 如果传入的 Promise 数组中至少有一个 Promise 对象变为 resolve 状态，则 Promise.any 的返回值会变成一个 Fulfill 状态的 Promise 对象，并且这个对象的值会等于最先变为 resolve 状态的 Promise 对象的 resolve 值 12345678910const p1 = Promise.reject('reject p1');const p2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve('resolve p2'), 1000));const p3 = Promise.resolve('resolve p3');Promise.any([p1, p2, p3]) .then(value =&gt; console.log(value)) // resolve p3 .catch(error =&gt; console.error(error)); 如果传入的 Promise 数组中所有的 Promise 对象都变为 reject 状态，则 Promise.any 的返回值会变成一个 Reject 状态的 Promise 对象，并抛出一个 AggregateError 错误，其中包含了所有 reject 的原因信息 12345678910const p1 = Promise.reject('reject p1');const p2 = new Promise((_, reject) =&gt; setTimeout(() =&gt; reject('reject p2'), 1000));const p3 = Promise.reject('reject p3');Promise.any([p1, p2, p3]) .then(value =&gt; console.log(value)) .catch(error =&gt; console.error(error)); // AggregateError: All promises were rejected Promise.allSettled ( promiseArr ) Promise.all(promiseArr) 接收一个 Promise 对象数组作为参数 在所有 Promise 对象都 settle 后返回一个新的 Promise 对象，该对象的 Fulfill 状态的值是一个数组，包含每个 Promise 对象的 settle 状态信息（即不管 resolve 还是 reject 都会被处理） 注意：若有错误抛出，则抛出错误信息，并终止函数 12345678910111213141516171819202122232425const p1 = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('resolve p1'); }, 1000);});const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('reject p2'); }, 2000);});const p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('reject p3'); }, 3000);});const pas = Promise.allSettled([p1, p2, p3]).then(valArr =&gt; { valArr.forEach((item, index) =&gt; { console.log(`item ${index + 1}: `, item); // item 1: {status: 'fulfilled', value: 'resolve p1'} // item 2: {status: 'rejected', reason: 'reject p2'} // item 3: {status: 'rejected', reason: 'reject p3'} });}); Promise.race ( promiseArr ) Promise.race(promiseArr) 接收一个 Promise 对象数组作为参数 该方法返回一个新的 Promise 对象，在 promiseArr 包含的 Promise 对象中有一个对象 settled ( 已解决，即已经 fulfilled / rejected ) 时立即 resolve / reject 注意：抛出异常的 Promise 实例不会被 Promise.race 处理 1234567891011121314151617181920const p1 = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('resolve p1'); }, 500);});const p2 = new Promise((_, reject) =&gt; { setTimeout(() =&gt; { reject('reject p2'); }, 1000);});const p3 = new Promise(() =&gt; { setTimeout(() =&gt; { throw 'error p3'; // 抛出异常, 不会被处理 }, 0);});Promise.race([p1, p2, p3]) .then(value =&gt; console.log('value', value)) // value resolve p1 .catch(reason =&gt; console.log('reason', reason)); 可以使用 Promise.race 来实现一个超时控制，如果某个异步操作在指定时间内没有完成，就抛出超时异常： 1234567891011121314151617181920212223242526272829function timeoutPromise(promise, timeout) { // 返回一个新的 Promise 对象 return Promise.race([ promise, // 原始的 Promise 对象 new Promise((_, reject) =&gt; { // 将给定的时间转换为毫秒单位 setTimeout(() =&gt; { reject(new Error('Operation timed out')); }, timeout); }), ]);}const timeout = 5000; // 设置超时时间为 5 秒钟const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('Operation completed successfully'); }, 3000);});// 调用 timeoutPromise 函数测试timeoutPromise(promise, timeout) .then(result =&gt; { console.log(result); // 打印输出 &quot;Operation completed successfully&quot; }) .catch(error =&gt; { console.error(error); // 打印输出 &quot;Error: Operation timed out&quot; }); 上例中，setTimeout 函数模拟了一个需要等待 3 秒钟才能完成的异步操作。我们设置了超时时间为 5 秒钟，所以 Promise.race 方法会在 3 秒钟后返回原始的 Promise 对象的结果。如果在 5 秒钟内未完成该操作，则会抛出超时错误 Async/Awaitasync和await是建立在Promise之上的高级抽象，使得异步代码的编写和阅读更加接近于同步代码的风格。 Async 函数通过在函数声明前加上async关键字，可以将任何函数转换为返回Promise的异步函数。这意味着你可以使用.then()和.catch()来处理它们的结果。 123456async function asyncFunction() { return &quot;异步操作完成&quot;;}asyncFunction().then(value =&gt; console.log(value)); // 输出：异步操作完成 Await关键字await关键字只能在async函数内部使用。它可以暂停async函数的执行，等待Promise的解决（resolve），然后以Promise的值继续执行函数。(这里有一个和事件循环相关的知识点：await后面的表达式是同步执行的，await下面的代码会进入为任务队列等待执行) 1234567891011async function asyncFunction() { let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(&quot;完成&quot;), 1000) }); let result = await promise; // 等待，直到promise解决 (resolve) console.log(result); // &quot;完成&quot;}asyncFunction(); 在实际应用中，async和await使得处理复杂的异步逻辑更加简单，尤其是在涉及多个依次执行的异步操作时。 前几年的版本时，浏览器执行过程中await 会阻塞后续代码，将后续的代码放入微任务队列中，但是现在的浏览器执行代码时会给紧跟在await关键字后的代码开小灶，相当于紧随在await关键字后的代码变成同步代码，但是再往后的代码依旧会被推入微任务队列。 错误处理在async/await中，错误处理可以通过传统的try…catch语句实现，这使得异步代码的错误处理更加直观。 123456789101112async function asyncFunction() { try { let response = await fetch('http://example.com'); let data = await response.json(); // 处理数据 } catch (error) { console.log('捕获到错误：', error); }}asyncFunction(); 之前就遇到过一个很奇葩的业务场景，是属于数据库数据遗留问题，后端没对数据进行过数据清理，导致一些时JS字符串，在JSON转的时候会报错 就在catch里面去处理正确的逻辑 Promise与Async/Await的比较虽然async/await在很多情况下可以提供更清晰和简洁的代码，但Promise也有其独特的优势。例如，处理多个并行异步操作时，Promise.all()通常是更好的选择。选择使用Promise或async/await通常取决于具体的应用场景和个人偏好。","link":"/2022/05/25/Promise/"},{"title":"vue3快速diff算法和vue2双端diff算法","text":"认识虚拟 DOM因为 Diff 算法的工作就是为了计算虚拟dom的差异，并将差异应用到真实DOM上，以实现高效的更新。Diff算法主要包括三个步骤：树的遍历、节点的比较和差异的应用。 在树的遍历过程中，Diff算法会递归地遍历虚拟DOM树和真实DOM树，并比较它们的节点。这个过程是从根节点开始，逐层向下遍历，通过比较节点的标签、属性、子节点等信息，来确定是否有差异存在。 节点的比较是Diff算法的核心部分，它会对虚拟DOM和真实DOM的节点进行详细的比较。在比较过程中，会考虑节点的类型、标签、属性等方面的差异，并将这些差异记录下来。 差异的应用是将记录下来的差异应用到真实DOM上，以实现对DOM的更新。这个过程是通过操作真实DOM的API来实现的，比如添加、删除、修改节点等操作。 虚拟 DOM 简单说就是 用JS对象来模拟 DOM 结构怎么用 JS 对象模拟 DOM 结构的呢？ 123456&lt;template&gt; &lt;div id=&quot;app&quot; class=&quot;container&quot;&gt; &lt;h1&gt;沐华&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 上面的模板转在虚拟 DOM 就是下面这样的 12345678{ tag:'div', props:{ id:'app', class:'container' }, children: [ { tag: 'h1', children:'沐华' } ]} 这样的 DOM 结构就称之为 虚拟 DOM (Virtual Node)，简称 vnode。 tag：必选。就是标签。也可以是组件，或者函数 props：非必选。就是这个标签上的属性和方法 children：非必选。就是这个标签的内容或者子节点，如果是文本节点就是字符串，如果有子节点就是数组。换句话说 如果判断 children 是字符串的话，就表示一定是文本节点，这个节点肯定没有子元素 为什么要使用虚拟 DOM 呢？如图可以看出原生 DOM 有非常多的属性和事件，就算是创建一个空div也要付出不小的代价。 如果我们去全量更新那，性能可想而知， diff 算法和数据改变前的 DOM 对比，计算出需要更改的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图，这样就有很大的性能提升 Vue3快速diff算法 流程概述这里需要注意的一点是，vue在进行diff算法对比的时候，对有key的组件和没key的组件采用的是两个函数去分别处理 对比详解 patchChildren函数 当组件更新的时候会走到patchChildren函数，以下是patchChildren的函数的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const patchChildren: PatchChildrenFn = (...) =&gt; { // 取一哈新旧虚拟节点的子节点 const c1 = n1 &amp;&amp; n1.children const prevShapeFlag = n1 ? n1.shapeFlag : 0 const c2 = n2.children const { patchFlag, shapeFlag } = n2 if (patchFlag &gt; 0) { // patchFlag &gt; 0 就表示子节点含有动态属性，如：动态style、动态class、动态文案等 if (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) { // 子节点带 key patchKeyedChildren(...) return } else if (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) { // 子节点不带 key patchUnkeyedChildren(...) return } } // 子节点存在3种可能的情况：文本、数组、没有子节点 if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) { // 新虚拟节点的子节点是文本 if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { // 对应的旧虚拟节点的子节点是数组 // 卸载旧虚拟节点的数组子节点 unmountChildren(c1 as VNode[], parentComponent, parentSuspense) } // 再挂载新虚拟节点的文本子节点 if (c2 !== c1) { hostSetElementText(container, c2 as string) } } else { if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { // 旧虚拟节点的子节点是数组 if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { // 新虚拟节点的子节点也是数组，做全量diff patchKeyedChildren(...) } else { // 能走到这就说明新虚拟节点没有子节点，这里只需要卸载久虚拟节点的子节点 unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true) } } else { // 走到这就说明 // 旧虚拟节点的子节点要么是文本要么也没有子节点 // 新虚拟节点的子节点要么是数组要么就没有子节点 if (prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) { // 旧虚拟节点的子节点是文本，更新 hostSetElementText(container, '') } if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { // 新虚拟节点的子节点是数组，挂载 mountChildren(...) } } } } 从patchChildren函数的源码中我们可以知道，Vue3在比较新旧两组子节点的时候会采用以下两种方法处理： 如果新的子节点没有key属性，那么就会调用patchUnkeyedChildren函数来对新旧两组子节点进行Diff比较； 如果新的子节点没有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较； 这两种函数的对比是有区别的 patchUnkeyedChildren函数如果新的子节点没有key属性，那么就会调用patchUnkeyedChildren函数来对新旧两组子节点进行Diff比较。该函数的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 没有 key 标识的子节点的 patch 过程，即 diff 过程 const patchUnkeyedChildren = ( c1: VNode[], c2: VNodeArrayChildren, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =&gt; { // 旧子节点 c1 = c1 || EMPTY_ARR // 新子节点 c2 = c2 || EMPTY_ARR // 旧的一组子节点的长度 const oldLength = c1.length // 新的一组子节点的长度 const newLength = c2.length // 两组子节点的公共长度，即两者中较短的那一组子节点的长度 const commonLength = Math.min(oldLength, newLength) let i // 遍历commonLength，调用patch函数进行更新 for (i = 0; i &lt; commonLength; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) patch( c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } // 如果旧的一组子节点的长度大于新的一组子节点的长度，说明有旧的子节点需要卸载 if (oldLength &gt; newLength) { // remove old unmountChildren( c1, parentComponent, parentSuspense, true, false, commonLength ) } else { // 说明是有新子节点需要挂载 // mount new mountChildren( c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength ) } } 上面代码所示，处理步骤如下： 求新旧两组子节点各自的长度，然后求出两组子节点的公共长度commonLength； 遍历commonLength，调用patch函数进行更新； 公共长度内的子节点更新完毕，进行以下操作： 如果新的一组子节点的长度更长，说明新的子节点需要挂载，调用mountChildren函数进行挂载； 否则说明旧子节点需要卸载，调用unmount函数卸载旧节点； 这个函数的对比过程是十分简单的，比较关键的是下面的这个函数！ patchKeyedChildren函数 如果新的子节点有key属性，那么就会调用patchkeyedChildren函数来对新旧两组子节点进行Diff比较。 快速diff算法预处理步骤快速 Diff 算法包含预处理步骤，这其实是借鉴了纯文本 Diff 算法的思路。快速diff算法的预处理是分别处理新旧节点中的前置节点和后置节点。预处理达成的目的实际上就是把key相同的节点位置相同的节点找出来，这部分节点直接用patch进行更新，不参与后续循环 处理前置节点123456789101112131415161718192021222324252627282930313233343536let i = 0// 新的一组子节点的长度const l2 = c2.length// 旧子节点的尾部索引let e1 = c1.length - 1 // prev ending index// 新子节点的尾部索引let e2 = l2 - 1 // next ending index// 从头部开始同步，处理相同的同步节点// 1. sync from start// (a b) c// (a b) d ewhile (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[i] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) if (isSameVNodeType(n1, n2)) { // 相同的节点，递归执行patch更新节点 patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else { // 遇到了 key 不同的节点，那就直接退出循环，相同前置节点(a b)的更新处理完成 break } i++} 我们使用while循环查找所有相同的前置节点，并调用patch函数进行打补丁，直到遇到key值不同的节点为止。这样就完成了前置节点的更新。（很简单，就是在两组新旧节点定一个指针从头部开始移动遇到key值不同的节点为止停止移动） 处理后置节点1234567891011121314151617181920212223242526272829303132// 2. sync from end// a (b c)// d e (b c)while (i &lt;= e1 &amp;&amp; i &lt;= e2) { // 旧的后置节点 const n1 = c1[e1] // 新的后置节点 const n2 = (c2[e2] = optimized ? cloneIfMounted(c2[e2] as VNode) : normalizeVNode(c2[e2])) // 新旧后置节点相同，调用 patch 函数打补丁 if (isSameVNodeType(n1, n2)) { patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else { // 遇到了 key 不同的节点，退出循环，相同后置节(b c)点的更新处理完成 break } // 新旧后置节点索引递减，即从后往前遍历两组子节点 e1-- e2--} 与处理前置节点一样，在while循环内，需要调用patch函数进行打补丁，然后递减两个索引e1、e2，直到遇到类型不同且key值不同的节点为止，这样就完成了后置节点的更新。 处理新增节点当前置节点和后置节点处理完毕后，旧的一组子节点已经全部被处理了，但是在新的一组子节点中，还遗留了一个未被处理的节点p-4，这个节点是新增的节点。怎么判断出p-4是一个新增的节点的呢？ 我们可以根据索引i、e1、e2之间的关系： 条件一：e1 &lt; i：说明在预处理过程中，所有的旧节点都处理完毕了，因为旧子节点指针e1 处理完毕后在 i 的前面； 条件二：e2 ≥ i：说明在预处理过程中，在新的一组子节点中，仍然有未被处理的节点，因为新节点的指针e2还在i指针的后面，而这些遗留的节点江北视为新增节点。 如果条件一和条件二同时成立，说明在新的一组子节点中，存在遗留节点，且这些节点都是新增节点。因此，我们需要将它们挂载到正确的位置 1234567891011121314151617181920212223242526272829303132333435// 3. common sequence + mount// (a b)// (a b) c// i = 2, e1 = 1, e2 = 2// (a b)// c (a b)// i = 0, e1 = -1, e2 = 0// i &gt; e1 说明在预处理的过程中，所有的旧子节点处理完毕额if (i &gt; e1) { // i &lt;= e2 说明在预处理过后，在新的一组子节点中，仍然有未被处理的节点，这些遗留的节点将被视作新增节点 if (i &lt;= e2) { // 锚点的索引 const nextPos = e2 + 1 // 锚点元素 const anchor = nextPos &lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor // 采用 while 循环，调用 patch 函数逐个挂载新增节点 while (i &lt;= e2) { patch( null, (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) i++ } }} 在这段代码中： 计算锚点的索引值（nextPos）为e2 + 1; 如果小于新的一组子节点的数量，则说明锚点元素在新的一组子节点中，直接使用(c2[nextPos] as VNode).el，否则说明索引c2对应的节点已经是尾部节点了，这时锚点元素是parentAnchor； 找到锚点元素后，使用一个while循环，将i和e2之间的节点作为新节点挂载； 像这样 找到 新节点数组中的 e2 - i之间的所有节点，当作新节点进行挂载 处理删除节点 当相同的前置节点和后置节点全部被处理完毕后，新的一组子节点已经全部被处理完毕，而就得一组子节点中遗留了一个节点p-2，实际上，遗留的节点可能有多个，如下图所示： 1234567891011121314// 4. common sequence + unmount// (a b) c// (a b)// i = 2, e1 = 2, e2 = 1// a (b c)// (b c)// i = 0, e1 = 0, e2 = -1else if (i &gt; e2) { while (i &lt;= e1) { unmount(c1[i], parentComponent, parentSuspense, true) i++ }} 在上面的源码中，当满足i &gt; e2 &amp;&amp; i ≤ e1时，则开启一个while循环，并调用unmount函数将i到e1之间的节点全部删除。 到这里，基于理想情况下，处理完前置节点和后置节点后，新旧两组子节点总有一组的子节点全部被处理完毕。所有的操作只需要简单地更新、挂载、卸载节点即可。判断新子节点便利完的情况，并且旧子节点有遗漏的情况的条件 条件一： i &lt;=e1：说明在预处理过程中，旧子节点有遗漏没遍历完全 条件二：i &gt; e2：说明在预处理过程中，新子节点已经遍历完 注意：现在预处理过程中的新增节点和删除节点是举的最理想状况的例子，还有个别极端情况，比如，预处理结束后，新旧节点剩下的数量一样，其中新节点有新增元素，有旧节点中存在，新节点中不存在的已经被删除的元素，也有新旧节点都存在的元素但是顺序不一样的元素，接下来的处理方式才是重中之重！ 非理想情况下的未处理节点上面的例子都比较理想化，当完成前置和后置节点的处理后，新旧两组子节点总会有一组子节点全部被处理完毕，但有的情况比较复杂。下面我们给出非理想情况下的例子，经过上面的前置和后置处理后，新子节点和旧子节点都有未被处理的节点，如下图所示：在这种非理想情况下，索引i、e1、e2不满足下面两个条件中的任何一个： i &gt; e1 &amp;&amp; i &lt; e2(新增节点的情况) i &gt; e2 &amp;&amp; i &lt; e1(卸载旧节点的情况) 怎么来处理这种情况呢？这里的内容是vue算法的重大更新，也是性能优化的一个点！ 第1步：构建索引表keyToNewIndexMap给新子节点构建一张索引表keyToNewIndexMap，目的是用来存储节点key和在新子节点位置的索引，可以在O(n)时间复杂度下获取到旧节点，提高查找性能 1234567891011121314151617181920212223// 预处理完后，未处理节点的第一个未处理节点的索引位置const s1 = i // prev starting indexconst s2 = i // next starting index// 构建新的一组子节点中未处理的key和索引位置的映射，是为了解决性能问题// 5.1 build key:index map for newChildrenconst keyToNewIndexMap: Map&lt;string | number | symbol, number&gt; = new Map()for (i = s2; i &lt;= e2; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) if (nextChild.key != null) { if (__DEV__ &amp;&amp; keyToNewIndexMap.has(nextChild.key)) { warn( `Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.` ) } // 将新节点的key和索引位置添加到map集合中 keyToNewIndexMap.set(nextChild.key, i) }} 现在我们得到了keyToNewIndexMap索引表 第2步：构建newIndexToOldIndexMap数组为了在后面快速找到需要移动的节点，需要构建newIndexToOldIndexMap数组，它的长度等于经过预处理后未处理的新子点数量，并且初始值都是0。其源码如下： 12345678910111213141516171819let j// 代表更新过节点数量let patched = 0// 新的一组节点中剩余未处理节点的数量const toBePatched = e2 - s2 + 1// 标识节点是否需要移动节点let moved = false// 代表遍历旧的一组子节点的过程中遇到的最大索引值// used to track whether any node has movedlet maxNewIndexSoFar = 0// 构建一个索引映射数组，存储新的一组子节点在旧的一组子节点的位置索引（存储的是新的一组子节点中的节点在旧的一组子节点中的位置索引）// works as Map&lt;newIndex, oldIndex&gt;// Note that oldIndex is offset by +1// and oldIndex = 0 is a special value indicating the new node has// no corresponding old node.// used for determining longest stable subsequenceconst newIndexToOldIndexMap = new Array(toBePatched)for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0 第3步：填充newIndexToOldIndexMap数组填充的目的是将newIndexToOldIndexMap数组中的元素存储的是新的一组子节点中的节点在旧的一组子节点中的位置索引。如果旧的一组子节点中没有新的一组的子节点元素那么将新的子节点元素的索引值设为 -1 （其实这段代码，我并没有找到对应的源码进行正式，但是这种情况一定是给了一个比较特殊的值，反正有待自己考证） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 遍历旧的一组子节点中剩余未处理的节点for (i = s1; i &lt;= e1; i++) { // 旧数组中剩余未处理的节点 const prevChild = c1[i] // 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点 if (patched &gt;= toBePatched) { // all new children have been patched so this can only be a removal unmount(prevChild, parentComponent, parentSuspense, true) continue } // 新的一组子节点中未被处理节点在新子节点中的位置索引 let newIndex if (prevChild.key != null) { // 从索引表中获取与旧节点具有相同key的新节点在新的一组子节点中的位置索引 newIndex = keyToNewIndexMap.get(prevChild.key) } else { // 旧子节点没有 key ，那么尝试在新的一组子节点中查找具有相同类型的没有key的新子节点 // key-less node, try to locate a key-less node of the same type for (j = s2; j &lt;= e2; j++) { if ( newIndexToOldIndexMap[j - s2] === 0 &amp;&amp; isSameVNodeType(prevChild, c2[j] as VNode) ) { newIndex = j break } } } // 如果在新的一组子节点中没有找到与旧的一组子节点中具有相同key 或相同类型的子节点， // 说明该旧子节点在新的一组子节点中已经不存在了，需要将其卸载 if (newIndex === undefined) { unmount(prevChild, parentComponent, parentSuspense, true) } else { // 填充 索引映射数组 newIndexToOldIndexMap[newIndex - s2] = i + 1 // 通过比较 newIndex 和 maxNewIndexSoFar 的值来判断节点是否需要移动 if (newIndex &gt;= maxNewIndexSoFar) { // 如果在遍历过程中遇到的索引值呈现递增趋势，则说明不需要移动节点 maxNewIndexSoFar = newIndex } else { // 否则需要移动 moved = true } // 调用patch函数完成更新 patch( prevChild, c2[newIndex] as VNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) // 每更新一个节点，都将patched变量+1 patched++ }} 上面的源码解析如下： 使用for循环遍历旧子节点，在遍历过程如果发现已经更新的节点数量patched大于需要更新的节点数量toBePatched，则调用unmount将剩余的旧节点全部卸载掉； 拿旧节点的key值去索引表keyToNewIndexMap去查找该节点在新节点中的位置newIndex; 如果newIndex不存在，则说明该节点在新节点已经不存在，则调用unmount函数卸载它； 如果newIndex存在，则说明该节点在新节点中存在，则调用patch函数更新打补丁，并填充newIndexToOldIndexMap数组；(注意：现在的newIndexToOldIndexMap中的索引值是未处理的新节点在全部旧子节点中的索引位置，p3在旧子节点中的索引是2) 在这段代码中， 增加了两个变量moved和maxNewIndexSoFar变量，其中，moved的初始值是false，代表是否需要移动节点，maxNewIndexSoFar初始值为0，代表遍历旧节点过程中遇到的最大索引值。如果在遍历过程中遇到的索引值呈递增趋势，则不需要移动节点，否则就需要移动节点。 第4步：判断节点是否需要移动计算最长递增序列 1234const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) // [0, 1] : EMPTY_ARR getSequence函数返回的是最长递增序列中的元素在newIndexToOldIndexMap数组的位置索引。重新编号本步骤忽略掉经过预处理的前置节点和后置节点，对新旧未处理的节点索引值进行重新编号。重置索引i,j的指向，辅助节点移动索引j指向最长递增序列中最后一个节点的位置，索引i指向新子节点最后一个位置。然后开启一个for循环，让索引i、j按照箭头的方向移动，见第5步。 newIndexToOldIndexMap[i]的值为0：挂载节点如果newIndexToOldIndexMap[i]的值为0，则说明索引为i的节点是全新的节点，使用patch函数将其挂载到容器中。(这里就是处理的新增节点，反正在newIndexToOldIndexMap数组里面是具有特殊标识的) 123456789101112131415if (newIndexToOldIndexMap[i] === 0) { // mount new patch( null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized )} i ≠ seq[j]时，移动节点当索引i和索引j指向的子序列元素时，该节点对应的真实DOM需要移动。 123456if (j &lt; 0 || i !== increasingNewIndexSequence[j]) { // 当指向新的一组子节点的元素索引 i 不等于索引 j指向的子序列的元素时， // 该节点对应的真实DOM元素需要移动 move(nextChild, container, anchor, MoveType.REORDER)} 如上图所示，此时索引 i 的值为 2 ，索引 j 的值为 1 ，因此 2 !== seq[1] 成立，因此，节点 p-2 对应的真实节点需要移动。 i == seq[j]时，无需移动节点当i == seq[j]时，说明该位置的节点不需要移动，此时只需要让索引 j 按照图中箭头方向移动即可，即让变量 j 递减，进入下一次的循环比较。i == seq[j]时，同时代表着索引i对应的新的节点在旧子节点中的相对位置是正确的，不需要进行移动如上图所示，此时索引 i 的值为 1 ，索引 j 的值也为 1 ，因此 1 === seq[1] 成立，节点 p-4 对应的真实节点不需要移动，只需要让变量 j 递减即可。移动挂载节点操作的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839// looping backwards so that we can use last patched node as anchorfor (i = toBePatched - 1; i &gt;= 0; i--) { const nextIndex = s2 + i // 新子节点 const nextChild = c2[nextIndex] as VNode // 锚点 const anchor = nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor if (newIndexToOldIndexMap[i] === 0) { // mount new patch( null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else if (moved) { // 这里是需要移动节点的情况 // i 指向的是新的一组子节点中元素的位置索引 // j 指向的是最长递增序列中元素的位置索引 // move if: // There is no stable subsequence (e.g. a reverse) // OR current node is not among the stable sequence if (j &lt; 0 || i !== increasingNewIndexSequence[j]) { // 当指向新的一组子节点的元素索引 i 不等于索引 j指向的子序列的元素时， // 该节点对应的真实DOM元素需要移动 move(nextChild, container, anchor, MoveType.REORDER) } else { // 当i === seq[j]时，说明该位置的节点不需要移动，即让索引j递减 j-- } }} Vue2双端diff算法 patch()Diff 算法，在 Vue2 里面就是 patch，其实 patch 就是一个函数，我们先介绍一下源码里的核心流程，再来看一下 patch 的源码，源码里每一行也有注释它可以接收四个参数，主要还是前两个 oldVnode：老的虚拟 DOM 节点 vnode：新的虚拟 DOM 节点 hydrating：是不是要和真实 DOM 混合，服务端渲染的话会用到，这里不过多说明 removeOnly：transition-group 会用到，这里不过多说明 主要流程是这样的： vnode 不存在，oldVnode 存在，就删掉 oldVnode vnode 存在，oldVnode 不存在，就创建 vnode 两个都存在的话，通过 sameVnode 函数(后面有详解)对比是不是同一节点 如果是同一节点的话，通过 patchVnode 进行后续对比节点文本变化或子节点变化 如果不是同一节点，就把 vnode 挂载到 oldVnode 的父元素下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// 两个判断函数function isUndef (v: any): boolean %checks { return v === undefined || v === null}function isDef (v: any): boolean %checks { return v !== undefined &amp;&amp; v !== null}return function patch (oldVnode, vnode, hydrating, removeOnly) { // 如果新的 vnode 不存在，但是 oldVnode 存在 if (isUndef(vnode)) { // 如果 oldVnode 存在，调用 oldVnode 的组件卸载钩子 destroy if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false const insertedVnodeQueue = [] // 如果 oldVnode 不存在的话，新的 vnode 是肯定存在的，比如首次渲染的时候 if (isUndef(oldVnode)) { isInitialPatch = true // 就创建新的 vnode createElm(vnode, insertedVnodeQueue) } else { // 剩下的都是新的 vnode 和 oldVnode 都存在的话 // 是不是元素节点 const isRealElement = isDef(oldVnode.nodeType) // 是元素节点 &amp;&amp; 通过 sameVnode 对比是不是同一个节点 (函数后面有详解) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // 如果是 就用 patchVnode 进行后续对比 (函数后面有详解) patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) } else { // 如果不是同一元素节点的话 if (isRealElement) { // const SSR_ATTR = 'data-server-rendered' // 如果是元素节点 并且有 'data-server-rendered' 这个属性 if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { // 就是服务端渲染的，删掉这个属性 oldVnode.removeAttribute(SSR_ATTR) hydrating = true } // 这个判断里是服务端渲染的处理逻辑，就是混合 if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } else if (process.env.NODE_ENV !== 'production') { warn('这是一段很长的警告信息') } } // function emptyNodeAt (elm) { // return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm) // } // 如果不是服务端渲染的，或者混合失败，就创建一个空的注释节点替换 oldVnode oldVnode = emptyNodeAt(oldVnode) } // 拿到 oldVnode 的父节点 const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // 根据新的 vnode 创建一个 DOM 节点，挂载到父节点上 createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // 如果新的 vnode 的根节点存在，就是说根节点被修改了，就需要遍历更新父节点 if (isDef(vnode.parent)) { let ancestor = vnode.parent const patchable = isPatchable(vnode) // 递归更新父节点下的元素 while (ancestor) { // 卸载老根节点下的全部组件 for (let i = 0; i &lt; cbs.destroy.length; ++i) { cbs.destroy[i](ancestor) } // 替换现有元素 ancestor.elm = vnode.elm if (patchable) { for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, ancestor) } const insert = ancestor.data.hook.insert if (insert.merged) { for (let i = 1; i &lt; insert.fns.length; i++) { insert.fns[i]() } } } else { registerRef(ancestor) } // 更新父节点 ancestor = ancestor.parent } } // 如果旧节点还存在，就删掉旧节点 if (isDef(parentElm)) { removeVnodes([oldVnode], 0, 0) } else if (isDef(oldVnode.tag)) { // 否则直接卸载 oldVnode invokeDestroyHook(oldVnode) } } } // 返回更新后的节点 invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm } sameVnode就是用来判断节点是否相同，通过标签和key判断 1234567891011121314151617function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; // key 是不是一样 a.asyncFactory === b.asyncFactory &amp;&amp; ( // 是不是异步组件 ( a.tag === b.tag &amp;&amp; // 标签是不是一样 a.isComment === b.isComment &amp;&amp; // 是不是注释节点 isDef(a.data) === isDef(b.data) &amp;&amp; // 内容数据是不是一样 sameInputType(a, b) // 判断 input 的 type 是不是一样 ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; // 判断区分异步组件的占位符否存在 isUndef(b.asyncFactory.error) ) ) )} patchVnode这个是在新的 vnode 和 oldVnode 是同一节点的情况下，才会执行的函数，主要是对比节点文本变化或子节点变化流程是这样的： 如果 oldVnode 和 vnode 的引用地址是一样的，就表示节点没有变化，直接返回 如果 oldVnode 的 isAsyncPlaceholder 存在，就跳过异步组件的检查，直接返回 如果 oldVnode 和 vnode 都是静态节点，并且有一样的 key，并且 vnode 是克隆节点或者 v-once 指令控制的节点时，把 oldVnode.elm 和 oldVnode.child 都复制到 vnode 上，然后返回 如果 vnode 不是文本节点也不是注释的情况下 如果 vnode 和 oldVnode 都有子节点，而且子节点不一样的话，就调用 updateChildren 更新子节点 如果只有 vnode 有子节点，就调用 addVnodes 创建子节点 如果只有 oldVnode 有子节点，就调用 removeVnodes 删除该子节点 如果 vnode 文本为 undefined，就删掉 vnode.elm 文本 如果 vnode 是文本节点但是和 oldVnode 文本内容不一样，就更新文本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function patchVnode ( oldVnode, // 老的虚拟 DOM 节点 vnode, // 新的虚拟 DOM 节点 insertedVnodeQueue, // 插入节点的队列 ownerArray, // 节点数组 index, // 当前节点的下标 removeOnly // 只有在) { // 新老节点引用地址是一样的，直接返回 // 比如 props 没有改变的时候，子组件就不做渲染，直接复用 if (oldVnode === vnode) return // 新的 vnode 真实的 DOM 元素 if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) { // clone reused vnode vnode = ownerArray[index] = cloneVNode(vnode) } const elm = vnode.elm = oldVnode.elm // 如果当前节点是注释或 v-if 的，或者是异步函数，就跳过检查异步组件 if (isTrue(oldVnode.isAsyncPlaceholder)) { if (isDef(vnode.asyncFactory.resolved)) { hydrate(oldVnode.elm, vnode, insertedVnodeQueue) } else { vnode.isAsyncPlaceholder = true } return } // 当前节点是静态节点的时候，key 也一样，或者有 v-once 的时候，就直接赋值返回 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) { vnode.componentInstance = oldVnode.componentInstance return } // hook 相关的不用管 let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) { i(oldVnode, vnode) } // 获取子元素列表 const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) { // 遍历调用 update 更新 oldVnode 所有属性，比如 class,style,attrs,domProps,events... // 这里的 update 钩子函数是 vnode 本身的钩子函数 for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) // 这里的 update 钩子函数是我们传过来的函数 if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) } // 如果新节点不是文本节点，也就是说有子节点 if (isUndef(vnode.text)) { // 如果新老节点都有子节点 if (isDef(oldCh) &amp;&amp; isDef(ch)) { // 如果新老节点的子节点不一样，就执行 updateChildren 函数，对比子节点 if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) } else if (isDef(ch)) { // 如果新节点有子节点的话，就是说老节点没有子节点 // 如果老节点文本节点，就是说没有子节点，就清空 if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') // 添加子节点 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) } else if (isDef(oldCh)) { // 如果新节点没有子节点，老节点有子节点，就删除 removeVnodes(oldCh, 0, oldCh.length - 1) } else if (isDef(oldVnode.text)) { // 如果老节点是文本节点，就清空 nodeOps.setTextContent(elm, '') } } else if (oldVnode.text !== vnode.text) { // 新老节点都是文本节点，且文本不一样，就更新文本 nodeOps.setTextContent(elm, vnode.text) } if (isDef(data)) { // 执行 postpatch 钩子 if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) }} updateChildren这个是新的 vnode 和 oldVnode 都有子节点，且子节点不一样的时候进行对比子节点的函数这里很关键，很关键！应该是vue2diff算法的核心在新老两组VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢，当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。先进行以下4种情况的优化策略： 老数组的开始与新数组的开始：oldStartVnode, newStartVnode 老数组的结尾与新数组的结尾：oldEndVnode, newEndVnode 老数组的开始与新数组的结尾：oldStartVnode, newEndVnode 老数组的结尾与新数组的开始：oldEndVnode, newStartVnode 老数组的开始与新数组的开始 新数组的结尾节点有剩余则添加从左往右比对完，老数组的游标先相交了，发现新数组结尾还有节点没有比对，则在新数组结尾创建剩下没有比对的节点。 老数组的结尾节点有剩余则删除从左往右比对完，新数组的游标先相交了，发现老数组结尾还有节点没有比对，则删除老数组剩下没有比对的节点。 老数组的结尾与新数组的结尾 新数组的开头节点有剩余则添加 老数组的开头节点有剩余则删除从右往左比对完，新数组的游标先相交了，发现老数组的开头还有节点没有比对，则删除老数组开头没有比对的节点。 老数组的开始与新数组的结尾如果老数组的开头节点与新数组的结尾节点比对成功了，除了会继续递归比对它们，还将真实节点 A 移动到结尾。 老数组的结尾与新数组的开始如果老数组的结尾节点与新数组的开始节点比对成功了，除了会继续递归比对它们，还将真实节点D移动到开头。 以上四种情况都没对比成功如果以上4种情况都没找到，则拿新数组的第一个节点去老数组中去查找。如果拿新数组的第一个节点去老数组中查找成功了，则会继续递归比对它们，同时将比对到的节点移动到对应的节点前面，并且将老数组原来的位置内容设置为 undefind。注：这里 只有找到了旧节点并且新旧节点一样才会将旧节点数组中 idxInOld 中的元素置为 undefined。 如果拿新数组的第一个节点去老数组中查找，没找到，则创建一个新的节点插入到未处理的节点前面。 经过上面的处理之后，根据判断条件也不难看出，遍历结束之后 新旧节点数组都刚好没有剩余元素 是很难出现的，当且仅当遍历过程中每次新头尾节点总能和旧头尾节点中总能有两个新旧节点相同时才会发生，只要有一个节点发生改变或者顺序发生大幅调整，最后 都会有一个节点数组起始索引和末尾索引无法闭合。那么此时就需要对剩余元素进行处理： 旧节点数组遍历结束、新节点数组仍有剩余，则遍历新节点数组剩余数据，分别创建节点并插入到旧末尾索引对应节点之前 新节点数组遍历结束、旧节点数组仍有剩余，则遍历旧节点数组剩余数据，分别从节点数组和 dom 树中移除 总结Vue 2 的 diff 算法相对于简单 diff 算法来说，通过 双端对比与生成索引 map 两种方式 减少了简单算法中的多次循环操作，新旧数组均只需要进行一次遍历即可将所有节点进行对比。其中双端对比会分别进行四次对比和移动，性能不算最优解，所以 Vue 3 中引入了 最长递增子序列 的方式来 替代双端对比，而其余部分则依然通过转为索引map 的形式利用空间扩展来减少时间复杂度，从而更高的提升计算性能。","link":"/2023/03/27/vue3%E5%BF%AB%E9%80%9Fdiff%E7%AE%97%E6%B3%95%E5%92%8Cvue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95/"},{"title":"在Flutter初始化项目的demo下初步认识一下页面结构","text":"我发现flutter的初始demo真的很经典，研究一下这个demo对初学者后续的学习觉得非常有帮助 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import 'package:flutter/material.dart';void main() { runApp(const MyApp());}class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: const MyHomePage(title: 'Flutter Demo Home Page1'), ); }}class MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ const Text( 'You have pushed the button this many times:', textDirection: TextDirection.ltr, style: TextStyle(color: Colors.amber), ), Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); }} 先看main函数 123void main() { runApp(const MyApp());} runApp顶级函数传入了 MyApp构造函数实例，这里没有用new关键字，是简写的形式，前面用了const关键字，在 Flutter 项目中，const 关键词有以下几个用途： 性能优化： 在 Dart 中，使用 const 关键词可以创建编译时常量，这些常量在程序运行之前就已经确定了值，可以在编译时进行优化。因此，使用 const 可以提高程序的性能，特别是在创建大量相同的对象时。 内存优化： 使用 const 可以确保相同的对象只会在内存中存在一份，这有助于节省内存空间。如果多个地方都需要同一个对象，使用 const 可以确保这个对象只被创建一次。 可读性和维护性： 在某些情况下，使用 const 可以使代码更加简洁清晰，并且可以表达出这个对象是不可变的。这有助于提高代码的可读性和维护性。 再看MyApp构造函数是怎么来的 12345678910111213class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: const MyHomePage(title: 'Flutter Demo Home Page1'), ); }} MyApp继承自StatelessWidget类，const MyApp({super.key});构造函数继承调用父类传参 标准写法实际上应该是这样的 const MyApp({Key? key}) : super(key: key); 问号 ? 是可选链操作符（Optional Chaining Operator）的一部分。而在 Flutter 中，**?** 还有另外一个用途，它表示变量可以为 null。 @override 表示MyApp类重写了父类的build方法，返回值是一个Widget，Widget 是构建用户界面的基本单位。它们描述了应用程序中的各种元素，例如按钮、文本框、图像、布局等。Flutter 中的所有视觉元素都是由 Widget 构成的，因此 Widget 在 Flutter 中起着非常重要的作用。在Flutter中一切皆Widget再看MyHomePage类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ const Text( 'You have pushed the button this many times:', textDirection: TextDirection.ltr, style: TextStyle(color: Colors.amber), ), Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); }} MyHomePage类继承自 StatefulWidget 类 const MyHomePage({super.key, required this.title});构造函数传参 标准写法可以是这样子 12345678class MyHomePage extends StatefulWidget { const MyHomePage({Key? key, required this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();} 在 Dart 中，required 关键字通常用于命名参数（named parameter）或者可选参数（optional parameter）的声明中，表示该参数是必须要传递的，否则会在编译时报错。 在 Flutter 中，required 关键字同样用于命名参数或可选参数，通常用于构造函数中。当你在 Flutter 的构造函数中使用 required 关键字修饰参数时，表示这个参数是必须要传递的，否则会报错。 在 Dart 中，final 关键字用于声明一个只能赋值一次的变量。一旦给 final 变量赋值后，就不能再改变它的值。 在 Flutter 中，final 关键字通常用于声明不可变的对象或者变量，例如在 StatelessWidget 或者 StatefulWidget 中声明 Widget 变量时使用 final 关键字。 **State**：这表示 createState 方法会返回一个与 MyHomePage 类型相关联的 State 对象。在 Flutter 中，State 对象负责管理 Widget 的状态信息。 createState()：这是一个用于创建 State 对象的特殊方法，它必须在 StatefulWidget 的子类中重写。在这里，createState() 方法返回的是一个与 MyHomePage 相关联的 State 对象。 =&gt; _MyHomePageState();：这是 Dart 中的箭头函数语法，用于简化返回表达式。在这里，createState() 方法使用箭头函数的方式直接返回了一个 _MyHomePageState 类的实例，这个实例就是与 MyHomePage 相关联的 State 对象。 综合起来，这行代码的作用是创建一个与 MyHomePage 相关联的 State 对象，并且在 createState 方法中使用了箭头函数的简化语法来直接返回这个 State 对象的实例 **_MyHomePageState()**。这样，Flutter 就能正确地管理 MyHomePage 的状态信息，实现与用户交互相关的状态变化和界面更新。","link":"/2023/06/25/%E5%9C%A8Flutter%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%9A%84demo%E4%B8%8B%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84/"},{"title":"父Widget获取子Widget状态","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import 'package:flutter/material.dart';void main() { runApp(const MyApp());}class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: const HomePage(), ); }}//父Widgetclass HomePage extends StatefulWidget { const HomePage({super.key}); @override State&lt;HomePage&gt; createState() =&gt; _HomePageState();}class _HomePageState extends State&lt;HomePage&gt; { final GlobalKey _globalKey = GlobalKey(); @override Widget build(BuildContext context) { return Scaffold( floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: () { //1、获取currentState Widget的属性（记住） var boxState = _globalKey.currentState as _BoxState; print(boxState._count); setState(() { boxState._count++; }); //调用currentState Widget的方法 boxState.run(); //2、获取子Widget (了解) //只读 var boxWidget = _globalKey.currentWidget as Box; print(boxWidget.color); //值：MaterialColor(primary value: Color(0xfff44336)) // 3、获取子组件渲染的属性（了解） //只读 var renderBox= _globalKey.currentContext!.findRenderObject() as RenderBox; print(renderBox.size); //值：Size(100.0, 100.0) }, ), appBar: AppBar( title: const Text('Title'), ), body: Center( child: Box(key: _globalKey, color: Colors.red), ), ); }}//子Widgetclass Box extends StatefulWidget { final Color color; const Box({Key? key, required this.color}) : super(key: key); @override State&lt;Box&gt; createState() =&gt; _BoxState();}class _BoxState extends State&lt;Box&gt; { int _count = 0; void run() { print(&quot;我是box的run方法&quot;); } @override Widget build(BuildContext context) { return SizedBox( height: 100, width: 100, child: ElevatedButton( style: ButtonStyle( backgroundColor: MaterialStateProperty.all(widget.color)), onPressed: () { setState(() { _count++; }); }, child: Text( &quot;$_count&quot;, style: Theme.of(context).textTheme.headline2, ), ), ); }}","link":"/2023/06/29/%E7%88%B6Widget%E8%8E%B7%E5%8F%96%E5%AD%90Widget%E7%8A%B6%E6%80%81/"},{"title":"vue3+ts 样式处理","text":"postcss1，增强代码的可读性利用从 Can I Use 网站获取的数据为 CSS 规则添加特定厂商的前缀。 Autoprefixer 自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为 CSS 规则添加前缀。2，将未来的 CSS 特性带到今天PostCSS Preset Env 帮你将最新的 CSS 语法转换成大多数浏览器都能理解的语法，并根据你的目标浏览器或运行时环境来确定你需要的 polyfills，此功能基于 cssdb 实现。3，css模块化css 模块能让你你永远不用担心命名太大众化而造成冲突，只要用最有意义的名字就行了。4，避免 CSS 代码中的错误通过使用 stylelint 强化一致性约束并避免样式表中的错误。stylelint 是一个现代化 CSS 代码检查工具。它支持最新的 CSS 语法，也包括类似 CSS 的语法，例如 SCSS 。 postcss-nestingpostcss-nesting 是一个 PostCSS 插件，在 CSS 中添加了类似于 Sass 或 Less 的嵌套语法。它可以帮助我们更好地组织 CSS 代码，使其可读性更高、结构更清晰。 autoprefixerAutoprefixer是一款基于PostCSS插件，用于解析CSS并使用Can I Use中的值向CSS规则添加供应商前缀 。它是 Google 推荐的，并在Twitter和阿里巴巴中使用。可以实现css3代码自动补全，也可以运用到sass、less中 postcss-pxtorempostcss-pxtorem是PostCSS的插件，用于将像素单元生成rem单位。 总之把这四个安装下来 再安装个预处理css less sass都行 vite.config.ts12345678910111213141516171819202122232425262728293031323334353637383940import { defineConfig } from 'vite';import vue from '@vitejs/plugin-vue';import eslintPlugin from 'vite-plugin-eslint';import autoprefixer from 'autoprefixer';import postCssPxToRem from 'postcss-pxtorem';import * as path from 'path';// https://vitejs.dev/config/export default defineConfig({ base: './', resolve: { alias: { '@': path.resolve(__dirname, 'src'), }, }, css: { postcss: { plugins: [ postCssPxToRem({ // 自适应，px&gt;rem转换 rootValue: 16, // 1rem的大小 propList: ['*'], // 需要转换的属性，这里选择全部都进行转换 // propList: ['font', 'font-size', 'line-height', 'letter-spacing'], // selectorBlackList: [], // replace: true, // mediaQuery: false, // minPixelValue: 0, // exclude: /node_modules/i, }), autoprefixer(), ], }, }, server: { host: 'localhost', port: 9999, // 端口 }, plugins: [vue(), eslintPlugin()],}); postCssPxToRem有很多配置项,按需配置 记得把autoprefixer配置在css处理器中 rootValue：根元素的字体大小（font-size），默认为 16。 unitPrecision：转换后的 rem 值的小数位数，默认为 6。 propList：需要转换的属性列表，默认为 ['*']，表示转换所有属性。 selectorBlackList：一个过滤 CSS 选择器的数组，默认值为空数组。可以使用正则表达式。 replace：是否替换原有的 px 单位，默认为 true。 mediaQuery：是否在媒体查询中转换 px 为 rem，默认为 false。 minPixelValue：设置小于多少尺寸的 px 值将不会被转换，默认为 0。 APP.vue动态设置根元素字体大小123456789101112131415161718function setRem() { // 1920 默认大小16px; 1920px = 120rem ;每个元素px基础上/16 const screenWidth = 1920; const scale = screenWidth / 16; const htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; // 得到html的Dom元素 const htmlDom = document.getElementsByTagName('html')[0]; // 设置根元素字体大小 // htmlDom.style.fontSize = htmlWidth / scale + 'px';} // 初始化 setRem(); // 改变窗口大小时重新设置 rem window.onresize = function () { setRem(); }; 你也可以设置字体最大不超过多少,最小不超过多少,同样可以用于H5适配","link":"/2023/03/21/vue3-ts-%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86/"},{"title":"vue3+ts 样式处理","text":"第一步安装所需依赖安装这些东西 1pnpm i eslint eslint-plugin-import eslint-plugin-vue prettier eslint-plugin-prettier eslint-config-prettier eslint-config-airbnb-base -D 第二步 配置eslint初始化命令package.json配置一下 123&quot;scripts&quot;: { &quot;lint:create&quot;: &quot;eslint --init&quot;}, 运行一下命令再安装一些东西 1pnpm i eslint eslint-import-resolver-alias @types/eslint @types/node 第三步 生成eslint配置文件eslintrc.cjs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566module.exports = { parser: 'vue-eslint-parser', parserOptions: { parser: '@typescript-eslint/parser', ecmaVersion: 2020, sourceType: 'module', ecmaFeatures: { jsx: true, }, }, extends: [ 'plugin:vue/vue3-recommended', 'plugin:@typescript-eslint/recommended', 'prettier', 'plugin:prettier/recommended', './.eslintrc-auto-import.json', ], rules: { camelcase: [2, { properties: 'always' }], //变量名采用驼峰命名 indent: ['off', 2], //2 个空格缩进 quotes: [2, 'single'], //强制使用一致的反勾号、双引号或单引号 'no-multi-str': 2, //禁止使用多行字符串(禁止使用斜线&quot;\\&quot;创建多行字符串,应使用&quot;\\n&quot;) //禁止在变量定义之前使用它们 'no-use-before-define': [ 2, { functions: false, classes: false, variables: false, }, ], // 无内容标签自闭合 'vue/html-self-closing': [ 'error', { html: { void: 'always', normal: 'never', component: 'always', }, svg: 'always', math: 'always', }, ], // // 不允许在组件内部直接改变props值，或者说只能通过this.$emit（）改变props值 'vue/no-mutating-props': 'off', 'vue/multi-word-component-names': 'off', // 组件名大驼峰命名 'vue/component-definition-name-casing': ['error', 'PascalCase'], // 检查v-model绑定值是否有效 'vue/valid-v-model': 'error', // 标签结束 /&gt; 之前保留一个空格 'vue/html-closing-bracket-spacing': [ 'error', { selfClosingTag: 'always', }, ], 'no-unused-vars': 'off', '@typescript-eslint/no-unused-vars': ['error'], '@typescript-eslint/no-explicit-any': 0, 'prettier/prettier': 'error', //必须放在规则最后一条 },}; 配置 package文件命令 123&quot;scripts&quot;: { &quot;lint&quot;: &quot;eslint \\&quot;src/**/*.{js,vue,ts}\\&quot; --fix&quot; }, 第四步修改viteconfig.js123456pnpm install vite-plugin-eslint -Dvite的一个插件，让项目可以方便的得到eslint支持，完成eslint配置后，可以快速的将其集成进vite之中，便于在代码不符合eslint规范的第一时间看到提示import eslintPlugin from 'vite-plugin-eslint'plugins: [vue(), eslintPlugin()] 第五步,新建必要配置文件.eslintignore 1234567891011121314151617buildconfig/*.jsstatic/diststatic/jsconfigdist*.env*src/interface/generate.jssrc/interface/swaggerApi.json.eslintrc-auto-import.json.eslintrc.js.prettierrc.js.tailwind.config.jsNIM_Web_SDK_v9.1.1.js .prettierrc.cjs 123456789101112131415161718192021222324module.exports = { // printWidth: 800, //单行宽度限制 // tabWidth: 2, //tab 使用两个空格 arrowParens: 'avoid', // (x) =&gt; {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 bracketSameLine: false, // 将&gt;多行 HTML（HTML、JSX、Vue、Angular）元素放在最后一行的末尾，而不是单独放在下一行（不适用于自闭合元素） bracketSpacing: true, // 在对象，数组括号与文字之间加空格 &quot;{ foo: bar }&quot; embeddedLanguageFormatting: 'auto', //嵌入式语言格式 htmlWhitespaceSensitivity: 'css', // 尊重 CSSdisplay属性的默认值。对于与处理相同的车把strict。 insertPragma: false, // 插入编译指示‍ jsxSingleQuote: false, // 在jsx中使用单引号代替双引号 printWidth: 80, // 超过最大值换行 proseWrap: 'preserve', // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 quoteProps: 'as-needed', // 引用对象中的属性时更改 &quot;as-needed&quot;- 仅在需要时在对象属性周围添加引号‍‍ requirePragma: false, // 需要编译指示‍ semi: true, // 句尾添加分号 singleQuote: true, // 使用单引号代替双引号 tabWidth: 2, // 缩进字节数 trailingComma: 'es5', // 末尾逗号 none - 末尾无逗号，es5 - es5有效保留， all - 在可能的地方都加上逗号‍ useTabs: false, // 缩进不使用tab，使用空格 vueIndentScriptAndStyle: false, // Vue 文件脚本和样式标签缩进‍ endOfLine: 'auto', //结尾是 \\n \\r \\n\\r auto ignorePath: '.prettierignore', // 不使用prettier格式化的文件填写在项目的.prettierignore文件中}; .eslintrc-auto-import.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475{ &quot;globals&quot;: { &quot;ElMessageBox&quot;: true, &quot;ElMessage&quot;: true, &quot;Component&quot;: true, &quot;ComponentPublicInstance&quot;: true, &quot;ComputedRef&quot;: true, &quot;EffectScope&quot;: true, &quot;ExtractDefaultPropTypes&quot;: true, &quot;ExtractPropTypes&quot;: true, &quot;ExtractPublicPropTypes&quot;: true, &quot;InjectionKey&quot;: true, &quot;PropType&quot;: true, &quot;Ref&quot;: true, &quot;VNode&quot;: true, &quot;WritableComputedRef&quot;: true, &quot;computed&quot;: true, &quot;createApp&quot;: true, &quot;customRef&quot;: true, &quot;defineAsyncComponent&quot;: true, &quot;defineComponent&quot;: true, &quot;effectScope&quot;: true, &quot;getCurrentInstance&quot;: true, &quot;getCurrentScope&quot;: true, &quot;h&quot;: true, &quot;inject&quot;: true, &quot;isProxy&quot;: true, &quot;isReactive&quot;: true, &quot;isReadonly&quot;: true, &quot;isRef&quot;: true, &quot;markRaw&quot;: true, &quot;nextTick&quot;: true, &quot;onActivated&quot;: true, &quot;onBeforeMount&quot;: true, &quot;onBeforeRouteLeave&quot;: true, &quot;onBeforeRouteUpdate&quot;: true, &quot;onBeforeUnmount&quot;: true, &quot;onBeforeUpdate&quot;: true, &quot;onDeactivated&quot;: true, &quot;onErrorCaptured&quot;: true, &quot;onMounted&quot;: true, &quot;onRenderTracked&quot;: true, &quot;onRenderTriggered&quot;: true, &quot;onScopeDispose&quot;: true, &quot;onServerPrefetch&quot;: true, &quot;onUnmounted&quot;: true, &quot;onUpdated&quot;: true, &quot;provide&quot;: true, &quot;reactive&quot;: true, &quot;readonly&quot;: true, &quot;ref&quot;: true, &quot;resolveComponent&quot;: true, &quot;shallowReactive&quot;: true, &quot;shallowReadonly&quot;: true, &quot;shallowRef&quot;: true, &quot;toRaw&quot;: true, &quot;toRef&quot;: true, &quot;toRefs&quot;: true, &quot;toValue&quot;: true, &quot;triggerRef&quot;: true, &quot;unref&quot;: true, &quot;useAttrs&quot;: true, &quot;useCssModule&quot;: true, &quot;useCssVars&quot;: true, &quot;useLink&quot;: true, &quot;useRoute&quot;: true, &quot;useRouter&quot;: true, &quot;useSlots&quot;: true, &quot;watch&quot;: true, &quot;watchEffect&quot;: true, &quot;watchPostEffect&quot;: true, &quot;watchSyncEffect&quot;: true }}","link":"/2023/03/21/vue3-ts-%E5%BC%95%E5%85%A5eslint%E5%92%8Cprettier/"},{"title":"渲染管线原理","text":"什么是渲染管线渲染管线（渲染流水线）是将三维场景模型转换到屏幕像素空间输出的过程。图形渲染管线接受一组3D坐标，然后把它们转变为屏幕上的有色2D像素输出。流水线可抽象为三个阶段：应用阶段、几何阶段、光栅化阶段。应用阶段：这是一个由开发者完全控制的阶段，在这一阶段将进行数据准备，并通过CPU向GPU输送数据，例如顶点数据、摄像机位置、视锥体数据、场景模型数据、光源等等；此外，为了提高渲染性能，还会对这些数据进行处理，比如剔除不可见物体；最后还要设置每个模型的渲染状态，这些渲染状态包括但不限于所使用的材质、纹理、shader等。这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，通俗来讲渲染图元可以是点、线、面等。几何阶段：几何阶段运行在GPU中，几何阶段用于处理我们要绘制的几何相关事情，它和每个渲染图元打交道。几何阶段最重要的任务是将顶点坐标变换到屏幕空间中。后面会对几何阶段进行更详细的表述。光栅化阶段：光栅化阶段运行在GPU中，其主要任务是决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值，然后进行逐像素处理。流水线可抽象为三个阶段：应用阶段、几何阶段、光栅化阶段。应用阶段：这是一个由开发者完全控制的阶段，在这一阶段将进行数据准备，并通过CPU向GPU输送数据，例如顶点数据、摄像机位置、视锥体数据、场景模型数据、光源等等；此外，为了提高渲染性能，还会对这些数据进行处理，比如剔除不可见物体；最后还要设置每个模型的渲染状态，这些渲染状态包括但不限于所使用的材质、纹理、shader等。这一阶段最重要的输出是渲染所需的几何信息，即渲染图元，通俗来讲渲染图元可以是点、线、面等。几何阶段：几何阶段运行在GPU中，几何阶段用于处理我们要绘制的几何相关事情，它和每个渲染图元打交道。几何阶段最重要的任务是将顶点坐标变换到屏幕空间中。后面会对几何阶段进行更详细的表述。光栅化阶段：光栅化阶段运行在GPU中，其主要任务是决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值，然后进行逐像素处理。 CPU和GPU之间的通信渲染管线的起点是CPU，CPU与GPU的通信即上文的应用阶段，在这个阶段可分为以下三个步骤：（1）把数据加载到显存：大多数显卡没有直接访问RAM的能力，将数据加载到显存中使GPU能更快的访问这些数据。当把数据加载到显存后，内存中的数据便可以释放了，但对于一些还需要使用的数据则需要继续保留在内存中，如CPU需要网格数据进行碰撞检测。（2）设置渲染状态：渲染状态的一个通俗解释就是，定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器/片段着色器、光源属性、材质等。如果不设置渲染状态，那所有的网格将使用同一种渲染，显然这是不希望得到的结果。（3）调用Draw Call：当所有的数据准备好后，CPU就需要调用一个渲染指令告诉GPU，按照上述设置进行渲染，这个渲染命令就是Draw Call。Draw Call命令仅仅会指向一个需要被渲染的图元列表，而不包含任何材质信息，因为这些信息已经在上一个阶段中完成。执行DrawCall后GPU就会按照渲染流水线进行渲染计算，并输出到显示设备中，所执行的操作便是下述GPU渲染管线的内容。 💡 Tips：可通过 markdown 语法（+ `code` + + 空格）或者快捷键 ctrl/cmd + E快速插入行内代码。 在文本中使用行内代码，可以顺畅地显示代码变量名。 GPU渲染上述是对渲染管线抽象的概述，这里开始对每个阶段进行展开。图形渲染管线可以被划分为如下图所示的几个阶段，每个阶段将会把前一个阶段的输出作为输入，所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行，正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个渲染管线阶段运行各自的小程序，从而在图形渲染管线中快速处理数据。 💡 Tips：GPU具有成千上万的小处理核心，每个核心的运算能力相比GPU要弱得多，但GPU的“人海战术”体现了其强大的并行处理能力，而运行在这些核心上的小程序就叫做Shader。 上图所示的渲染管线，绿色部分代表可编程的阶段，因此也被称为可编程渲染管线（这区别于一些较旧的GPU渲染管线，这种渲染管线只提供一些配置操作，开发者没有对流水线的完全控制权），接下来对各个阶段进行展开。 顶点数据：顶点数据是渲染流水线的输入，顶点数据包括顶点坐标、法线、切线、顶点颜色、纹理坐标等。顶点着色器：顶点着色器的处理单位是顶点，即对于输入的每个顶点都会调用一次顶点着色器。顶点着色器主要功能是进行坐标系变换操作，所输入的顶点坐标等位于模型局部坐标空间，在这一阶段需要将顶点坐标数据变换为到齐次裁剪空间。当顶点坐标被变换到齐次裁剪空间后，通常再由硬件做透视除法，最终得到归一化的设备坐标(NDC)。顶点着色器还可执行顶点光照计算(高洛德着色)，但顶点光照效果通常不尽人意，因此通常在片元着色器中执行逐片元光照计算。曲面细分着色器：曲面细分着色器是一个可选的阶段。曲面细分是利用镶嵌化处理技术对三角形进行细分，以此来增加物体表面的三角面数量。 💡 在这一阶段，程序员可以进行曲面细分操作，看起来就像在原有的图元内加入了更多的顶点。对于一些有大量曲面的模型，进行曲面细分可以让曲面更加圆润；如果为这些细分的顶点再准备一些位置信息，那么这些细分的顶点将有助于我们展现一个细节更加丰富的模型。这也是贴图置换（Displacement Mapping）的基本思路。 几何着色器：几何着色器也是一个可选的阶段。顶点着色器以顶点数据作为输入，而几何着色器则以完整的图元(Primitive)作为输入数据。例如，以三角形的三个顶点作为输入，然后输出对应的图元。与顶点着色器不能销毁或创建顶点不同，几何着色器的主要亮点就是可以创建或销毁几何图元，此功能让GPU可以实现一些有趣的效果。例如，根据输入图元类型扩展为一个或更多其他类型的图元，或者不输出任何图元。需要注意的是，几何着色器的输出图元不一定和输入图元相同。几何着色器的一个拿手好戏就是将一个点扩展为一个四边形(即两个三角形)。 裁剪：裁剪操作就是将相机看不到的物体、顶点剔除，使其不被下一阶段处理。只有当图元完全位于视锥体内时，才会将它送到下一阶段，对于部分位于视锥体内的图元，外部的顶点将被剔除掉。由于已经知道在NDC下的顶点位置（即顶点位置在一个立方体内），因此裁剪就变得简单：只需要将图元裁剪到单位立方体内。裁剪这一步骤是硬件的固定操作，因此是不可编程的。 屏幕映射：这一步输入的坐标仍是三维坐标（范围在单位立方体内），屏幕映射的任务就是将每个图元的x、y值变换到屏幕坐标系（屏幕坐标系是一个2D空间）。由于输入坐标范围在[-1,1]，因此这是一个拉伸到屏幕分辨率大小的过程。对于输入的坐标z值不做任何处理（实际上屏幕坐标系和z坐标一起构成窗口坐标系），这些值会被一起传递到光栅化阶段。屏幕坐标系在OpenGL和DirectX中的定义方式不同。 三角形设置：光栅化第的第一个流水线阶段是三角形设置，这个阶段会计算光栅化一个三角形所需的信息。具体来说上一阶段输出的都是三角形的顶点，但如果要得到整个三角形网格对像素的覆盖情况，就必须计算每条边上的像素坐标。为了能计算边界像素的坐标信息，就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。它的输出是为下一阶段做准备的。 三角形遍历：该阶段会检查每个像素是否被一个三角形网格所覆盖。若被覆盖的话就会生成一个片元。而这样一个找到哪些像素被三角形网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换。三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角形网格覆盖了哪些像素，并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。 关于三角形设置和三角形遍历，Dmitry V. Sokolov老师的tinyrenderer开源项目中的Lesson1和Lesson2对这部分内容进行了体现。这两节课从使用Bresenham算法绘制一根直线开始直至通过线扫绘制成一个三角形。（根据Dmitry V. Sokolov的说法，正文所述扫描变换似乎是较旧的CPU渲染算法？）关于三角形顶点的插值与三角形的重心坐标系相关，三角形填充也会产生锯齿的问题，相关内容后续进行学习补充。 片元着色器：片元着色器是一个非常重要的可编程着色器阶段，前面的光栅化阶段实际上并不会影响每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的，而片元就负责存储这样一系列信息，真正会对产生影响的是下一个阶段逐片元操作。片元着色器的输入是上一个阶段对顶点信息进行插值的结果（是根据从顶点着色器输出的数据插值得到的），而它的输出是像素颜色值。这一阶段可以完成很多重要的渲染技术，其中最重要的技术有纹理采样、逐片光照计算等，覆盖片元的纹理坐标是通过前述的阶段的顶点数据插值得到的。 逐片元操作（输出合并）：逐片元操作是渲染管线的最后一个阶段，这一阶段有几个重要任务： （1）决定每个片元的可见性，这涉及到很多测试功能，例如深度测试、模板测试。模板测试与之相关的是模板缓冲，模板测试通常用来限制渲染的区域，渲染阴影，轮廓渲染等。如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值进行比较，这个比较函数可以是由开发者指定的。模板测试是高度可配置的，无论一个片元有没有经过模板测试，都可以根据模板测试和下面的深度测试结果来修改模板缓冲区。 深度测试同样是高度可配置的，如果开启了深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较，这个比较函数也是可以由开发者设置，通常这个值是小于等于的关系，因为我们总想显示出离相机最近的物体(不包括透明/半透明)，而那些被遮挡的就不需要出现在屏幕。如果一个片元通过了测试，那么开发者可以指定是否要用这个片元的深度值覆盖所有的深度值。 💡 Tips：测试顺序并不是唯一的，逻辑上来说测试是在片元着色器之后进行，但对于大多数GPU而言，会尽可能的在执行片元着色器之前就执行测试操作，从而避免将不需要渲染的图元流入到后续的运算中。但将测试提前可能会与片元着色器中的一些操作冲突，如透明度测试，因此需要对其进行判断。 （2）如果一个片元通过了所有测试，就需要把这些片元的颜色值和颜色缓冲中已有的颜色值进行混合。颜色混合的一个重要应用就是渲染出透明效果。开发者可以选择开启/关闭混合功能，如果没有开启混合，就会直接覆盖掉颜色缓冲区中的颜色。如果开启了混合，GPU会取出片元着色器得到的颜色（源颜色）和颜色缓冲区存在的颜色（目标颜色），之后按照设定的函数进行混合，这个混合函数通常和透明度通道息息相关，例如可以根据透明通道的值进行相加、相减、相乘等。","link":"/2023/12/25/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%8E%9F%E7%90%86/"},{"title":"初识着色器(包括着色器传参)","text":"摘要本文内容主要介绍 Three.js 中的着色器知识，通过讲解什么是着色器、着色器的分类、GLSL 语言的核心语法要点、Three.js 中的两种着色器材质的 RawShaderMaterial 和 ShaderMaterial 的区别和用法等基本知识，深入理解着色器，并使用它创建出有趣的三维图形。 效果随着本文内容一步步深入，最终将使用着色器构建一个如下所示的波动旗帜 🚩 效果，通过滑动调整页面右上方的 dat.GUI 控制器，可以调整 x轴 和 y轴 上的波动幅度。 正文 Shader着色器简介着色器是 WebGL 的重要组件之一，它是一种使用 GLSL 语言编写的运行在 GPU 上的程序。顾名思义，着色器用于定位几何体的每个顶点，并为几何体的每个可见像素进行着色 🎨。着色器是屏幕上呈现画面之前的最后一步，用它可以实现对先前渲染结果进行修改，如颜色、位置等，也可以对先前渲染的结果做后处理，实现高级的渲染效果。例如，对于相同场景、相同光照、相同模型等条件下，对这个模型分别使用不同的着色器，就会呈现出完全不同的渲染效果：使用 plastic shader 的模型渲染出塑料质感，而使用了 toon shader 的模型则看起来是二维卡通效果。 为什么要使用着色器虽然 Three.js 已经内置了非常多的材质，但是在实际开发中很难满足我们的需求，比如在数字孪生系统的开发中，我们经常需要添加一些炫酷的飞线效果、雷达效果等 ✨，它们是无法直接使用 Three.js 来生成，此时就需要我们创建自己的着色器。而且出于性能的考虑，我们也可以使用自己的着色器材质代替像 MeshStandardMaterial 这样的材质非常精细涉及大量代码和计算的材质，以便于提升页面性能。 着色器的类型 顶点着色器Vertex ShaderVertex Shader 用于定位几何体的顶点，它的工作原理是发送顶点位置、网格变换（position、旋rotation和 scale 等）、摄像机信息（position、rotation、fov 等）。GPU 将按照 Vertex Shader 中的指令处理这些信息，然后将顶点投影到 2D 空间中渲染成 Canvas。当使用 Vertex Shader 时，它的代码将作用于几何体的每个顶点。在每个顶点之间，有些数据会发生变化，这类数据称为 attribute；有些数据在顶点之间永远不会变化，称这种数据为 uniform。Vertex Shader 会首先触发，当顶点被放置，GPU 知道几何体的哪些像素可见，然后执行 Fragment Shader。 attribute：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点的位置。 uniform：顶点着色器使用的常量数据，不能被修改，一般用于对同一组顶点组成的单个 3D 物体中所有顶点都相同的变量，如当前光源的位置。 varying: 从顶点着色器发送到片元着色器中的插值计算数据 片元着色器Fragment ShaderFragment Shader 在 Vertex Shader 之后执行，它的作用是为几何体的每个可见像素进行着色。我们可以通过uniforms 将数据发送给它，也可以将 Vertex Shader 中的数据发送给它，我们将这种从 Vertex Shader 发送到 Fragment Shader 的数据称为 varying。Fragment Shader 中最直接的指令就是可以使用相同的颜色为所有像素进行着色。如果只设置了颜色属性，就相当于得到了与 MeshBasicMaterial 等价的材质。如果我们将光照的位置发送给 Fragment Shader，然后根据像素收到光照影响的多少来给像素上色，此时就能得到与 MeshPhongMaterial 效果等价的材质。 📌 以下内容示例流程翻译、并整理于《three.js journey》 shader 相关课程，如果对英文原版感兴趣可前往查看。 原始着色器材质RawShaderMaterial在 Three.js 中可以渲染着色器的材质有两种：RawShaderMaterial 和 ShaderMaterial，它们之间的区别是 ShaderMaterial 会自动将一些初始化着色器的参数添加到代码中（内置 attributes 和 uniforms），而 RawShaderMaterial 则什么都不会添加。我们先来看看如何使用 RawShaderMaterial 材质，首先我们创建一个平面，然后和创建其他材质一样，通过 new THREE.RawShaderMaterial 初始化原始着色器材质，并给它添加两个参数 vertexShader 和 fragmentShader 代表材质的顶点着色器和片元着色器。 1234const material = new THREE.RawShaderMaterial({ vertexShader: '', fragmentShader: '' }) 然后开始编写材质的顶点着色器和片元着色器，分别添加如下的代码。 1234567891011121314151617181920const material = new THREE.RawShaderMaterial({ vertexShader: ` uniform mat4 projectionMatrix; uniform mat4 viewMatrix; uniform mat4 modelMatrix; attribute vec3 position; void main() { gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0); } `, fragmentShader: ` precision mediump float; void main(){ gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } ` }); 此时可以得到一个红色的平面，说明我们编写的第一个着色器运行成功了 🎉。 分离两种着色器在实际开发中，着色器比较复杂，代码量比较多，如果直接放在材质中的话会增加代码阅读困难量。我们可以将着色器代码单独拆分出来，分别存放在 vertex.glsl 和 fragment.glsl 文件中，然后在代码中像下面这样引入即可。这样做还有一个好处就是可以安装代码编辑器的 GLSL 高亮语法插件，提高编程效率。 1234567import testVertexShader from './shaders/test/vertex.glsl';import testFragmentShader from './shaders/test/fragment.glsl';const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader }); 此时查看页面，得到的结果还是一样的。 属性材质的一些通用属性在 RawShaderMaterial 同样是适用的，比如 wireframe、side、transparent、flatShading 等都可以生效，对上面材质开启 wireframe 属性，可以得到如下图所示的平面的网格模型。 12345const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader, wireframe: true }); :::danger但是需要注意的是，像map、alphaMap、opacity、color等属性在着色器材质中会失效，我们需要在着色器代码中自己实现::: GLSL 语言在 Three.js 中，需要使用 GLSL 语言来编写着色器，全称是 OpenGL Shading Language，意为 OpenGL 中的着色语言。它的语法类似于 C语言，在开始编写着色器之前，我们先了解一些它的基本语法。 日志：由于着色器语言是针对每个顶点和每个片元执行的，日志记录是没有意义的，因此编写 GLSL 时没有控制台。 缩进：代码缩进格式没有严格要求，只要易读美观就行。 分号：和 C语言 一样，编写 GLSL 语言时，任何指令的结尾都必须添加分号，丢失分号就会导致代码无法运行。 类型：和 C语言 一样， GLSL 是一种强类型语言，不同类型的变量不能混用，否则会报错。 变量在 GLSL 中有很多变量类型，编写着色器时，我们需要根据需要选择合适类型的变量。 整型用以定义整数。 12int foo = 123;int bar = - 1; 浮点类型浮点数就是小数，可以是正数也可以是负数，必须提供小数点 .。 12float foo = - 0.123;float bar = 1.0; 布尔类型用于表示值得真假。 12bool foo = true;bool bar = false; 二维向量vec2如果我们需要存储具有 x 和 y 属性这样具有2个坐标的值时，可以使用 vec2。需要注意的是，直接使用 vec2 foo = vec2() 这样未添加参数的空值会报错，应该像下面这样提供完整的参数： 1vec2 foo = vec2(1.0, 2.0); 创建 vec2 后修改属性值： 123vec2 foo = vec2(0.0);foo.x = 1.0;foo.y = 2.0; 进行浮点数与 vec2 相乘等操作运算时，结果将同时作用于 x 和 y： 12vec2 foo = vec2(1.0, 2.0);foo *= 2.0; 三维向量vec3与 vec2 类似，vec3 用于表示具有 x、y、z 三个坐标的值，可以用它非常方便的表示三维空间坐标。 123vec3 foo = vec3(0.0);vec3 bar = vec3(1.0, 2.0, 3.0);bar.z = 4.0; RGB 颜色也同样适合使用 vec3 表示： 123vec3 color = vec3(0.0);color.r = 0.5;color.b = 1.0; 可以使用 vec2 来创建 vec3： 12vec2 foo = vec2(1.0, 2.0);vec3 bar = vec3(foo, 3.0); 也可以使用 vec3 来创建 vec2，其中 bar 的值为 1.0, 2.0，baz 的 值为 2.0, 1.0： 123vec3 foo = vec3(1.0, 2.0, 3.0);vec2 bar = foo.xy;vec2 baz = foo.yx; 四维向量vec4与前面几个类似，vec4 用于表示四维向量，四个值命名为 x, y, z, w 或 r, g, b, a，向量之间同样能进行相互转换： 12vec4 foo = vec4(1.0, 2.0, 3.0, 4.0);vec4 bar = vec4(foo.zw, vec2(5.0, 6.0)); 除上述之外，还有一些其它类型的变量，如 mat2、mat3、mat4、sampler2D 等将在后续学习中介绍。 在着色器内，一般命名以 gl_ 开头的变量是着色器的内置变量。 webgl_ 和 webgl 是着色器保留字，自定义变量不能以 webgl 或 _webgl 开头。 变量声明一般包含 &lt;存储限定符&gt; &lt;数据类型&gt; &lt;变量名称&gt;，以 attribute vec4 a_Position 为例，attribute 表示存储限定符，vec 是数据类型，a_Position 为变量名。 函数在 GLSL 中定义函数，必须以返回值的类型开头，如果没有返回值，则可以使用 void。定义函数的参数时，也必须提供参数类型。在 GLSL 中定义函数，必须以返回值的类型开头，如果没有返回值，则可以使用 void。定义函数的参数时，也必须提供参数类型。 123456789101112131415// 有返回值float loremIpsum() { float a = 1.0; float b = 2.0; return a + b;}// 无返回值void justDoingStuff() { float a = 1.0; float b = 2.0;}// 定义参数类型float add(float a, float b) { return a + b;} 内置函数GLSL 内置了很多使用的函数，下面列举了一些比较常用的： 运算函数 abs(x)：取 x 的绝对值 radians(x)：角度转弧度 degrees(x)：弧度转角度 sin(x)：正弦函数，传入值为弧度。还有 cos 余弦函数、tan 正切函数、asin 反正弦、acos反余弦、atan 反正切等 pow(x,y)：x^y exp(x)：e^x exp2(x)：2^x log(x)：logex log2(x)：log2x sqrt(x)：x√ inversesqr(x)：1x√ sign(x)：x&gt;0 返回 1.0，x&lt;0 返回 -1.0，否则返回 0.0 ceil(x)：返回大于或者等于 x 的整数 floor(x)：返回小于或者等于 x 的整数 fract(x)：返回 x-floor(x) 的值 mod(x,y)：取模求余数 min(x,y)：获取 x、y 中小的那个 max(x,y)：获取 x、y 中大的那个 mix(x,y,a)：返回 x∗(1−a)+y∗a step(x,a)：x&lt;a返回 0.0，否则返回 1.0。 smoothstep(x,y,a)：a&lt;x 返回 0.0，a&gt;y 返回 1.0，否则返回 0.0-1.0 之间平滑的 Hermite 插值。 dFdx(p)：p 在 x 方向上的偏导数 dFdy(p)：p 在 y 方向上的偏导数 fwidth(p)：p 在 x 和 y 方向上的偏导数的绝对值之和 **几何函数 ** length(x)：计算向量 x 的长度 distance(x, y)：返回向量 xy 之间的距离 dot(x,y)：返回向量 xy 的点积 cross(x,y)：返回向量 xy 的差积 normalize(x)：返回与 x 向量方向相同，长度为 1 的向量 矩阵函数 matrixCompMult(x,y)：将矩阵相乘 lessThan(x,y)：返回向量 xy 的各个分量执行 x&lt;y 的结果 lessThanEqual(x,y)：返回向量 xy 的各个分量执行 x&lt;=y 的结果，类似的有类似的有 greaterThanEqual any(bvec x)：x 有一个元素为 true，则为 true all(bvec x)：x 所有元素为 true，则返回 true，否则返回 false not(bvec x)：x 所有分量执行逻辑非运算:::success如果想了解更多GLSL的内置函数，可以到这个网站查询：Kronos Group OpenGL reference pages::: 理解顶点着色器Vertex Shader接下来讲解着色器里代码的具体内容。顶点着色器的作用是将几何体的每个顶点放置在 2D 渲染空间上，即顶点着色器将 3D 顶点坐标转换为 2D canvas 坐标。main函数它将被自动调用，并且不会返回任何内容。 1void main() {} gl_Positiongl_Position 是一个内置变量，我们只需要给它重新赋值就能使用，它将会包含屏幕上的顶点的位置。下面 main 函数中就是用于给它设置合适的值。执行这段指令后，将得到一个 vec4，意味着我们可以直接在 gl_Position 变量上使用其x、y、z 和 w 属性。 123456void main() { gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0); gl_Position.x += 0.5; gl_Position.y += 0.5;} 平面向右上角发生了位移，但是需要注意的是，我们并没有像在 Three.js 中一样将平面在三维空间中进行了移动，我们只是在二维空间中移动了平面的投影。就像你在桌子上画了一幅具有透视效果的画，然后把它向桌子右上角移动，但是你的画中的透视效果并没有发生变化。gl_Position 的作用是在 2D 空间上定位 📍 顶点，既然是 2D 空间，为什么需要使用一个四维向量表示呢？实际上是这些坐标并不是精确的在 2D 空间，而是位于被称为 Clip Space 需要四个维度的裁切空间。裁切空间是指在 -1 到 +1 范围内所有 x、y、z 3个方向上的空间，第四个值 w 用于表示透视。就像把所有东西都放在 3D 盒子中一样，任何超出范围的内容都将被裁切。gl_Position 这些内容的这些内容都是自动完成的，我们只需明白其大概原理即可。 位置属性Position attributes相同的代码将应用于几何体的每一个顶点，属性变量 attribute 是在顶点之间唯一会发生改变的变量。相同的顶点着色器 Vertex Shader 将应用于每一个顶点，position 属性将包含具体顶点的 x, y, z 坐标值。我们可以使用如下代码获取顶点位置： 12attribute vec3 position; 因为 gl_Position 是 vec4 类型，可以使用以下方法将 vec3 转化成 vec4： 12gl_Position = /* ... */ vec4(position, 1.0); 矩阵限定变量Matrices uniforms每个矩阵将转换 position，直到我们获得最终的裁切空间坐标。下面是 3 个矩阵，因为在几何体所有顶点中它们的值都是相同的，我们可以通过 uniform 来获取它们。 123uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat4 modelMatrix; 下面将对每个矩阵做出一些变换： modelMatrix：将进行网格相关的变换，如缩放、旋转、移动等操作变换都将作用于 position。 viewMatrix：将进行相机相关的变换，如我们向左移动相机，顶点应该在右边、如果我们朝着网格方向移动相机，顶点会变大等。 projectionMatrix：会将我们的坐标转化为裁切空间坐标。 为了使用矩阵，我们需要将其相乘，如果想让一个 mat4 作为变量，则该变量类型必须是 vec4。我们也可以将多个矩阵相乘： 12gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0); 实际上还可以使用更短的写法来让 viewMatrix 和 modelMatrix 组合成一个 projectionMatrix，虽然代码少了，但我们可控制的步骤也少了。 12345678uniform mat4 projectionMatrix;uniform mat4 modelViewMatrix;attribute vec3 position;void main(){ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);} 实际中我们会选择更长的写法，以便于更好地理解及对 position 进行更多的控制。 123456789101112uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat4 modelMatrix;attribute vec3 position;void main(){ vec4 modelPosition = modelMatrix * vec4(position, 1.0); vec4 viewPosition = viewMatrix * modelPosition; vec4 projectedPosition = projectionMatrix * viewPosition;~~~~ gl_Position = projectedPosition;} 上面两种写法都是等价的，使用下面这种时，我们可以更方便地进行控制，比如可以通过调整 modelPosition 的值来对整个模型进行移动，通过以下代码，就能向上移动模型： 123456void main() { vec4 modelPosition = modelMatrix * vec4(position, 1.0); modelPosition.y += 1.0; // ...} 我们还可以做一些更有趣的操作，比如将平面变换为波浪形状： 123456void main() { vec4 modelPosition = modelMatrix * vec4(position, 1.0); modelPosition.z += sin(modelPosition.x * 10.0) * 0.1; // ...} 理解片元着色器Fragment Shader片元着色器的代码将应用于几何体的每个可见像素，这就是片元着色器在顶点着色器之后运行的原因，它的代码比顶点着色器更易于管理。 主函数main同样，片元着色器中也有一个主函数： 12void main() {} 精度Precision在顶部有一条这样的指令，我们用它来决定浮点数的精度，有以下几种值供选择： highp：会影响性能，在有些机器上可能无法运行； mediump：常用的类型； lowp：可能会由于精度问题产生错误。 12precision mediump float; 我们现在示例使用的是 RawShaderMaterial 原始着色器材质才需要设置精度，在着色器材质 ShaderMaterial中会自动处理。 在顶点着色器中也可以是指精度，但是这是非必须的。 gl_FragColorgl_FragColor 和 gl_Position 类似，但它用于颜色。它也一样是已经被内置声明了的，我们只需要在main 函数中重新给它赋值。它是一个 vec4，前三个值是红色、绿色、蓝色通道 (r, g, b)，第四个值是透明度 alpha (a)。gl_FragColor 的每个值的取值范围是 0.0 到 1.0，如果我们设置的值高于它们，也不会产生报错。下面这段代码将生成一个紫色的几何体 12gl_FragColor = vec4(0.5, 0.0, 1.0, 1.0); 为了 alpha 透明度值可以生效，我们需要在材质中将 transparent 属性设置为 true： 123456const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader, transparent: true}) 属性AttributesAttributes 是每个顶点之间变化的值，我们之前已经有一个命名为 position 的属性变量，它是每个顶点在坐标轴中的 vec3 值。我们将为每个顶点添加一个随机值，并根据这个值在 z 轴上移动该顶点。在 JavaScript 代码中我们可以像下面这个直接给 BufferGeometry 添加 attribute 属性。然后再创建一个 32位 的浮点类型数组 Float32Array，为了知道几何体中有多少个顶点，现在可以通过 attributes 属性获取。最后在 BufferAttribute 中使用该数组，并将它添加到几何体的属性中。 setAttribute：第一个参数是需要设置的 attribute 属性名称，然后在着色器中可以使用该名字，属性名命名时最好加一个 a 前缀方便区分。 BufferAttribute：第一个参数是数据数组；第二个参数表示组成一个属性的值的数量，如我们要发送一个 (x, y, z) 构成位置，则需要使用 3，示例中每个顶点的随机数只有 1个，因此这个参数使用 1。 12345678910const geometry = new THREE.PlaneBufferGeometry(1, 1, 32, 32)const count = geometry.attributes.position.countconst randoms = new Float32Array(count)// 使用随机数填充数组for(let i = 0; i &lt; count; i++) { randoms[i] = Math.random()}// 添加到几何体的属性中geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1)) 现在，我们可以在顶点着色器中获取该属性，并使用它移动顶点，可以得到一个如下图所示的一个由随机尖峰构成的平面。 12345678attribute float aRandom;void main(){ // ... modelPosition.z += aRandom * 0.1; // ...} 限定变量Varyings现在我们若想在片元着色器中想使用 aRandom 属性给片元着色，是无法直接使用 attribute 属性变量的。此时，实现这个功能的方法就是将这个值从顶点着色器发送到片元着色器，称这种变量为 varying。我们需要在两种着色器中都做如下的操作： 在顶点着色器中，我们需要在 main 函数之前创建 varying，将其命名为以 v 作为前缀的变量名 vRandom，然后在 main 函数中给它赋值： 1234567varying float vRandom;void main() { // ... vRandom = aRandom;} 在片元着色器中，使用相同的方法声明，然后在 main 函数中使用它，可以得到如下的染色效果： 1234567precision mediump float;varying float vRandom;void main() { gl_FragColor = vec4(0.5, vRandom, 1.0, 1.0);} :::danger📌 varying的一个有趣之处是，顶点之间的值是线性插值的，如GPU在两个顶点之间绘制一个片元，一个顶点的varying是1.0，另一个顶点的varying是0.0，则该片元值将为0.5。这个特性可以实现平滑的渐变效果。::: 统一变量Uniformsuniform 用于将数据从 JavaScript 发送到 着色器。如果我们使用同一个着色器但是参数不同时就可以使用 uniform，使用期间参数还可以改变。在顶点着色器 和 片元着色器 中都可以使用 uniform，它的值在每个顶点和每个片元中的数据都是相同的。实际上在我们的代码中已经有 projectionMatrix、viewMatrix、modelMatrix 等 uniform，Three.js 内置创建了它们。现在，我们来创建自己的 uniform。为了将统一变量添加到材质中，需要使用 uniforms 属性。我们将创建一个波动的平面，并使用变量来控制波浪的频率。下面用于控制 频率 的变量命名为 uFrequency，特地加了一个 u 字符作为前缀来标识是 uniform 变量，方便在着色器中和其他参数区分开来，但这不是强制的。 12345678const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader, uniforms: { uFrequency: { value: 10 } }}) 然后，可以在着色器代码中获取 uniform 值，并在 main 函数中使用它： 123456789101112uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat4 modelMatrix;uniform float uFrequency;attribute vec3 position;void main() { // ... modelPosition.z += sin(modelPosition.x * uFrequency) * 0.1;} 显示结果和前面的相同，但是现在我们可以在 JavaScript 来控制频率了。我们可以把频率 frequency 改成 vec2 来控制水平和垂直方向的波动，在 Three.js 中可以使用二维向量 THREE.Vector2： 12345678const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader, uniforms: { uFrequency: { value: new THREE.Vector2(10, 5) } }}) 然后在着色器中，将 uFrequency 的类型从 float 改为 vec2 并在 z轴 同时应用 uFrequency 的 x值 和 y值，此时我们的模型网格就会同时产生在水平和垂直方向的波动： 12345678910// ...uniform vec2 uFrequency;void main() { // ... modelPosition.z += sin(modelPosition.x * uFrequency.x) * 0.1; modelPosition.z += sin(modelPosition.y * uFrequency.y) * 0.1; // ...} 让我们再新加一个 uniform 来让平面像在风中飘动的旗帜。我们将使用统一变量 uTime 向着色器发送一个时间值，然后在 sin(…) 函数中使用它： 123456789const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader, uniforms: { uFrequency: { value: new THREE.Vector2(10, 5) }, uTime: { value: 0 } }}) 不要忘了在 tick (render函数)页面重绘函数中更新 uTime，我们使用 getElapsedTime 来获取已经花费了多少时间: 123456const tick = () =&gt; { const elapsedTime = clock.getElapsedTime(); material.uniforms.uTime.value = elapsedTime; // ...} 然后在着色器中获取 uTime 并在 sin(…) 函数中使用它，我们的平面就会看起来像一个在风中飘动的旗帜 🚩： 123456789// ...uniform float uTime;void main() { modelPosition.z += sin(modelPosition.x * uFrequency.x + uTime) * 0.1; modelPosition.z += sin(modelPosition.y * uFrequency.y + uTime) * 0.1; // ...} 我们也可以将 uTime 之前的 + 改为 - 来修改波动的方向。 123modelPosition.z += sin(modelPosition.x * uFrequency.x - uTime) * 0.1;modelPosition.z += sin(modelPosition.y * uFrequency.y - uTime) * 0.1; :::danger📌 注意，使用uTime时如果直接使用JavaScript的Date.now()，会发现不起作用，因为它的数值对于着色器而言太过庞大，我们不能发送太小或太大的统一变量值。:::虽然现在网格模型具有波动效果，但是它仍然是一个平面网格构成，我们可以修改它的属性来使它看起来更像个旗子 🚩。我们可以修改它的大小比例： 12const mesh = new THREE.Mesh(geometry, material);mesh.scale.y = 2 / 3; 在片元着色器中也可以使用 uniform 统一变量，我们添加一个 uColor 作为颜色变量： 12345678910const material = new THREE.RawShaderMaterial({ vertexShader: testVertexShader, fragmentShader: testFragmentShader, uniforms: { uFrequency: { value: new THREE.Vector2(10, 5) }, uTime: { value: 0 }, uColor: { value: new THREE.Color('orange') } }}) 然后在片元着色器中获取颜色变量，并将它作为 gl_FragColor 的值，你会看到平面将变成设定的颜色效果： 1234567precision mediump float;uniform vec3 uColor;void main() { gl_FragColor = vec4(uColor, 1.0);} 纹理TexturesTextures 知识比较复杂，在之前的文章中已经介绍过使用 THREE.TextureLoader 加载纹理，下面我们给着色器材质添加一个图片纹理，并使用 uTexture 统一变量传递给着色器： 12345678const material = new THREE.RawShaderMaterial({ // ... uniforms: { // ... uTexture: { value: textureLoader.load('/textures/flag.png') } }}) 然后在着色器中，为了使纹理的颜色应用于每个可见片元上，我们需要使用 texture2D(…)，它接收两个参数，第一个是需要应用的纹理即 uTexture，第二个是纹理上拾取颜色的坐标系，这个坐标系其实就是前面讨论的 UV坐标,它的作用是将纹理坐标投射到几何体上。我们用于创建几何体的 PlaneBufferGeometry 会自动生成这个坐标，我们可以通过 geometry.attributes.uv 来查看它。texture2D(…) 的返回结果是一个由 r, g, b, a 构成的 vec4。因为 uv 是一个 attribute 属性，因此需要在顶点着色器中需要这样获取它，我们需要在片元着色器中使用它，因此还需要通过 varying 发送到片元着色器，并在 main 函数中更新它： 123456789// ...attribute vec2 uv;varying vec2 vUv;void main() { // ... vUv = uv;} 现在，我们可以在片元着色器中获取 vUv 变量，并在 texture2D(…)方法中使用它： 123456789101112precision mediump float;uniform vec3 uColor;uniform sampler2D uTexture;varying vec2 vUv;void main() { vec4 textureColor = texture2D(uTexture, vUv); gl_FragColor = textureColor;} 颜色变化现在虽然有了图片贴图，但是旗子 🚩 的明暗颜色变化还不太明显，下面我们将为它添加一些阴影变化。首先在顶点着色器中，我们将把风的高程存储 elevation 变量中，然后通过 varying 发送到片元着色器： 1234567891011varying float vElevation;void main() { // ... float elevation = sin(modelPosition.x * uFrequency.x - uTime) * 0.1; elevation += sin(modelPosition.y * uFrequency.y - uTime) * 0.1; modelPosition.z += elevation; // ... vElevation = elevation;} 然后在片元着色器中获取 vElevation，用它来改变 textureColor 的 r, g, b属性： 123456789// ...varying float vElevation;void main() { vec4 textureColor = texture2D(uTexture, vUv); textureColor.rgb *= vElevation * 2.0 + 0.5; gl_FragColor = textureColor;} 着色器材质ShaderMaterial上面所有内容，为了深入理解着色器的原理，我们使用的是 RawShaderMaterial，接下来我们使用更简单的 ShaderMaterial 来重构上面完成的所有功能。ShaderMaterial 和 RawShaderMaterial 的工作原理其实是一样的，只不过其内置 attributes 和 uniforms，精度 也会自动设置。我们只需按下面流程稍加修改代码即可。在 JavaScript 代码中将材质换为 THREE.ShaderMaterial。 12const material = new THREE.ShaderMaterial({}); 然后删除着色器中以下属性和定义： uniform mat4 projectionMatrix; uniform mat4 viewMatrix; uniform mat4 modelMatrix; attribute vec3 position; attribute vec2 uv; precision mediump float; 其他 查错：因为着色器是对每个片元执行，因此没有日志记录，出错的话很难查找，如果我们忘写了分号，Three.js 会将整个着色器代码打印出来并会提示出错的行号； 调试：调试数值的一种方法是可以在 gl_FragColor 中使用它，虽然不够精确，但是可以看到颜色变化； GLSLify：一个 node module 模块，可以改对 glsl 文件的处理，通过 glslify 我们可以像模块一样导入和导出 glsl 代码。你可以使用 glslify-loader 并将其加到 webpack 配置中。 总结 了解什么是着色器 了解为什么要使用着色器 GLSL 语言的基本语法规则 理解 Vertex Shader 顶点着色器 理解 Fragment Shader 片元着色器 掌握 Attributes、Varyings、Uniforms的区别和用法 着色器在两种着色器材质 RawShaderMaterial 和 ShanderMaterial 中的使用方法 使用着色器设置颜色和纹理等","link":"/2023/12/26/%E5%88%9D%E8%AF%86%E7%9D%80%E8%89%B2%E5%99%A8-%E5%8C%85%E6%8B%AC%E7%9D%80%E8%89%B2%E5%99%A8%E4%BC%A0%E5%8F%82/"},{"title":"01BTC-密码学原理-区块链系统实现","text":"区块链与密码学以比特币为例子，比特币作为区块链的经典应用，其本质是一种加密货币， 但实际上，比特币是不加密的，区块链上的所有信息都是公开的，包括账户的地址、交易记录、金额等等。比特币主要用到了密码学中的2个功能，一个是哈希，另一个是签名；这也是区块链中涉及到密码学部分的主要功能。 一、哈希(散列)函数哈希函数是可以用来将任意大小的数据映射到固定大小值的任何函数。哈希函数返回的值称为哈希值、哈希码、摘要或简单的哈希。这些值用于索引一个固定大小的表，称为哈希表。使用哈希函数为哈希表建立索引称为哈希或分散存储寻址。 二、密码散列函数(Cryptographic hash function)密码散列函数（英语：Cryptographic hash function），又译为加密散列函数、密码散列函数、加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的资料是什么。这样的单向函数被称为“现代密码学的驮马”那么区块链中的哈希函数主要是密码散列函数，它有几个重要的性质： Collision resistance(抗碰撞性) Hiding(不可逆) puzzle friendly （仅比特币需满足） Collision resistance抗碰撞性的意思就是对于一个哈希函数H,2个输入a,b，你很难找到两个不同的输入使得哈希后的输出值相同 H(a)=H(b),_wherea_\\=b 两个不同的输入输出的值是相同的，一般来说，哈希碰撞是无可避免的，因为你的输入空间其实远远大于输出空间，假如我们的哈希函数输出值控制在256个bit位，那么它的输出空间有2256种情况，理论上，如果进行2256+1次计算，则能达到哈希碰撞，也就是能找到两个不同的输入使得哈希值相同。但是这样的计算太庞大，很难实现。利用抗碰撞性，我们可以拿来检测数据是否被篡改，假如我们有一个数据m,它的哈希值H(m)，也把它叫做’message digest’，如果有人改了m，那么哈希值一定会发生变化。因为抗碰撞性，意为着你无法篡改内容而又不被发现。Collision resistance在数学上无法被证明，只能靠实际经验获得，但有一些哈希函数如MD5已经被找到一种方法能够人为的构造哈希碰撞。 Hidinghiding的意思是哈希过程是不可逆的，你知道哈希值，并不能反推出哈希函数的输入值具体是多少。但这个条件成立的前提是输入空间足够大：如果只有几个输入，那就很没意思了输入空间均匀分布：即使有很大的输入空间，但如果某几个输入值被选中的概率很大，那就意味着有很大的概率反推输入值 digital commitment用前面两个性质可以实现digital commitment，这也叫digital equivalent of a sealed envelop。举一个现实生活的例子。如一个人说自己能预测股票涨停，那么如何证明呢？如果让他提前公布自己的“预测”——明天股票的涨停，然后明天再去看股市，那么他公布的信息本身就会影响到股票涨停。如果在股票涨停之后再公布，那么大家会怀疑他有没有篡改自己的“预测”。而这里sealed envelop也就是解决这个问题的办法，让这个人先把预测结果写在纸上，放进信封里封好，然后交给第三方的公证机构保管。第二天股市收盘后，再让公证机构检查信封完好、打开信封、查看纸上的预测结果和实际涨停是不是一致即可。而使用digital commitment在这个问题上的做法是把预测结果计算出一个哈希值，然后把哈希值公布出去，因为有hiding的性质，所以大家没法通过哈希值知道预测结果。第二天收盘后公布预测结果，因为有collision resistance的性质，所以预测结果是没有篡改过的，否则和公布的哈希值就对不上了。在这个问题里，例如预测的是“涨的股票的名字”，那么因为股票一共就那么多支，输入空间并不是足够大，这样就不满足hiding的性质（大家可以遍历所有的股票取哈希去知道预测的是哪支股票涨）。这时候的解决办法可以是在输入后面加上一个随机数nonce，增大输入空间和输入的概率随机性,使得分布足够的均匀： H(x_∣∣_nonce)orH(x_∣∣_nonce) 在挖矿的时候，经常也是去算这个nonce。 puzzle friendly除了前面两个性质，比特币中的哈希函数还要满足puzzle friendly这个性质。该性质要求哈希值计算事先不可预测，仅仅根据输入很难预测出输出。例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。比如说，我们想得到一个哈希值这个哈希值前面K个位置都是0,总共是256位。 00000…XXXXXX 那么什么样的输入可以得到这样的输出？答案很难得到。该性质保证了比特币系统中，只能通过“挖矿”获得比特币。也就是说，该性质保证了工作量证明(POW)机制可以运行下去【“挖矿难，但验证易”】。在比特币系统中采用SHA-256哈希函数。比特币挖矿的过程就是去找一个随机数nonce，这个nonce和区块的块头里的其它信息合并在一起作为输入，取哈希值，所得哈希值要小于等于某个指定的阈值： H(block,header)≤target 注意，nonce不是区块块头以外的东西，它是其中的一个域，但是可以人为设置。挖矿的过程就是不停的去试nonce，使得整个块头部分取哈希小于等于target。有了puzzle friendly这个性质，使得比特币挖矿的过程没有捷径可言，只能不停的去试大量的nonce才能找到符合要求的解，所以才能用来用作工作量证明（proof of work,POW）。这个puzzle friendly和最前面的collision resistance有一定的联系，但不是完全一样。那个是无法去人为制造哈希碰撞，而这个是无法去人为构造符合特定特征的哈希值。虽然找到一个符合要求的nonce很难，但一旦找到之后，将它发布出去以后，其他人要验证这个nonce是不是符合要求是很容易的，只要算一次哈希值再和target比较一下就可以了。 三、签名 比特币中账户管理在第三方中心化系统中，账户开通依赖于第三方。但去中心化的比特币系统中，很明显不能进行“申请账户”。在比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对。公钥和私钥的应用保证了“签名”的应用。当在比特币网络中进行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。也就是说，只有拥有私钥，才能将该账户中的比特币转走。在比特币系统中，很难通过生成大量公私钥对来获取他人私钥 两种加密体系 对称加密体系最早的加密体系是对称的加密体系（symmetric encryption algorithm）。如两方进行通信，商量好一个密钥（encryption key），发送方使用密钥加密，接收方使用密钥解密。因为加密解密用的是用一个密钥，所以这是对称的加密体系。这种方式假设了存在某种安全的渠道，能够把密钥分发给通讯双方，这是对称加密体系的一个弱点。 非对称加密体系非对称的加密体系（asymmetric encryption algorithm）不再像对称加密那样使用一个密钥，而是使用一对密钥，即公钥和私钥，加密用的是公钥，解密用的是私钥。例如A要发信息给B，那么使用B的公钥对信息进行加密，B收到信息后用B自己的私钥进行解密就能得到原来的信息。也就是说加密和解密用的都是接收方的公钥和私钥。这样做的好处是公钥是不用保密的，可以告诉所有人，有的人主页上就有PGP public key。只有私钥是要保密的，但是私钥只需要保存在本地就可以了，不用传递给任何人，这样就避免了传输密钥过程不安全的问题。要回复对方再用对方的公钥加密，始终都不需要知道其他人的私钥，这就解决了对称加密体系中密钥分发不安全（不方便）的问题。 比特币中的签名加密货币是不加密的，前面学的非对称加密的公钥和私钥在比特币系统中就是用来做签名的。比如A要向B转账，即A在区块链上发起一个交易，所有交易是公开的，但大家怎么判断这个交易确实是A发起的，而不是别人冒名顶替的，这就需要A用户用自己的私钥对交易进行签名。其他用户拿到签名和交易信息后，可以用A的公钥去验证签名的正确性。签名用的是私钥，验证签名用的是公钥。都是同一个用户的公钥和私钥。生成公钥私钥的过程是随机的，但要求选取一个好的随机源，否则前面的分析就不成立了（就有不足够小的可能生成重复的公钥私钥对）。比特币中使用的签名算法不仅在生成公钥私钥对时有好的随机源，在之后每次签名的时候也要有好的随机源。如果签名时使用的随机源不好，就有可能泄露私钥。比特币系统中的签名，一般是先对message取一个哈希，然后再对哈希值签名。","link":"/2023/08/01/01BTC-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"02BTC-数据结构-区块链系统实现","text":"Hash pointer（哈希指针） 指针 在程序运行过程中，需要用到数据。最简单的是直接获取数据，但当数据本身较大，需要占用较大空间时，明显会造成一定麻烦。因此，可以引入指针这一概念。当需要获取数据时，只需要按照指针所给的地址，去对应的位置读取数据即可，这样大大节省了内存空间。:::info区块链结构本身为一条链表，节点为区块。而传统链表实现，便是通过指针将各个节点串联起来而称为最终的链。如下便是我们最常见的一个链表：但在区块链系统中，并未采用指针，而是使用了哈希指针::: 哈希指针 如下图对于该节点，我们可以看到有两个指针指向这个节点（实际上为一个），其中P为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。:::info在比特币中，其最基本的数据结构便是一个个区块形成的区块链。::: 区块链与链表区别：哈希指针代替普通指针 如图为一个简单的区块链。其中，每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。需要注意的是，本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。:::info如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。::: Merkle Tree(默克尔树)Merkle Tree是比特币系统中又一个重要的数据结构首先，回顾一下Binary Tree(如果不懂请自行复习数据结构)。Merkle Tree和Binary Tree的区别有哪些？ Merkle Tree用哈希指针代替了普通指针&lt;br /&gt;上图即为一个简单的Merkle Tree，其中A、B、C、D为数据块。可见，A和B各有一个哈希值，将其合并放在一个节点中，C和D同样操作，而后，针对得到的两个节点分别取哈希，又可以得到两个新的哈希值，即为图中根节点。实际中，在区块块头中存储的是根节点的哈希值（对其再取一次哈希）。如视频中图片：该数据结构的优点在于：只需要记住Root Hash（根哈希值），便可以检测出对树中任何部位的修改。例如，所绘制Merkle Tree中节点B发生了改变，则对应的第二层第一个节点中第二个哈希值便也会发生改变，进而根节点中第一个哈希值也会发生改变，从而导致根哈希值也发生了改变。:::info在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过Merkle Tree的形式组织在一起。区块本身分为两部分（块头和块身），在块头中存在有根哈希值（没有交易的具体信息），块身中存在交易列表。::: Merkle Tree的实际用途Merkle Tree可以用于提供Merkle Proof。关于Merkle proof，需要先了解比特币系统中节点。比特币中节点分为轻节点和全节点。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。:::info为什么要分轻节点和全节点？因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容即可。:::当需要向轻节点证明某条交易是否被写入区块链，便需要用到Merkle proof。我们将交易到根节点这一条路径称为Merkle proof，全节点将整个Merkle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。:::info思考：是否存在不安全的情况？如下图我们要验证B，但是H(1)和H(4)都是全节点提供的。全节点可否修改B，通过H(1)调整，使得修改过后的H(1)和轻节点计算出的H(2)一起取得哈希仍然为H(3)？实际上，这种情况为人为制造哈希碰撞。由于哈希函数的collision resistance性质，这种情况是不会发生的。从而，保证了系统的不可篡改性。同时，这样一个Merkle Proof的事件复杂度为O(log n),非常高效【证明交易存在】。如果要证明交易不存在，如果不对叶节点规定排序顺序，没有一个效率较高的方法证明不存在。在比特币系统中，没有相应的需求，所以在比特币系统中并没有对Merkle Tree进行排序。:::","link":"/2023/08/02/02BTC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"03 BTC-共识协议-区块链系统实现","text":"数字货币中经常出现的问题 双花攻击: 数字货币本身为带有签名的数据文件，可以进行复制。即：对用户来说，可以将同一货币花费两次。:::info修改：对货币添加唯一编号（不可篡改），每次支付向货币发行单位查询真伪。该方法每次交易都需要依赖于第三方机构来判断货币真伪且防止双花攻击。是一个典型的第三方中心化方案。现实中，我们通过支付宝、微信、信用卡等各种支付方式交易时，必然会依赖于第三方机构。由于这些第三方机构具有较高的可信度，有政府进行背书，所以可以采用这种方案。但是，很多场景下，并不存在这样一个可信赖的第三方机构。基于这个背景，以去中心化思想为核心的比特币系统便吸引了人们的注意力。::: 去中心化需要解决的问题 数字货币的发行由谁执行？如何发行？发行多少？什么时候发行？在传统中心化货币体系中，这些问题我们可以交给第三方机构（如：央行）。当引入去中心化思想后，系统中节点平等，交易不通过第三方，那么货币发行权的分配必然是一个需要解决的问题。:::info在比特币系统中由挖矿来决定货币发行权和发行量。::: 如何验证交易是否有效？如何防止双花攻击？同样，在传统中心化体系中，该问题的解决由第三方机构来完成。而剔除这一机构后，交易双方如何能够验证交易的有效性？如何防止系统中恶意用户作恶获取收益？这也是去中心化交易系统需要解决的问题。:::info该问题的解决，依赖于系统中维护的一个数据结构，记录货币的使用情况（是否被花过？被谁花过？）。该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。::: 案例说明如下，假定A获得铸币权，新发布了10个比特币（该交易称为铸币交易）。A将10个比特币转给了B(5个)和C(5 个)，A对该交易进行签名，同时该交易需要说明所花掉10个比特币来源（来自铸币交易）。之后，B将自己的5个比特币转给C(2个)和D(3个)，该交易需要B的签名，该交易需要说明所花掉的5个比特币来自于第二个交易中。然后，C将自己所拥有的全部7个比特币都转给E，并对该交易签名，可以发现该交易中C的比特币来源于两个交易中。这样就构成了一个简单的区块链。【红色部分为比特币来源】:::info需要注意的是，这里面有两种哈希指针。第一种为指向前面的区块（白色），使得各个区块形成链，第二种则是为了说明比特币的来源（红色）。说明比特币的来源并非凭空捏造，可以防止双花攻击。在进行交易时，需要付款人的签名和收款人的地址，在比特币系统中，该地址即为收款人的公钥的哈希。可以将其视为银行账 户，根据此进行转账交易。（虽然公钥可以公开，但实际中更多公开的是公钥的哈希）在交易中，收款方需要知道付款方的公钥，从而验证A签名是否有效。即A需要提供自己的公钥，如果所提供公钥与铸币交易中。（实际上其他节点都需要知道付款方公钥，验证交易合法性）实际中A转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造A的公钥来“偷”走A的比特币。在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。在该图中，一个区块仅含有一个交易，实际中一个区块中包含多个交易，交易通过Markle Tree（详见比特币数据结构篇中）组织起来，在区块中存储。::: 比特币区块信息 block Header（区块宏观信息） block body(略) Version(版本协议) … Hash of previous block header（指向前一个区块指针） … Merkle root hash（默克尔树根哈希值） … target（挖矿难度目标阈值） … nonce（随机数） … 什么是挖矿(怎么获得记账权)简单的说挖矿就是通过输入一个随机值用固定工作量证明哈希函数求解一个目标哈希值 工作量证明函数(固定工作量证明哈希函数)比特币系统中使用的工作量证明函正是 SHA256。SHA 是安全散列算法（Secure Hash Algorithm）的缩写，是一个密码散列函数家族。这一组函数是由美国国家安全局（NSA）设计，美国国家标准与技术研究院（NIST） 发布的，主要适用于数字签名标准。SHA256 就是这个函数家族中的一个，是输出值为 256 位的哈希算法。到目前为止，还没有出现对 SHA256 算法的有效攻击。 区块(输入的一个随机值)比特币的区块由区块头及该区块所包含的交易列表组成。区块头的大小为 80 字节，由 4 字节的版本号、32 字节的上一个区块的散列值、32 字节的 Merkle Root Hash、4 字节的时间缀（当前时间）、4 字节的当前难度值、4 字节的随机数组成。区块包含的交易列表则附加在区块头后面，其中的第一笔交易是 coinbase 交易，这是一笔为了让矿工获得奖励及手续费的特殊交易。区块的大致结构如图所示：拥有 80 字节固定长度的区块头，就是用于比特币工作量证明的输入字符串。因此，为了使区块头能体现区块所包含的所有交易，在区块的构造过程中，需要将该区块要包含的交易列表，通过 Merkle Tree 算法生成 Merkle Root Hash，并以此作为交易列表的摘要存到区块头中。其中 Merkle Tree 的算法图解如下： 难度值难度值（difficulty）是矿工们在挖矿时候的重要参考指标，它决定了矿工大约需要经过多少次哈希运算才能产生一个合法的区块。比特币的区块大约每 10 分钟生成一个，如果要在不同的全网算力条件下，新区块的产生保持都基本这个速率，难度值必须根据全网算力的变化进行调整。简单地说，难度值被设定在无论挖矿能力如何，新区块产生速率都保持在 10 分钟一个。难度的调整是在每个完整节点中独立自动发生的。每 2016 个区块，所有节点都会按统一的公式自动调整难度，这个公式是由最新 2016 个区块的花费时长与期望时长（期望时长为 20160 分钟即两周，是按每 10 分钟一个区块的产生速率计算出的总时长）比较得出的，根据实际时长与期望时长的比值，进行相应调整（或变难或变易）。也就是说，如果区块产生的速率比 10 分钟快则增加难度，比 10 分钟慢则降低难度。这个公式可以总结为如下形式：复制代码 1新难度值 = 旧难度值 * ( 过去 2016 个区块花费时长 / 20160 分钟 ) 目标值(目标哈希值)工作量证明需要有一个目标值。比特币工作量证明的目标值（Target）的计算公式如下：复制代码 12345目标值 = 最大目标值 / 难度值其中最大目标值为一个恒定值：0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 目标值的大小与难度值成反比。比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值。我们也可以简单理解成，比特币工作量证明的过程，就是通过不停的变换区块头（即尝试不同的 nouce 值）作为输入进行 SHA256 哈希运算，找出一个特定格式哈希值的过程（即要求有一定数量的前导 0）。而要求的前导 0 的个数越多，代表难度越大。 工作量证明的过程我们可以把比特币矿工解这道工作量证明迷题的步骤大致归纳如下： 生成 Coinbase 交易，并与其他所有准备打包进区块的交易组成交易列表，通过 Merkle Tree 算法生成 Merkle Root Hash 把 Merkle Root Hash 及其他相关字段组装成区块头，将区块头的 80 字节数据（Block Header）作为工作量证明的输入 不停的变更区块头中的随机数即 nonce 的数值，并对每次变更后的的区块头做双重 SHA256 运算（即 SHA256(SHA256(Block_Header))），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。获得记账权 该过程可以用下图表示： 分布式共识可否各个节点独立完成区块链构建？很明显不行，各个节点独立打包交易，形成区块链，必然无法避免区块链内容不一致。从分布式系统角度来说，账本内容需要取得分布式共识，从而保证区块链内容在不同节点上的一致性。根据FLP不可能结论，在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。根据CAP Theorem（Consistency一致性、Availability可靠性、Partition tolerance容错性），任何一个分布式系统 中，最多只能满足其中两个性质。分布式共识中协议Paxos 可以保证Consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。 比特币共识协议:::info背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。想法1：直接投票某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。更大的一个问题—— membership。如果是联盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击）。所以，这种简单的投票方案也是不可行的。:::比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。[H(block header)&lt;=target]当某个节点找到符合要求的nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。:::info猜想: 会不会合法区块被拒绝？如图所示。发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。这样，也就会导致合法区块被拒绝分叉攻击如图所示，A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。此外，区块链正常运行场景下，也可能会发生分叉。当两个节点同时获得记账权时，会有两个等长的合法链。在缺省情况下，节点接收最先听到的区块，该节点会沿着该区块继续延续。但随着时间延续，必然有一个链胜出，由此保证了区块链的一致性。（被扔掉的区块称为“孤儿区块”）可见，依赖于算力竞争，有效的防止了“女巫攻击”。::: 比特币激励机制:::info为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？:::比特币系统设计之初便考虑到了这个问题，那就是引入激励机制。比特币通过设置出块奖励来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。:::info比特币系统设计规定，起初每个区块可以获得50个比特币，但之后每隔21万个区块，奖励减半。:::但是这样就可以了吗？？？区块中保存交易记录，那么，会不会存在节点只想发布区块而不想打包交易？中本聪在设计该系统时，引入了交易费。在一个区块中，其输入&gt;=输出，差值便是给区块所属节点的手续费。","link":"/2023/08/02/03-BTC-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"03 BTC-系统实现-区块链系统实现","text":"UTXO(Unspent Transaction Output尚未被花掉的交易输出)区块链是一个去中心化的账本，比特币采用了 **基于交易的账本模式 **。然而，系统中并无显示记录账户包含比特币 数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为 **UTXO(Unspent Transaction Output尚未被花掉的交易输出) **的数据结构。:::info如图，A转给B五个BTC，转给C3个BTC，B将5个BTC花掉，则该交易记录不保存在UTXO中，C没有花掉，则该交易记录保存在UTXO中:::UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出。:::info为什么要维护这样一个数据结构？？？为了防范“双花攻击”，判断一个交易是否合法，要查一下想要花掉的 BTC是否在该集合中，只有在集合中才是合法的。如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么根本不存在，要么已经被花过。所以，全节点需要在内存中维护一个UTXO，从而便于快速检测double spending（双花攻击）。:::每个交易会消耗输出，但也会产生新的输出。:::info如图，A转给B5个BTC，之后B将其转给D，则UTXO中会删掉A-&gt;B这一交易记录，同时会添加B-&gt;D这一交易记录。假如有人收到BTC转账，但一直不花，那么这个信息会一直保存在UTXO中。这种情况可能是该用户不想花这些BTC(如：中本聪) ，也有可能是忘记了私钥导致无法花掉。所以，UTXO是逐渐增大的，但该数据目前来说，一个普通的服务器硬盘中是可以完全保存这些数据的。:::每个交易可以有多个输入，也可以有多个输出，但输入之和要等于输出之和（total inputs = total outputs）。存在一些交易的total inputs 略大于 total outputs，这部分差额便作为交易费，给了获得记账权的节点。在公开课笔记3中最后提及到“区块中保存交易记录，如果仅仅设置出块奖励，那么，会不会存在节点只想发布区块获得出块奖励而不想打包交易？” 因此，BTC系统设计了Tranction fee（交易费），对于获得记账权节点来说，除了出块奖励之外，还可以得到打包交易的交易费。但目前来说，交易费远远小于出块奖励。等到未来出块奖励变少，可能区块链的维护便主要依赖于交易费了。:::infoBTC系统中每21万个区块，BTC出块奖励减半。根据下图计算，基本上出块奖励每4年减半。比特币是基于交易的模式，与之对应，还有一种基于账户的模式（如：以太坊）。基于账户的模式要求，系统中显示记录账户余额。也就是说，可以直接查询当前账户余额是多少货币。可以看到，比特币这种模式，隐私性较好，但其也付出一定代价。在进行交易时，因为没有账户这一概念，无法知道账户剩余多少BTC,所以必须说明币的来源（防止双花攻击）。而基于账户的模式，则天然地避免了这种缺陷，转账交易就是对一（多 个）账户余额的数字减和另一个（多个）账户余额的数字::: BTC系统中具体的区块信息如下图所示，为一个区块的信息（取自视频中截图，源自blockchain.info）:::info什么是挖矿？可以看到，区块哈希与前一区块哈希都是以一长串0开头的，挖矿本身就是尝试各种nonce，使得产生的区块哈希值小于等于目标阈值。该目标阈值，表示成16进制，就是前面含有一长串的0:::北京大学肖臻老师《区块链技术与应用》公开课笔记5——BTC具体实现篇.pdf","link":"/2023/08/03/04-BTC-%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"05 BTC-挖矿-区块链系统实现","text":"全节点和轻节点之前提到，由于硬件限制，BTC系统中分为轻节点和全节点，下表阐述了全节点和轻节点的区别在比特币网络中，大多数节点都是轻节点。如果只是想进行转账操作，不需要挖矿，就无需运行一个全节点。在挖矿 过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，在本地重新组装一个指向最 后这个新合法区块的候选区块，重新开始挖矿。:::info 这样是不是有些可惜？之前花费好多资源，全部白挖了。 实际上并不可惜。之前文章中提及，挖矿本身具有无 记忆性，前面无论挖多久，对后续继续挖矿没有影响。 比特币系统如何安全性？ 一是密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账 户上BTC转走。（前提：系统中大多数算力掌握在好人手中） 二是共识机制：保证了恶意交易不被系统承认。::: 挖矿设备演化目前，挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。 普通CPU -&gt; GPU -&gt;ASIC芯片 （挖矿专用矿机）:::info实际上，挖矿本身就是计算，对于普通计算机来说，挖矿过程中大多数内存、硬盘、CPU中大多数部件（用到 指令较少）等都是闲置的，如果用普通计算机专门用于挖矿是根本不划算的。随着挖矿难度提高，用通用计算 机挖矿很快变得无利可图。 所以，挖矿设备转入第二代——GPU(主要用于大规模并行计算，如：深度学习)。 但是，用GPU挖矿，仍然有一定浪费(GPU为通用并行计算设计，挖矿仍然有很多部件闲置。例如：浮点数运算 部件，挖矿过程只使用整数操作，该部分部件根本不会用到)。:::GPU价格上涨，仅仅是深度学习火热导致的吗？实际上，很多GPU被用于了挖矿。:::info当然，目前GPU挖矿也已经不划算了（目前一些新开发货币仍然用GPU挖矿）。所以，开始进入第三代设备： ASIC芯片（专门为挖矿设计的芯片），这种芯片专门为挖矿设计，只能用于特定币种的挖矿。 但ASIC芯片设 计、流片流程很长，假如BTC价格剧烈变化，前期投入很可能会血本无归。所以，ASIC芯片需要提前预订。假 如BTC系统中，算力突然很猛烈增加，一般是一个大的厂商生产出新的ASIC矿机。:::ASIC芯片只能用于挖矿，一旦其过时，便完全作废。思考：ASIC芯片的出现是好事吗？ 很明显，ASIC芯片并不是普通人可以参与的，一定程度上提升了挖矿的门槛，违 背了比特币系统去中心化的初衷。理想状态下，所有人用CPU挖矿，这样只要有一台家用计算机便可以参与挖矿。当 然，后续有一些货币便考虑到了这个问题，设计了抗ASIC芯片化的解决方案，后续介绍以太坊时会对这种方案进行介 绍。 但反过来想，如果大家都用ASIC矿机挖矿，如果有人想要颠覆BTC系统，必然会导致BTC价格跳水，从而导致其 所购买ASIC矿机作废，投入成本血本无归。所以，很多人反倒认为ASIC芯片出现，一定程度上并不是坏事。 大型矿池出现:::info挖矿另一个趋势便是大型矿池的出现。对于单个矿工来说，即使使用了ASIC矿机，其算力在整个系统中仍然只 占据很少一部分，即使从平均收益看有利可图，但收入很不稳定。 此外，单个矿工除挖矿还要承担全节点其他 责任，造成了算力的消耗。:::因此，为了解决这些问题，便引入了矿池的概念。 矿池的架构如下图，通常是一个全节点驱动多台矿机。矿工只需 要不停计算哈希值，而全节点其他职责由矿主来承担。ASIC芯片只能计算哈希值，不能实现全节点其他功能。此外， 矿池出现解决了单个矿工收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。所以，必须涉及如何分配的问题。如果分配不公平，挖矿的动力就会减少。矿池一般具有两种组织形式。1.类似大型数据中心（同一机构），集中成千上万矿机进行哈希计算。2.分布式。矿工 与矿主不认识(不同机构)，矿工与矿主联系，自愿加入其矿池，矿主分配任务，矿工进行计算，获得收益后整个矿池 中所有矿工进行利益分配。 矿池利益分配方法假使第二种情况，矿工来源于五湖四海（非同一机构），收益应该如何分配？ 思路一：平均分配，所有人平分出块奖励。 这一点有些类似我国某段历史时期，大家一起”吃大锅饭”，会导致 某些矿工懈怠，不干活（挖矿要费电，需要成本）。 所以，这里也需要进行按劳分配，需要一个工作量证明的 方案。如何证明每个矿工所作的工作量呢？ 思路二：降低挖矿难度（可行方案）。 假设原本挖矿难度要求，计算所得126位的哈希值前70位都必须为0，现 在降低要求，只需要前60位为0，这样挖矿会更容易挖到。当然，这个哈希是不会被区块链所承认的，我们将其 称为一个share，或almost valid share。矿工每挖到一个share，将其提交给矿主，矿主对其进行记录，作为矿 工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的share数量进行分配。 因 为每个矿工尝试的nonce越多，挖到矿的可能性越大，所能得到的share也会越多，所以这种方案作为工作量证 明方案是可行的。 :::info1.思考一：有没有可能，某个矿工平时正常提交share，但真正挖到区块后不提交给矿主而是自己偷偷发布出去，从而避免他人分走挖矿所得到的出块奖励？事实上，这种情况是不可能的。因为每个矿工挖矿任务是矿主分配的。矿主组装区块，交给矿工计算，而区块中铸币交易的收款人地址是矿主，如果矿工修改该地址，计算的nonce值也会作废。2.思考二：如果矿工自己刚开始就自己偷偷组装一个区块，自己挖矿，这样就类似于其脱离了该矿池。因为其自己所组织的区块不会被矿主所认可，其提交的share也不会被认可，也就得不到分配的收益。3.思考三：有没有可能矿工捣乱？平时提交share，等挖到后扔掉区块，不提交？这种可能是有的，如果矿工本身仅仅想捣乱，是可以这么做的。但扔掉区块后，对其本身来说，也没有相应的奖励获得，看似是损人不利己的情况。但是，矿池之间存在竞争关系。有可能为了打击竞争对手，会派出矿机加入竞争对手矿池挖矿，从而起到搞破坏的作用。即只参与其他矿工挖矿分红，自己挖到的区块却丢掉不给他人分。 ::: 关于矿池的一些统计数据（图片源自肖老师课程视频）图1：矿池在各个国家分布比例图（2018年） 可见，中国所占矿池比例远远超过其他国家。图2：2014年图单个矿池算力分布比例图,这个时间，存在一个矿池(GHash.IO)算力比例占据全部算力一半以上，当时引起了恐慌(一个矿池就可以发动51攻 击)。之后，该矿池主动降低了矿池算力（化整为零，实际上仍然存在发动51攻击能力），避免动摇人们对比特币信 心。图3：2018年图单个矿池算力分布比例图 表面看上去是安全的，但实际实上某个机构如果有超过50%算力，其必然不会将其放入一个矿池中。而是将其分散隐藏，真正需要发动攻击时候再集中起来发动51攻击（注意：矿工转换矿池是很容易的）。:::info由这些数据可以得知，矿池本身对BTC系统带来了较大威胁。某个恶意用户如果想发动攻击，以前需要自己达 到51%算力，现在自己只需要作为矿主，只需要很少一部分算力就可以了。只要能够吸引到足够多的不明真相 的矿工，便可以用较低成本实现51攻击。 当然，矿主经验管理矿池，也需要收取一定比例(出块奖励、交易费) 作为管理费用。如果恶意者想要攻击系统，会将管理费降低甚至赔本吸引足够多矿工加入。这便使得发动51% 攻击变得容易了起来。::: 51%算力矿池可以发动哪些攻击 分叉攻击 对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。:::info矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被 利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。 此外，51%攻击只是一个概率问 题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。::: 封锁交易（Boycott） 假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发 布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。:::info像不像即当裁判又当运动员？”堂下何人状告本官“？::: 盗币（将他人账户BTC转走） 这个是不可能的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签 名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。 矿池出现的优劣优点：解决了矿工收入不稳定的问题，减轻了矿工的负担。 缺点：威胁到了区块链系统的安全，使得51%攻击变得 容易起来。","link":"/2023/08/04/05-BTC-%E6%8C%96%E7%9F%BF-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"title":"区块链中的共识协议-区块链基本概念","text":"今天我们关注区块链中的核心问题：作为分布式账本，每个参与者都维护了一份数据，那么如何确认记账权，最终的账本以谁为准呢？ 区块链的共识区块链是一种去中心化的分布式账本系统，区块链的共识问题实际上是来源于分布式系统的一致性问题。共识（Consensus）故名思义，共同的认识，共识问题研究的是多个成员如何达成一致，典型的比如投票选举。共识机制在区块链中扮演着核心的地位，共识机制决定了谁有记账的权利，以及记账权利的选择过程和理由。不同的虚拟货币采用共识机制也不同，常见的共识机制有 POW、POS、DPOS等。我们前面提到 CAP 中的 C 是 Consistency（一致性），Consistency 和 Consensus 有什么区别呢？Consistency 侧重的是内容在时间顺序上的一致和统一，而 Consensus 则是指由许多参与者对某项内容达成共识，所以一般把 Consistency 翻译为“一致性”，把 Consensus 翻译为“共识”。 拜占庭将军问题前面的课程中我们已经分享了几个经典的一致性算法，如果把共识机制延伸到分布式系统中，就是系统需要有一个主进程来协调，系统的所有决定都由主进程来达成一致性。到了区块链中，由于区块链是一种去中心化的分布式系统，所以区块链中是没有类似于团队里的领导，以及分布式系统中的 master 角色，这样就需要有某种共识机制，以便保证系统一致性。一般在网络通信中，把节点故障，也就是信道不可靠的情况称为“非拜占庭错误”，恶意响应，也就是系统被攻击，传递错误消息称为“拜占庭错误”。为什么叫拜占庭错误呢？实际上是来自于一个故事模型：拜占庭帝国就是中世纪的土耳其帝国，拥有巨大的财富，周围 10 个邻邦垂诞已久，但拜占庭高墙耸立，固若金汤，没有一个单独的邻邦能够成功入侵。任何单个邻邦入侵都会失败，同时也有可能自身被其他 9 个邻邦入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。然而，如果其中的一个或者几个邻邦本身答应好一起进攻，但实际过程出现背叛，那么入侵者可能都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国，这就是拜占庭将军问题。（图片来自维基百科）在拜占庭问题里，各邻国最重要的事情是：所有将军如何能过达成共识去攻打拜占庭帝国。拜占庭将军问题核心描述是军中可能有叛徒，却要保证进攻一致，由此引申到计算机领域，发展成了一种容错理论：一群将军想要实现某一个目标，比如一致进攻或者一致撤退，单独行动是行不通的，必须合作，达成共识；由于叛徒的存在，将军们不知道应该如何达到一致。其实，拜占庭将军问题（Byzantine Generals Problem）和我们前面提到的 Paxos 算法、逻辑时钟等，都是由 Leslie Lamport 提出的。Lamport 可以说是分布式系统的奠基人之一，由于在分布式领域的一系列贡献，Lamport 获得了 2013 年的图灵奖。拜占庭将军问题和我们今天要讨论的记账权有什么联系呢？在记账权的归属中，关键的是如何避免恶意共识的出现，也就是错误的记账，类似如何处理拜占庭将军中的叛徒。比特币是区块链技术最广泛的应用，在比特币中如何决定记账权呢？答案就是 POW 机制，接下来我们分析 POW 工作量证明机制。 POW 工作量证明PoW（Proof of Work，工作量证明）被认为是经过验证最安全的拜占庭解决机制，最早是用来防垃圾邮件的，典型的就是 Google 邮箱的反垃圾邮件系统。Google 邮箱强制要求每一个给 Google 服务器发送邮件的发送者，必须先完成一定量的计算工作，造成一小段时间的延迟，比如延迟 1 秒，如果是正常的邮件发送，这个时间是可以接受；如果是广告邮件发送者，因为要进行大量的发送工作，这种无价值的计算是无法忍受的。 挖矿的由来挖矿是比特币系统中一个形象化的表达，那么挖矿是怎么来的呢？比特币挖矿是将一段时间内比特币系统中发生的交易进行确认，并记录在区块链上形成新区块的过程，由于需要竞争记账权，利用计算机去计算 Hash 数值，随机碰撞解题，这个过程就是挖矿。换句话说，就是比特币系统出一道数学题，大家抢答最优解，挖矿就是记账的过程，矿工是记账员，区块链就是账本。 比特币的 POW 实现比特币中的 POW 实现，是通过计算来猜测一个数值（Nonce），得以解决规定的 Hash 问题，下面是比特币的区块结构，可以看到区块头有个随机数字段，这个就是 Nonce 值：中本聪在比特币系统中设置了一道题目，通过不断调节 Nonce 的值，来对区块头算 Hash，要求找到一个 Nonce 值，使得算出来的 Hash 值满足某个固定值。具体的 Hash 方法一般是使用 SHA256 算法 ，你可以查看这个小工具来测试 https://tool.oschina.net/encrypt?type=2。我们来简化一下计算过程，假设第 100 个区块给出的区块值是下列字符串，最早计算出该字符串的节点可以获得比特币：f7684590e9c732fb3cf4bf0b8e0f5ea9511e8bbaacb589892634ae7938e5700c由于 Hash 算法是一个不可以逆的算法，没法通过具体的 Hash 值倒推出原文，这样每个节点只能采用穷举的方法，也就是选择各种字符串，比如开始的 a、b、c、1、2、3、…，不断的尝试。比特币系统自身会调节难度，控制解题的时间，一般来讲，约每 10 分钟挖出一个区块，在这 10 分钟内，计算机只能不停地去计算，去试各种字符串。这个过程实际上是考验各个节点的服务器性能，也就是算力。如果你算力非常强大，有几万台服务器，可以很快得到 Nonce 值，也就是正确答案：lagou，对应 Hash 值和题目要求一致。接下来你就可以把这个 Nonce 值放在结构体里，通过 P2P 网络广播出去，其他的系统节点收到后，发现这个 Nonce 值是合法的，能满足要求，会认为你挖矿成功。由于解出了题目，你会获得系统对应的比特币奖励，以及本区块内所有交易产生的手续费。其他节点发现有人已经算出来了，就会放弃本次计算，然后开启下一个区块的题目，去寻找下一个区块头的 Nonce 值。作为落地的最大区块链系统，比特币的区块信息一直在动态生成。下面这张截图记录了比特币最近的区块信息，区块信息来自 https://www.blockchain.com/，你也可以点击链接查看最新的区块高度。 区块链分叉和 51% 攻击Hash 问题具有不可逆的特点，主要依靠暴力计算，谁的算力多，谁最先解决问题的概率就越大。当掌握超过全网一半算力时，就能控制网络中链的走向，这也是所谓 51% 攻击的由来。前面我们说过，因为区块链中每个节点都可以参与记账，系统中可能出现链的分叉（Fork），最终会有一条链成为最长的链。但是在现实社会中，牵扯到参与各方巨大的利益关系，算力之间的博弈往往并没有那么简单，以比特币为例，已经分裂出了 BCH（比特币现金）、BTG（比特币黄金）等分叉币。 POW 机制优缺点POW 的优点有很多，POW 是第一个完全实现去中心化共识算法的，并且节点自由进出，容易实现，由于对算力的高要求，破坏系统花费的成本也巨大。POW 机制的缺点也是显而易见的，最大的就是浪费能源，巨大的算力被浪费在了无尽的挖矿行为中，并且本身并不产生任何价值。这也是区块链被很多人指责的一点，浪费了大量的能源，收获的仅仅是一堆无价值的数据存储，换个角度来思考，这也说明了在去中心化的场景下，实现信任是多么的困难。另一方面也可以看到，大量的数字货币矿场都是建设在西南地区的深山中，利用当地价格低廉的电力资源，或者就直接和发电站建设在一起。 其他共识方法除了 POW 机制，还有其他的共识方法，典型的就是 POS 和 DPOS 等。 POS 权益证明POS（Proof of Stake，权益证明）类似现实生活中的股东大会机制，拥有股份越多的人拥有越多的投票权，也就越容易获取记账权。POS 是通过保证金来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费。提供证明的保证金越多，则获得记账权的概率就越大，合法记账者可以获得收益。著名的数字货币 ETH（以太坊），就在共识算法中采用了 POS 机制。 DPOS 委托权益证明采用 DPOS（Delegated Proof of Stake，委托权益证明）机制的典型代表是 EOS，如果说 POS 类似股东大会，比较的是谁持有的股份多，那么 DPOS 类似于公司董事会制度，在 DPOS 共识制度下，会选出一定数量的代表，来负责生产区块。 总结区块链可以说是分布式系统最广泛的应用之一，今天介绍了区块链共识问题的由来、拜占庭将军问题，以及典型的 POW 解决机制。","link":"/2023/07/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"区块链中的数据结构-区块链基本概念","text":"哈希链表hash pointers：与普通的指针的区别：普通的指针指向所在内存的起始地址，但是hash 指针除了保存起始地址之外，还会保存指向内存的hash值，这样就可以很容易的验证这块内存（这个区块）是否被篡改。tamper-evident log : 防篡改log，就是利用了区块链中后一个区块中会保存前一个区块中的hash值。牵一发动全身！ merkle treeMerkle tree ： 典型的属于以时间换空间。与链式的区块一样，其中root hash也能够检测出这个区块链是否被篡改。可以用logn的时间定位出那个区块被修改.全节点：包含真正交易数据的节点。轻节点：只包含hash header的节点。merkle proof （proof of membership） : 证明merkle tree中包含了某个交易。比如，某个全节点A向一个轻节点B转了一笔账，所以A需要向B发送一个merkel tree，然后B就可以来证明这个merkle tree是否是正确的。时间复杂度O（log n） （proof of no membership） :遍历全部的区块，O(n)。但是，如果所有的区块是按照hash值排序的话（sorted merkle tree），那么就可以利用O（log n）的时间来验证某个交易是否在这个merkel tree中。 备注： hash 指针不能够有环。否则就会造成循环依赖，造成死锁了。","link":"/2023/07/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"哈希函数-区块链基本概念","text":"概念哈希函数，又称散列算法，是一种从任何一种数据中创建数字 “指纹” 的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（或哈希值）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。 特性 1.哈希碰撞: 两个不同的值（比如张三、李四的学号）经过hash计算后，得到的hash值相同，后来的李四要放到原来的张三的位置，但是数组的位置已经被张三占了，导致冲突。如果两个输入串的hash函数的值一样，则称这两个串是一个碰(Collision)。既然是把任意长度的字符串变成固定长度的字符串，所以必有一个输出串对应无穷多个输入串，碰撞是必然存在的(暴力破解:遍历所有输入的可能性,实际工作中是不太可能实现的,)。用途: 用于检测对数据的篡改。 单向不可逆性:，x推出H（x），但是反推没有法子（单向性），也就是说，哈希值没有泄露输入的x的信息。也就是说x的信息被隐藏了起来，这也就就是隐藏性。(理论上是可以的,同样蛮力求解,如果输入的空间足够大,那么可能性就更低),性质的前提是：（1）输入空间较大；（2）输入的分布比较分散。 **digital commitment : **什么是digital equivalent of sealed envelope呢？我们先理解一下现实生活中sealed envelope的应用：假如有一个人他说可以准确预测股市，怎么验证他的预测是否准确呢？一种方法是这个人前一天在电视台公布自己的预测结果，xxx股票第二天涨停等，第二天收盘看一下xxx股票是否涨停即可。这个方法存在一些问题，即如果这个人是股神，他提前公布的预测意见可能会影响股市走势，从而导致预测与实际结果相同或相悖。即预测结果不能提前公开。但如果等第二天收盘之后再公开预测结果，又怎么能知道这个预测结果有没有被篡改，这个预测结果是不是提前一天做出来的？这个时候就用到了sealed envelope，即把这个预测结果提前写在一张纸上放在信封里封号，信封交给第三方公正机构保管，第二天再打开验证。那么电子世界里的digital sealed envelope呢？即预测结果x，H(x)可以公布出去，因为hiding性质的存在，所以从H(x)并不知道x，并不会影响市场。第二天收盘后再公布x，因为collision resistance，所以x不能篡改，如果改了就和H(x)对不上了。注意：实际操作中还是要保证输入空间足够大，分布比较均匀。常用的方法是输入拼接一个随机数nonce再一起取hash，即H(x||nonce)。 （3）puzzle friendly:指哈希值的计算事先不可预测，如果想hash值落在某个范围内，只能一个一个试，无法知道哪个输入更有可能在这个范围内，没有捷径。挖矿的过程就是找随机数nonce，使得H(block header的nonce)&lt;=target，落在target space里。puzzle friendly也就是说挖矿没有捷径，只能大量的试才能找到符合要求的nonce,所以可以用来做工作量证明。 注意：一旦有人找到了nonce，其他人验证则很容易，只需要算一次hash即可。挖矿很难，但验证很容易，即difficult to solve，but easy to verify,比特币中用到的hash函数是SHA-256（secure hash algorithm） 签名 日常生活中的开户方式，带上证件去银行办理开户。但是比特币去中心化，没有银行这样的账户管理机构，即需要用户自己开户。开户过程很简单，就是创立公钥、私钥对。即（public key，private key）共私钥对来源于密码学中非对称加密体系（asymmetric encryption algorithm），在此之前，最早使用的对称加密体系。什么是对称加密体系呢？比如A要发信息给B，考虑到可能被窃听，所以AB商量了一个密钥（encryption key），A用密钥加密后发给B，B收到后再用密钥解密。这种方法的前提是有某种安全的渠道能把密钥分发给通讯双方，密钥显然不能在网上传输。即对称加密体系的缺点就是密钥分发不方便。非对称加密体系避免了这一问题，使用一对密钥（公+私）。加密用公钥，解密用私钥。比如A要发信息给B，A用B的公钥加密后发给B，B再用自己的私钥解密。加密的公钥无需保密可以告诉所有人，私钥需保密，但私钥保存在本地即可，无需告诉对方。大家都不需要知道对方的私钥。这就解决了密钥分发不方便的问题。在比特币系统中创建账户，在本地产生一对（public key，private key），公钥相当于银行账号，别人知道就可以给你转账；私钥相当于银行密码，知道密码就可以转走钱。比特币系统其实是不加密的，信息是公开，那么要公钥、私钥有什么用？实际上是用来签名的。比如A转给B 10个比特币，把这个交易发布在区块链上，别人如何知道这个交易是A发起的呢？会不会是别人想转走A的钱呢？即A可以用自己的私钥对这个交易签名，其他人收到后再用A的公钥验证签名来确定交易是否正确。既然每个人都是独立的产生公私钥对，万一两个人的公私钥对完全相同怎么办？是不是就能把别人账号的比特币偷走？理论上是可以不停产生公私钥，但实际上是不可行的，如果是256位hash值，即使使用超级计算机每天试试试，产生相同公私钥对的概率也是微乎其微的，可忽略不计。注意：这里假设产生公私钥对时要有好的随机源，比特币中签名算法不光要求生成是要好的随机源，签名时也要好的随机源。 比特币中，我们先对message取hash值，再对hash值签名","link":"/2023/07/27/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"电子货币如何解决多重支付问题-区块链基本概念","text":"双花攻击（double spending attack） 首先交易之前A需要知道给谁转账,所以A需要知道B,C公钥的哈希(类似于转账地址,公钥是公开的) 。 输出方需要得到的信息 A的公钥的hash，也就是之前币的来源的那个区块的输出的hash值,这样就能指向币的来源(这样接防止了,如果有A’来冒充A,他给出自己的说是A的公钥,用自己的私钥进行签名,进行骗钱的操作),B知道了A公钥的哈希值,那么就可以在之前的校验中找到作为输出方A的公钥哈希值,看这两个哈希值是否对的上。 A的公钥,进行A私钥签名验证(是在交易中A自己给出来的)","link":"/2023/07/28/%E7%94%B5%E5%AD%90%E8%B4%A7%E5%B8%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8D%E6%94%AF%E4%BB%98%E9%97%AE%E9%A2%98-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"工作量证明-区块链基本概念","text":"1. 起源工作量证明 (Proof Of Work，简称 POW)，简单理解就是一份证明，用来确认你做过一定量的工作。监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。比如现实生活中的毕业证、驾驶证等等，也是通过检验结果的方式（通过相关的考试）所取得的证明。工作量证明系统（或者说协议、函数），是一种应对拒绝服务攻击和其他服务滥用的经济对策。它要求发起者进行一定量的运算，也就意味着需要消耗计算机一定的时间。这个概念由 Cynthia Dwork 和 Moni Naor 1993 年在学术论文中首次提出。而工作量证明（POW）这个名词，则是在 1999 年 Markus Jakobsson 和 Ari Juels 的文章中才被真正提出。哈希现金是一种工作量证明机制，它是亚当·贝克（Adam Back）在 1997 年发明的，用于抵抗邮件的拒绝服务攻击及垃圾邮件网关滥用。在比特币之前，哈希现金被用于垃圾邮件的过滤，也被微软用于 hotmail/exchange/outlook 等产品中（微软使用一种与哈希现金不兼容的格式并将之命名为电子邮戳）。哈希现金也被哈尔·芬尼以可重复使用的工作量证明（RPOW）的形式用于一种比特币之前的加密货币实验中。另外，戴伟的 B-money、尼克·萨博的比特金（Bit-Gold）这些比特币的先行者，都是在哈希现金的框架下进行挖矿的。 2. 哈希函数哈希函数（Hash Function），也称为散列函数，给定一个输入 x，它会算出相应的输出 H(x)。哈希函数的主要特征是： 输入 x 可以是任意长度的字符串 输出结果即 H(x) 的长度是固定的 计算 H(x) 的过程是高效的（对于长度为 n 的字符串 x，计算出 H(x) 的时间复杂度应为 O(n)） 而对于比特币这种加密系统所使用的哈希函数，它需要另外具备以下的性质： 免碰撞，即不会出现输入 x≠y，但是 H(x)=H(y) 其实这个特点在理论上并不成立，比如，比特币使用的 SHA256 算法，会有 2^256 种输出，如果我们进行 2^256+1 次输入，那么必然会产生一次碰撞；甚至从概率的角度看，进行 2^130 次输入就会有 99% 的可能发生一次碰撞。不过我们可以计算一下，假设一台计算机以每秒 10000 次的速度进行哈希运算，要经过 10^27 年才能完成 2^128 次哈希！甚至可以这么说，即便是人类制造的所有计算机自宇宙诞生开始一直运算到今天，发现碰撞的几率也是极其小的。 隐匿性，也就是说，对于一个给定的输出结果 H(x)，想要逆推出输入 x，在计算上是不可能的。 不存在比穷举更好的方法，可以使哈希结果 H(x) 落在特定的范围。 以上特点是比特币的工作量证明系统可以正常运行的基石。 3. 工作量证明的基本原理工作量证明系统主要特征是客户端需要做一定难度的工作得出一个结果，验证方却很容易通过结果来检查出客户端是不是做了相应的工作。这种方案的一个核心特征是不对称性：工作对于请求方是适中的，对于验证方则是易于验证的。它与验证码不同，验证码的设计出发点是易于被人类解决而不易被计算机解决。下图表示的是工作量证明的流程：举个例子，给定的一个基本的字符串”Hello, world!”，我们给出的工作量要求是，可以在这个字符串后面添加一个叫做 nonce 的整数值，对变更后（添加 nonce) 的字符串进行 SHA256 哈希运算，如果得到的哈希结果（以 16 进制的形式表示）是以”0000”开头的，则验证通过。为了达到这个工作量证明的目标。我们需要不停的递增 nonce 值，对得到的新字符串进行 SHA256 哈希运算。按照这个规则，我们需要经过 4251 次计算才能找到恰好前 4 位为 0 的哈希散列。复制代码 12345678910111213&quot;Hello, world!0&quot; =&gt; 1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64&quot;Hello, world!1&quot; =&gt; e9afc424b79e4f6ab42d99c81156d3a17228d6e1eef4139be78e948a9332a7d8&quot;Hello, world!2&quot; =&gt; ae37343a357a8297591625e7134cbea22f5928be8ca2a32aa475cf05fd4266b7...&quot;Hello, world!4248&quot; =&gt; 6e110d98b388e77e9c6f042ac6b497cec46660deef75a55ebc7cfdf65cc0b965&quot;Hello, world!4249&quot; =&gt; c004190b822f1669cac8dc37e761cb73652e7832fb814565702245cf26ebb9e6&quot;Hello, world!4250&quot; =&gt; 0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9 通过这个示例我们对工作量证明机制有了一个初步的理解。有的人会认为如果工作量证明只是这样的一个过程，那是不是只需要记住 nonce 为 4521 计算能通过验证就行了？当然不是的，这只是一个个例。下面，我们将输入简单的变更为”Hello, world+ 整数值”，整数值取 1 到 1000，也就是说，将输入变成一个由 1000 个值组成的数组：“Hello, world!1、Hello, world!2……Hello, world!1000”。然后对数组中的每一个输入依次进行上面例子中要求的工作量证明——找到前导为 4 个 0 的哈希散列。容易算出，预期大概要进行 2^16 次尝试（哈希值的伪随机特性使得我们可以做概率估算），才能得到 4 个前导 0 的哈希散列。而统计一下刚才进行的 1000 次计算的实际计算结果，我们会发现，进行计算的平均次数为 66958 次，十分接近 2^16（65536）。在这个例子中，数学期望的计算次数，就是我们要求的“工作量”，重复多次进行的工作量证明会是一个符合统计学规律的概率事件。统计输入的字符串与对应得到目标结果实际使用的计算次数列表如下：复制代码 123456789101112131415161718192021Hello, world!1 =&gt; 42153Hello, world!2 =&gt; 2643Hello, world!3 =&gt; 32825Hello, world!4 =&gt; 250Hello, world!5 =&gt; 7300...Hello, world!995 =&gt; 164819Hello, world!996 =&gt; 178486Hello, world!997 =&gt; 22798Hello, world!998 =&gt; 68868Hello, world!999 =&gt; 46821 比特币体系里的工作量证明机制与上述示例类似，但要比它更复杂一些。 4. 比特币中的工作量证明比特币网络中任何一个节点，如果想生成一个新的区块并写入区块链，必须解出比特币网络出的工作量证明的迷题。这道题关键的三个要素是工作量证明函数、区块及难度值。工作量证明函数是这道题的计算方法，区块决定了这道题的输入数据，难度值决定了这道题的所需要的计算量。 4.1 工作量证明函数和我们上节例子中用到的哈希函数一样，比特币系统中使用的工作量证明函正是 SHA256。SHA 是安全散列算法（Secure Hash Algorithm）的缩写，是一个密码散列函数家族。这一组函数是由美国国家安全局（NSA）设计，美国国家标准与技术研究院（NIST） 发布的，主要适用于数字签名标准。SHA256 就是这个函数家族中的一个，是输出值为 256 位的哈希算法。到目前为止，还没有出现对 SHA256 算法的有效攻击。 4.2 区块比特币的区块由区块头及该区块所包含的交易列表组成。区块头的大小为 80 字节，由 4 字节的版本号、32 字节的上一个区块的散列值、32 字节的 Merkle Root Hash、4 字节的时间缀（当前时间）、4 字节的当前难度值、4 字节的随机数组成。区块包含的交易列表则附加在区块头后面，其中的第一笔交易是 coinbase 交易，这是一笔为了让矿工获得奖励及手续费的特殊交易。区块的大致结构如图所示：拥有 80 字节固定长度的区块头，就是用于比特币工作量证明的输入字符串。因此，为了使区块头能体现区块所包含的所有交易，在区块的构造过程中，需要将该区块要包含的交易列表，通过 Merkle Tree 算法生成 Merkle Root Hash，并以此作为交易列表的摘要存到区块头中。其中 Merkle Tree 的算法图解如下： 4.3 难度值难度值（difficulty）是矿工们在挖矿时候的重要参考指标，它决定了矿工大约需要经过多少次哈希运算才能产生一个合法的区块。比特币的区块大约每 10 分钟生成一个，如果要在不同的全网算力条件下，新区块的产生保持都基本这个速率，难度值必须根据全网算力的变化进行调整。简单地说，难度值被设定在无论挖矿能力如何，新区块产生速率都保持在 10 分钟一个。难度的调整是在每个完整节点中独立自动发生的。每 2016 个区块，所有节点都会按统一的公式自动调整难度，这个公式是由最新 2016 个区块的花费时长与期望时长（期望时长为 20160 分钟即两周，是按每 10 分钟一个区块的产生速率计算出的总时长）比较得出的，根据实际时长与期望时长的比值，进行相应调整（或变难或变易）。也就是说，如果区块产生的速率比 10 分钟快则增加难度，比 10 分钟慢则降低难度。这个公式可以总结为如下形式：复制代码 1新难度值 = 旧难度值 * ( 过去 2016 个区块花费时长 / 20160 分钟 ) 工作量证明需要有一个目标值。比特币工作量证明的目标值（Target）的计算公式如下：复制代码 12345目标值 = 最大目标值 / 难度值其中最大目标值为一个恒定值：0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 目标值的大小与难度值成反比。比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值。与第 3 节所举的例子相类比，我们也可以简单理解成，比特币工作量证明的过程，就是通过不停的变换区块头（即尝试不同的 nouce 值）作为输入进行 SHA256 哈希运算，找出一个特定格式哈希值的过程（即要求有一定数量的前导 0）。而要求的前导 0 的个数越多，代表难度越大。 4.4 工作量证明的过程我们可以把比特币矿工解这道工作量证明迷题的步骤大致归纳如下： 生成 Coinbase 交易，并与其他所有准备打包进区块的交易组成交易列表，通过 Merkle Tree 算法生成 Merkle Root Hash 把 Merkle Root Hash 及其他相关字段组装成区块头，将区块头的 80 字节数据（Block Header）作为工作量证明的输入 不停的变更区块头中的随机数即 nonce 的数值，并对每次变更后的的区块头做双重 SHA256 运算（即 SHA256(SHA256(Block_Header))），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。 该过程可以用下图表示： 5. 结语比特币的工作量证明，就是我们俗称“挖矿”所做的主要工作。理解工作量证明机制，将为我们进一步理解比特币区块链的共识机制奠定基础。","link":"/2023/07/31/%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"uniapp","slug":"uniapp","link":"/tags/uniapp/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"three","slug":"three","link":"/tags/three/"},{"name":"区块链","slug":"区块链","link":"/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"categories":[{"name":"dart学习","slug":"dart学习","link":"/categories/dart%E5%AD%A6%E4%B9%A0/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"uniapp","slug":"uniapp","link":"/categories/uniapp/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"vue3","slug":"vue3","link":"/categories/vue3/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"前端安全","slug":"前端安全","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"浏览器原理","slug":"浏览器原理","link":"/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"Flutter","slug":"Flutter","link":"/categories/Flutter/"},{"name":"Three.js学习","slug":"Three-js学习","link":"/categories/Three-js%E5%AD%A6%E4%B9%A0/"},{"name":"区块链系统实现","slug":"区块链系统实现","link":"/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"name":"区块链基础","slug":"区块链基础","link":"/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/"}],"pages":[{"title":"","text":"Title -关于我 2020年普通本科毕业,一个前端菜鸟,兴趣使然,努力学习技术中... 学习工作的同时,热爱生活,热爱自己,热爱家人 -技术栈 vue: 对vue 可能是最熟悉的了,从工作开始就一直是用的vue进行的开发,h5公众号,小程序,web端,uniapp,从最开始的vue2 vue2.7 到现在的vue3,可能用的越来越多,感觉vue也是越来越好用了,面对大而杂的项目来说,也是非常的 nice,pinia和hooks写法在大型项目中表现个人感觉也是越来越优异,越来越舒服 react: 对react的深度可能没有像vue那么深,上一般项目是没有问题的,MVVM模型的设计思想:数据驱动视图加 上对vue的熟练度,react 掌握还是很快的,react对jsx语法的完美支持,让react使用起来更加灵活,所以很多人对react也是越写越爱爱不释手 Flutter: 为什么还会Flutter,为什么会选择flutter原因有两个,1.之前做过简单的跨端开发, 是用的uniapp,做出来的效果很一般,就是不丝滑,能用,再一个编译起来问题比较多很抓狂 ,这东西还是做小程序比较nice。2.Flutter的语言dart和ts比较相似,整体的学习成本要低一些,比较好上手,同时社区也比较活跃,再一个工作这么久深知自己在移动端部分的经验相对薄弱。 Three.js: 对这个的掌握程度只能说入门,能说熟练或者精通的人我都觉得是大牛,这东西到后面需要对计算机图形学有一个极深的理解才行,着色器语言,渲染管线原理,个人理解:完全掌握这些不亚于掌握大前端内容,深度甚至更高!。 -关博客 记录工作中的遇到的一些问题 一些学习笔记 可能有一些其他内容 2022.10.05","link":"/about/index.html"}]}