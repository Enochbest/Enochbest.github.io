{"posts":[{"title":"Dart学习---List的Remove方法小坑","text":"12345var L1=&lt;String&gt;['香蕉','苹果','西瓜','西瓜'];L1.addAll(['桃子','莆田']);print(L1);//[香蕉, 苹果, 西瓜, 桃子, 桃子, 莆田]L1.remove('桃子');print(L1);//[香蕉, 苹果, 西瓜, 桃子, 莆田] List 的remove()方法在移除重复数据的时候只会移除第一项","link":"/2022/11/28/Dart%E5%AD%A6%E4%B9%A0-List%E7%9A%84Remove%E6%96%B9%E6%B3%95%E5%B0%8F%E5%9D%91/"},{"title":"搞懂事件循环","text":"事件循环 文章参考地址:https://zh.javascript.info/event-loop#shi-jian-xun-huan 事件循环的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。 当有任务时： 从最先进入的任务开始执行。 休眠直到出现任务，然后转到第 1 步。 当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。 任务示例： 当外部脚本 &lt;script src=&quot;...&quot;&gt; 加载完成时，任务就是执行它。 当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。 当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。 ……诸如此类。当脚本/处理程序/事件激活时,js 引擎开始处理他们—处理完成后开始等待,(进入休眠，几乎不消耗 CPU 资源)一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序，依此类推。 两个注意点: 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。 例 1：拆分 CPU 过载任务通过一个例子来深入了解一下,假设我们有一个 CPU 过载任务。为了演示这种方法，简单起见，让我们写一个从 1 数到 1000000000 的函数如果你运行下面这段代码，你会看到引擎会“挂起”一段时间。对于服务端 JS 来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束之前不会处理其他事件。 123456789101112131415let i = 0;let start = Date.now();function count() { // 做一个繁重的任务 for (let j = 0; j &lt; 1e9; j++) { i++; } alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');}count(); 浏览器甚至可能会显示一个“脚本执行时间过长”的警告。让我们使用嵌套的 setTimeout 调用来拆分这个任务： 1234567891011121314151617181920let i = 0;let start = Date.now();function count() { // 做繁重的任务的一部分 (*) do { i++; } while (i % 1e6 != 0); if (i == 1e9) { alert(&quot;Done in &quot; + (Date.now() - start) + 'ms'); } else { setTimeout(count); // 安排（schedule）新的调用 (**) }}count(); 现在，浏览器界面在“计数”过程中可以正常使用。 单次执行 count 会完成工作 (*) 的一部分，然后根据需要重新安排（schedule）自身的执行 (**)： 首先执行计数：i=1...1000000。然后执行计数：i=1000001..2000000。……以此类推。现在，如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 onclick 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 count 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。 值得注意的是这两种变体 —— 是否使用了 setTimeout 对任务进行拆分 —— 在执行速度上是相当的。在执行计数的总耗时上没有多少差异。 为了使两者耗时更接近，让我们来做一个改进。 我们将要把调度（scheduling）移动到 count() 的开头： 1234567891011121314151617181920212223let i = 0;let start = Date.now();function count() { // 将调度（scheduling）移动到开头 if (i &lt; 1e9 - 1e6) { setTimeout(count); // 安排（schedule）新的调用 } do { i++; } while (i % 1e6 != 0); if (i == 1e9) { alert(&quot;Done in &quot; + (Date.now() - start) + 'ms'); }}count(); 现在，当我们开始调用 count() 时，会看到我们需要对 count() 进行更多调用，我们就会在工作前立即安排（schedule）它。 如果你运行它，你很容易注意到它花费的时间明显减少了。 为什么？ 这很简单：你应该还记得，多个嵌套的 setTimeout 调用在浏览器中的最小延迟为 4ms。即使我们设置了 0，但还是 4ms（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。 最后，我们将一个繁重的任务拆分成了几部分，现在它不会阻塞用户界面了。而且其总耗时并不会长很多。 例2：进度指示我们也可能想在任务执行期间展示一些东西，例如进度条。 如果我们使用 setTimeout 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。 这看起来更好看： 12345678910111213141516171819202122&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;&lt;script&gt; let i = 0; function count() { // 做繁重的任务的一部分 (*) do { i++; progress.innerHTML = i; } while (i % 1e3 != 0); if (i &lt; 1e7) { setTimeout(count); } } count();&lt;/script&gt; 现在 div 显示了 i 的值的增长，这就是进度条的一种。 宏任务和微任务除了 宏任务（macrotask） 外，还有在 微任务（Microtask 微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。 还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行。 每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。 看这个例子: 1234567setTimeout(() =&gt; alert(&quot;timeout&quot;));Promise.resolve() .then(() =&gt; alert(&quot;promise&quot;));alert(&quot;code&quot;); 这里的执行顺序是: 1.code 首先显示，因为它是常规的同步调用。 2.promise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行。 3.timeout 最后显示，因为它是一个宏任务。 更详细的事件循环图示如下（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）： 微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成。 这很重要，因为它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。 如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 queueMicrotask 来对其进行安排（schedule）。 这是一个与前面那个例子类似的，带有“计数进度条”的示例，但是它使用了 queueMicrotask 而不是 setTimeout。你可以看到它在最后才渲染。就像写的是同步代码一样： 12345678910111213141516171819202122&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;&lt;script&gt; let i = 0; function count() { // 做繁重的任务的一部分 (*) do { i++; progress.innerHTML = i; } while (i % 1e3 != 0); if (i &lt; 1e6) { queueMicrotask(count); } } count();&lt;/script&gt; 总结更详细的事件循环算法（尽管与 规范 相比仍然是简化过的）： 1.从 宏任务 队列（例如 “script”）中出队（dequeue）并执行最早的任务。 2.执行所有 微任务： *当微任务队列非空时： *出队（dequeue）并执行最早的微任务。 5.如果有变更，则将变更渲染出来。 6.如果宏任务队列为空，则休眠直到出现宏任务。 7.转到步骤 1。 安排（schedule）一个新的 宏任务： 使用零延迟的 setTimeout(f)。它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。 此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。 安排一个新的 微任务： 使用 queueMicrotask(f)。promise 处理程序也会通过微任务队列。在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。 所以，我们可以使用 queueMicrotask 来在保持环境状态一致的情况下，异步地执行一个函数。","link":"/2022/11/09/Event-Loop/"},{"title":"IM发送表情（基于quill富文本编辑器）","text":"首先 1npm install vue-quill-editor --save main.js 12345import VueQuillEditor from 'vue-quill-editor'//调用编辑器import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'Vue.use(VueQuillEditor) 最近公司在重构im项目，聊天中新增发送表情，有两种实现方法，由于公司现在的项目发送的时候用的不是富文本是输入框，第一种方法基于这种情况也可以实现原理都是一样的 就是把本地资源在以指定的key 字符串，在聊天信息中解析成富文本（含img标签） html 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;QuillEditor @getText=&quot;getText&quot; @getHtml=&quot;getHtml&quot; ref=&quot;MyQuillEditor&quot;&gt;&lt;/QuillEditor&gt; &lt;button @click=&quot;sendText&quot;&gt;发送消息&lt;/button&gt; &lt;div&gt; &lt;img v-for=&quot;(emojiItem, emojiKey, index) in emoji.map&quot; class=&quot;emoji-item&quot; :key=&quot;index&quot; :src=&quot;emoji.url + emojiItem&quot; @click=&quot;chooseEmoji(emojiKey)&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;div v-for=&quot;(msg,index) in messageList&quot; :key=&quot;index&quot;&gt; &lt;div v-html=&quot;emoji.decoder.decode(msg)&quot; style=&quot;text-align: center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js 12345678910111213141516171819202122// 定义子组件refconst MyQuillEditor = ref()const emojiUrl = 'https://imgcache.qq.com/open/qcloud/tim/assets/emoji/';const emojiMap = { '[么么哒]': 'emoji_3@2x.png', '[乒乓]': 'emoji_4@2x.png', '[便便]': 'emoji_5@2x.png', '[信封]': 'emoji_6@2x.png', '[偷笑]': 'emoji_7@2x.png', '[傲慢]': 'emoji_8@2x.png',};const emoji= reactive({ url: emojiUrl, map: emojiMap, visible: false, decoder: new EmojiDecoder(emojiUrl, emojiMap),})//将图片的key插入富文本const chooseEmoji = (emojiKey)=&gt;{ console.log(emojiKey) MyQuillEditor.value.insertText(emojiKey)} 将发送的字符串记录中替换成富文本信息 12345678910111213141516171819202122232425class EmojiDecoder { emojiMap = null; url = &quot;&quot;; patterns = []; metaChars = /[[\\]{}()*+?.\\\\|^$\\-,&amp;#\\s]/g; constructor(url,emojiMap) { this.url = url || ''; this.emojiMap = emojiMap || {}; for (let i in this.emojiMap) { // eslint-disable-next-line no-prototype-builtins if (this.emojiMap.hasOwnProperty(i)){ this.patterns.push('('+i.replace(this.metaChars, &quot;\\\\$&amp;&quot;)+')'); } } } decode (text) { return text.replace(new RegExp(this.patterns.join('|'),'g'), (match) =&gt; { return typeof this.emojiMap[match] != 'undefined' ? '&lt;img height=&quot;16px&quot; width=&quot;16px&quot; src=&quot;'+this.url+this.emojiMap[match]+'&quot; /&gt;' : match; }); }}export default EmojiDecoder 这种有个坏处富文本里面看不到图片，发送起来像这种”[便便]”, 第二种，我们重写一下插入内容的方法，在mainjs中 12345678910111213141516171819202122232425262728293031import VueQuillEditor , { Quill }from 'vue-quill-editor'// require stylesimport 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import imageResize from 'quill-image-resize-module' // 调整大小组件。import { ImageDrop } from 'quill-image-drop-module'; // 拖动加载图片组件。const Embed = Quill.import(&quot;blots/embed&quot;);console.log(Embed,'-------------666-----------------')///表情 重点部分class MsgEmoji extends Embed { static create(value) { console.log(&quot;create&quot;,value) ///通过id判断是否需要格式化，防止误伤 if(Object.prototype.toString.call(value)===&quot;[object HTMLImageElement]&quot;){ return value } let node = super.create(); node.setAttribute(&quot;src&quot;, value.src); node.style.width = &quot;16px&quot;; node.style.height = &quot;16px&quot;; node.style.backgroundColor = &quot;red&quot;; return node; } ///撤消操作 static value=node=&gt;node}MsgEmoji.blotName = &quot;MsgEmoji&quot;;MsgEmoji.tagName = &quot;img&quot;;//别忘了注册我们重写的方法Quill.register(MsgEmoji); 在页面上使用（选择表情的场景） 1234//获取富文本实例 let quill = this.$refs.myQuillEditor.quill //获取最近一次的光标位置 quill.insertEmbed(quill.selection.savedRange.index,&quot;MsgEmoji&quot;,{src: &quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;, code: &quot;0&quot; },Quill.sources.USER); quill很灵活，可自定义的非常多，还是比较推荐，像上面这种，需要自定义图片样式插入图片选择图片也是非常实用的！","link":"/2023/09/09/IM%E5%8F%91%E9%80%81%E8%A1%A8%E6%83%85%EF%BC%88%E5%9F%BA%E4%BA%8Equill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/"},{"title":"UviewPicker的数据渲染问题","text":"UviewPicker设计模式自我觉得真的很不理解,他的联级选择数据居然不是树形结构,需要自己去获取下一级的选项去设置,默认项是一个一维数组 拿到后端返回的树形接口前端操作起来算是比较麻烦需要几个工具函数进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//获取源数据的深度 function getDeep(obj) { let res = 1 // 递归函数 function fn(obj) { let arr = [] let arrLength = arr.length // 先遍历是不是里面还有对象类型，是就计数 for (let item in obj) { if (typeof (obj[item]) === 'object') { // 然后把这个再存到数组中下次遍历 // arr.push([...obj[item]]) // 要分别存入，否则下次死循环 for (let key in obj[item]) { arr.push(obj[item][key]) } } } // 循环结束后判断arr有没有增加 if (arr.length &gt; arrLength) { res++ arrLength = arr.length // 继续递归 return fn(arr) } else return res } return fn(obj) } //初始化默认展示的数据 function initModuleNumberFnc(data) { //获取第一项的深度用于遍历次数,处理出默认数据 const deepnum = getDeep(data[0]) console.log(deepnum) let firstArr = [] //初始化第一层数据 firstArr = data.map((item) =&gt; { return { id: item.id, name: item.nodeName } }) console.log(firstArr) let Arr = [] let initDataArr = data[0].children for (let index = 0; index &lt; deepnum - 2; index++) { if (index === 0) { Arr.push(data[0].children) console.log(Arr[index - 1]) } else { if (Arr[index - 1][0].children.length &gt; 0) { Arr.push(Arr[index - 1][0].children) console.log(Arr[index - 1][0].children) } } } console.log(Arr) return [firstArr, ...Arr] } initModuleNumberFnc(data) //已得到初始化数据作为默认渲染 //调用getNextData方法获取下一项的值 console.log(initModuleNumberFnc(data)) // 扁平化元数据 function cutTree(data, childName = 'children') { let result = []; while (data.length != 0) { let shift = data.shift(); let children = shift[childName] delete shift[childName] result.push(shift) if (children) { children.forEach(item =&gt; { data.push(item) }) } } return result } const result = cutTree(data) console.log(result) //根据传入的id获取下一项 function getNextData(id){ console.log(cutTree(data)) let res = result.filter((item)=&gt;{ return item.parentCode == id }) console.log(res) } getNextData('1496398135651430402')","link":"/2022/11/08/My-New-Post-1/"},{"title":"手写call、apply、bind","text":"Call12345const obj = {name: 'Enoch',say(prefix, age) {console.log(`${prefix},my name is ${this.name},i am ${age} year old`)} 上面我们定义了一个对象，对象中有个say方法，调用该对象上的方法后，我们得到了 1obj.say('hello',12) // 'hello,my name is Enoch,i am 12 year old' 这个时候问题来了，如果还有另外一个对象A，也想实现上面对象中的方法say，有两种 在A对象中也照搬不误的实现一个一模一样的say方法 能不能借用一下上面对象中的方法say 但是如果你选择了第二种，又会面临另外一个问题，因为方法中涉及到this指向的问题，而在上面，我就特意提出了理解this指向的前置条件。能不能做到把obj上面的say方法，借A用的同时，this指向也自然而然的指向A呢？其实上面这段话已经很好地道出了call的真正作用，改变函数的作用域。这里先说一下，不管是call,还是apply都是冒用借充函数。 123456789101112131415const obj = { name: 'Enoch', say(prefix, age) { console.log(`${prefix},my name is ${this.name},i am ${age} year old`) }}const A = { name:'小丁'}obj.say.call(A,'hello',3) // 'hello,my name is 小丁,i am 3 year old'} 通过以上代码片段，我们可以总结以下几点 A中确实没有再次定义一个重复的方法，并且say方法中的this指向确实指向了A call方法，可以接受任意多个参数，但是要求，第一个参数必须是待被指向的对象（A），剩下的参数，都传入借过来使用的函数（say）中 现在知道了call是什么东西，那么我们就开始来模仿实现以上两点，但模仿前，我们需要知道 不管是引用数据类型还是基本数据类型，它们的方法，都是定义在原型对象上面的 方法中的this指向 谁调用这个方法this就指向谁 手写Call先写个雏形，该自定义call方法接受N个参数，其中第一个参数是即将借用这个函数的对象，剩下的参数用rest参数表示，这就模仿出了上面的第二点的前半部分 123Function.prototype.myCall = function(target,...args){ } 我们都知道一个普通函数中的this是指向调用这个函数的对象的，那么我们想让上方say方法中的this指向调用该方法的对象，该怎么做呢？很简单，我在你这个对象上添加一个方法，当我们调用这个对象上的这个方法时，方法中的this自然就指向该对象 1234Function.prototype.myCall = function(target,...args){ const symbolKey = Symbol() target[symbolKey] = this} 这里我们做了两件事，首先就是给传入的第一个对象，添加了一个key，这里用symbolKey而不随便定义另外一个key名是因为，我随意添加的名字，可能target对象上面正好有呢？这不是扯犊子呢吗…而Symbol就是ES6中实现的，用来解决这种问题。其次，我们为这个属性，赋了一个值this，而这个this就正是借过来使用的函数，这样我们执行该函数时，其中的this，自然而然的就指向了target。到这里，已经模仿出了上面的第一点但是javascript要求，当我们target传入的是一个非真值的对象时，target指向window，这很好办 12345Function.prototype.myCall = function(target,...args){ target = target || window const symbolKey = Symbol() target[symbolKey] = this} 到这里，我们已经完全实现了上面提出的两点需要模仿实现的点，但是我们的目的是把别的方法，拿过来用用，用完了之后，肯定还是要删掉的。如果函数具备返回值的话，我们还是需要将返回值进行返回的。 12345678910Function.prototype.myCall = function(target,...args){ target = target || window const symbolKey = Symbol() target[symbolKey] = this const res = target[symbolKey](...args) // args本身是rest参数，搭配的变量是一个数组，数组解构后就可以一个个传入函数中 delete target[symbolKey] // 执行完借用的函数后，删除掉， return res}obj.say.myCall(A,'hello',3) // 'hello,my name is 小丁,i am 3 year old' 总结一下:就是将调用函数的this放在了传入的A对象身上,这样this就可以访问到A对象的值 Apply区别就是这里第二个参数直接就是个数组 123456789Function.prototype.myApply = function(target,args){ // 区别就是这里第二个参数直接就是个数组 target = target || window const symbolKey = Symbol() target[symbolKey] = this const res = target[symbolKey](...args) // args本身是个数组，所以我们需要解构后一个个传入函数中 delete target[symbolKey] // 执行完借用的函数后，删除掉， return res}obj.say.myCall(A,'hello',3) // 'hello,my name is 小丁,i am 3 year old' Bind先写了一个基础版 12345678910111213141516const obj = { name: 'Enoch', say() { console.log(`my name is ${this.name}`) }}obj.say() // 'my name is 麻不烧'const B = { name: '小丁丁'}const sayB = obj.say.bind(B)sayB() // 'my name is 小丁丁' bind本身是个方法，返回值也是个方法，一般调用bind方法的也是个方法…别懵 接受的第一个参数是一个对象，哪个方法调用bind方法，那么这个方法中的this，就是指向这个对象 手写Bind先写个基础架子 1234Function.prototype.myBind = function (target) { target = target || {} // 处理边界条件 return function () {} // 返回一个函数} 想要完成上面提到的第二个要素，还是和实现apply与call那样，给该target添加一个方法，这样方法中的this，就是指向该target 12345678910Function.prototype.myBind = function (target) { target = target || {} // 处理边界条件 const symbolKey = Symbol() target[symbolKey] = this return function () { // 返回一个函数 target[symbolKey]() delete target[symbolKey] } } 到这里，已经完成了bind的大部分逻辑，但是在执行bind的时候，是可以传入参数的，稍微改下上面的例子 1234567891011121314151617const obj = { name: 'Enoch', say(prefix, age) { console.log(`${prefix},my name is ${this.name},i am ${age} year old`) }}obj.say('hello',12) // 'hello,my name is 麻不烧,i am 12 year old'const B = { name: '小丁丁'}const sayB = obj.say.bind(B,'hello')sayB(3) // 'hello,my name is 小丁丁,i am 3 year old'' 这里，我们发现一个有意思的地方，不管是bind中传递的参数，还是调用bind的返回函数时传入的参数，都老老实实的传递到say方法中，其实很容易实现 12345678910Function.prototype.myBind = function (target,...outArgs) { target = target || {} // 处理边界条件 const symbolKey = Symbol() target[symbolKey] = this return function (...innerArgs) { // 返回一个函数 const res = target[symbolKey](...outArgs, ...innerArgs) // outArgs和innerArgs都是一个数组，解构后传入函数 // delete target[symbolKey] 这里千万不能销毁绑定的函数，否则第二次调用的时候，就会出现问题。 return res } } 由于myBind返回的函数会被多次调用，所以不应该在调用一次之后，就将里面的target[symbolKey]给销毁掉。因为这样会导致第二次调用的时候，出现问题。","link":"/2022/09/08/My-New-Post/"},{"title":"Vue在data中获取computed值为undefined","text":"直接看问题 12345678910data() { return { age:this.newAge //undefined }; }, computed: { newAge(){ return '18' } }, 这里的知识点和生命周期有关 首先created是最先执行的，初始化data里的值。 computed是界于created和mounted之间发生的 在data创建完成时 computed还没被创建,所以这个时候一定是undefined 解决方法 123456789101112data() { return { age:function () { return this.newAge } }; }, computed: { newAge(){ return '18' } },","link":"/2022/09/10/Vue-Article/"},{"title":"Vue通过dom导出excel表格","text":"一般业务中我们不会去通过这种方法去导出表格,这种不安全,一般会后端返回下载链接进行参数加密,并只能下载一次,每次下载前更新链接,这里只是介绍一种思路 安装xlsx库1npm install xlsx 安装file-saver库1npm install file-saver 编写保存函数，文件位置：src/utils/htmlToExcel.js123456789101112131415161718192021222324import FileSaver from &quot;file-saver&quot;;import * as XLSX from 'xlsx/xlsx.mjs';const htmlToExcel = { getExcel(dom,title='默认标题',){ var excelTitle = title; var wb = XLSX.utils.table_to_book(document.querySelector(dom)); /* 获取二进制字符串作为输出 */ var wbout = XLSX.write(wb, {bookType: &quot;xlsx&quot;,bookSST: true,type: &quot;array&quot;}); try { FileSaver.saveAs( new Blob([wbout], { type: &quot;application/octet-stream&quot; }), excelTitle + &quot;.xlsx&quot; ); } catch (e) { if (typeof console !== &quot;undefined&quot;) console.log(e, wbout); } return wbout; }};export default htmlToExcel; 使用函数，文件位置src/views/TablePage.vue注:表格导出实现解释，给展示表格添加选择功能，通过handleSelectionChange函数将选中数据与selectData绑定，在选中需要导出数据后点击导出按钮，展示el-dialog并将selectData数据展示在el-dialog中的表格，此表格为最后导出的表格，所以id赋值selectTable，最后确认打印调用exportExcel函数，通过htmlToExcel.getExcel('#selectTable','导出的自定义标题')导出Excel文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;template&gt; &lt;div&gt; &lt;!--导出按钮--&gt; &lt;el-button type=&quot;primary&quot; style=&quot;margin:20px;&quot; @click=&quot;exportExcelSelect&quot;&gt;导出Excel&lt;/el-button&gt; &lt;!--原始表格--&gt; &lt;el-table :data=&quot;tableData&quot; @selection-change=&quot;handleSelectionChange&quot; &gt; &lt;el-table-column type=&quot;selection&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;详细地址&quot;&gt; &lt;el-table-column prop=&quot;province&quot; label=&quot;省份&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;city&quot; label=&quot;市区&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;zip&quot; label=&quot;邮编&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; &gt; &lt;template&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;查看&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;编辑&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--预览弹窗表格--&gt; &lt;el-dialog title=&quot;表格保存预览&quot; width=&quot;70%&quot; :visible.sync=&quot;selectWindow&quot;&gt; &lt;el-table :data=&quot;selectData&quot; id=&quot;selectTable&quot; height=&quot;380px&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;详细地址&quot;&gt; &lt;el-table-column prop=&quot;province&quot; label=&quot;省份&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;city&quot; label=&quot;市区&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;zip&quot; label=&quot;邮编&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;exportExcel&quot;&gt;确定保存&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import htmlToExcel from '@/utils/htmlToExcel' export default { name: &quot;ExcelPage&quot;, data(){ return{ //表格数据 tableData: [ { date: '2016-05-03', name: '王小天', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-02', name: '王小明', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-04', name: '王小智', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-01', name: '王小红', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-08', name: '王小华', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-06', name: '王小丽', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 }, { date: '2016-05-07', name: '王小花', province: '上海', city: '普陀区', address: '上海市普陀区金沙江路 1518 弄', zip: 200333 } ], //表格中选中的数据 selectData:[], selectWindow:false, } }, methods:{ //导出 exportExcel() { htmlToExcel.getExcel('#selectTable','导出的自定义标题') }, //显示预览弹窗 exportExcelSelect(){ if (this.selectData.length &lt; 1){ this.$message.error('请选择要导出的内容！'); return false; } this.selectWindow = true; }, //选中数据 handleSelectionChange(val) { this.selectData = val; } } }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","link":"/2022/07/08/Vue%E9%80%9A%E8%BF%87dom%E5%AF%BC%E5%87%BAexcel%E8%A1%A8%E6%A0%BC/"},{"title":"docker安装以及简单前端项目部署","text":"centos 7.9 docker-compose根据自己情况安装 yum选择自己合适的 安装流程卸载旧版本12345678910111213 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#卸载 Docker Engine、CLI、Containerd 和 Docker Compose 软件包：yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin#主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷：sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 开始安装设置存储库。安装yum-utils包（提供yum-config-manager 实用程序）并设置存储库。 1234567891011121314 sudo yum install -y yum-utils#配置源#可以使用阿里源，最好选这个yum-config-manager --add-repo=http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#官方sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum makecache #重新构建缓存yum repolist {all|enabled|disabled} #列出所有/已启用/已禁用的yum源yum --disablerepo=repo #临时禁用某个repo源yum --enablerepo=repo #解除禁用某个repo源 安装 Docker 引擎。安装最新版本的 Docker Engine、containerd 和 Docker Compose 1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin #解除禁用某个repo源 要安装特定版本的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装 1234567891011yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:20.10.19-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.18-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.17-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.16-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.15-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.14-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:20.10.13-3.el7 docker-ce-stable 安装。 12345#默认安装sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin#可以选择版本sudo yum install docker-ce-20.10.14 docker-ce-cli-20.10.14 containerd.io docker-compose-plugin 结束 12345sudo systemctl start docker #启动sudo systemctl enable docker #开机启动docker version #查看版本docker run hello-world #示例进项 前端项目部署准备好阿里云服务器 CentOS 7.6 64位 下载xShell 7 和 Xftp 7 xShell连接服务器这里有两种方案 A.在Xshell客户端创建密匙，导入到阿里云中 B.在阿里云创建密匙，保存，然后导入到客户端 此处选择B方案，具体步骤如下： ①、登录阿里云ECS服务控制台，在【网络与安全】菜单下选择【秘钥对】，进入秘钥对管理界面。 ②、点击【创建秘钥对】进入创建密钥对界面，如下，填写密钥对名称，选择字段创建密钥对，再点击确认即可。此时会弹出下载当前创建秘钥对的提示，下载后保存到本地即可（链接shell时需要用到）。 ③、创建好后，执行【绑定密钥对】，将新建的密钥对绑定阿里云服务器，然后【一定要重启阿里云服务器才能绑定生效】。 ④、打开Xshell，点击新建，填写名称，主机IP（即阿里云ECS对应实例的对公IP地址） ⑤、点击用户身份验证，选择【Public Key】，用户名为【root】，用户秘钥处点击浏览，将之前下载下来的秘钥文件选择到此处，执行连接，即可正常连接至阿里云服务。 Xftp 也是同样的方法建立会话 在会话中看到 Welcome to Alibaba Cloud Elastic Compute Service ! 成功了 构建镜像cd / 切换到根目录下ll 给出当前目录下所有文件的一个长列表 mkdir appmkdir mycodes 设置当前工作目录， 首先我们需要在 demo 工程的根目录下创建一个 Dockerfile 把我们的工程文件拖进mycodes(Xftp) 在mycodes工作目录下开始构建(打包) 12docker build -f Dockerfile -t mycodes . 执行构建命令 运行容器 12docker run -d --name mycodes -p 9001:80 mycodes 访问 http://39.106.27.165:9001/","link":"/2022/10/09/docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"title":"vue+element实现横向树状表格组件","text":"首先使用的demo数据,根据树状数据进行组件递归渲染除每一层的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183menu:{ &quot;name&quot;: &quot;系统后台&quot;, &quot;id&quot;: 1, &quot;showRow&quot;:true, &quot;indeterminate&quot;:false, &quot;checked&quot;:false, &quot;isRoot&quot;:true, &quot;children&quot;:[ { &quot;name&quot;: &quot;系统管理&quot;, &quot;id&quot;: 20, &quot;children&quot;: [ { &quot;id&quot;: 21, &quot;name&quot;: &quot;人员管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 22, &quot;name&quot;: &quot;岗位管理&quot;, &quot;children&quot;:[], &quot;checked&quot;:true }, { &quot;id&quot;: 23, &quot;name&quot;: &quot;部门管理&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;患者管理&quot;, &quot;id&quot;: 30, &quot;children&quot;: [] }, { &quot;name&quot;: &quot;医院管理&quot;, &quot;id&quot;: 40, &quot;children&quot;: [ { &quot;id&quot;: 41, &quot;name&quot;: &quot;医院列表&quot;, &quot;children&quot;:[], }, { &quot;id&quot;: 42, &quot;name&quot;: &quot;工作室管理&quot;, &quot;children&quot;:[], }, ] }, { &quot;name&quot;: &quot;产品管理&quot;, &quot;id&quot;: 50, &quot;children&quot;: [ { &quot;id&quot;: 55, &quot;name&quot;: &quot;产品服务&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;订单管理&quot;, &quot;id&quot;: 60, &quot;children&quot;: [ { &quot;id&quot;: 61, &quot;name&quot;: &quot;订单管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 62, &quot;name&quot;: &quot;劳务协议&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;公司管理&quot;, &quot;id&quot;: 70, &quot;children&quot;: [ { &quot;id&quot;: 71, &quot;name&quot;: &quot;公司账户&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 72, &quot;name&quot;: &quot;医生工作室&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 73, &quot;name&quot;: &quot;备案审核&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;运营配置&quot;, &quot;id&quot;: 80, &quot;children&quot;: [ { &quot;id&quot;: 81, &quot;name&quot;: &quot;术后管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 82, &quot;name&quot;: &quot;患教中心&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 83, &quot;name&quot;: &quot;意见反馈&quot;, &quot;children&quot;:[] }, ] }, { &quot;name&quot;: &quot;知识库&quot;, &quot;id&quot;: 90, &quot;children&quot;: [ { &quot;id&quot;: 91, &quot;name&quot;: &quot;药品库&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 92, &quot;name&quot;: &quot;问卷库&quot;, &quot;children&quot;:[ { &quot;id&quot;: 94, &quot;name&quot;: &quot;分类管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 95, &quot;name&quot;: &quot;问卷管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 96, &quot;name&quot;: &quot;题目管理&quot;, &quot;children&quot;:[] }, ] }, { &quot;id&quot;: 93, &quot;name&quot;: &quot;话术问题管理&quot;, &quot;children&quot;:[ { &quot;id&quot;: 97, &quot;name&quot;: &quot;问题管理&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 98, &quot;name&quot;: &quot;问题分类&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 99, &quot;name&quot;: &quot;未知问题&quot;, &quot;children&quot;:[] }, { &quot;id&quot;: 100, &quot;name&quot;: &quot;话术管理&quot;, &quot;children&quot;:[] }, ] }, ] }, ] }, 第一级的根节点的数据是手动加的(写个方法遍历一下第一层数据加上就行,) 1234&quot;showRow&quot;:true,//当前子节点下是否还有子节点&quot;indeterminate&quot;:false,//当前是否支持半选&quot;checked&quot;:false,//选中绑定的值&quot;isRoot&quot;:true,//是否为第一级节点,后续样式判断 使用两个组件嵌套使用treeTable 和 subTable, treeTable是入口组件主要是在这里处理数据,subTable是进行递归的组件,主要是在这个组件里进行节点监听,改变数据渲染对应ui treeTable.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237 &lt;template&gt; &lt;subTable :menu=&quot;menu&quot; @chooseFirstLevel=&quot;chooseFirstLevel&quot;/&gt;&lt;/template&gt;&lt;script&gt;import subTable from &quot;./subTable&quot;;export default { name: &quot;treeTable&quot;, // 递归的终止条件 用于判断当前项的子级的子级是否存在，存在为true，继续递归，不存在就终止 components:{subTable,}, props: { menu: { type: Object, default: () =&gt; ({}), }, }, data(){ return{ // menu:{ // &quot;name&quot;: &quot;系统后台&quot;, // &quot;id&quot;: 1, // &quot;showRow&quot;:true, // &quot;indeterminate&quot;:false, // &quot;checked&quot;:false, // &quot;isRoot&quot;:true, // &quot;children&quot;:[ // { // &quot;name&quot;: &quot;系统管理&quot;, // &quot;id&quot;: 20, // &quot;children&quot;: [ // { // &quot;id&quot;: 21, // &quot;name&quot;: &quot;人员管理&quot;, // &quot;children&quot;:[] // // }, // { // &quot;id&quot;: 22, // &quot;name&quot;: &quot;岗位管理&quot;, // &quot;children&quot;:[], // &quot;checked&quot;:true // }, // { // &quot;id&quot;: 23, // &quot;name&quot;: &quot;部门管理&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;患者管理&quot;, // &quot;id&quot;: 30, // &quot;children&quot;: [] // }, // { // &quot;name&quot;: &quot;医院管理&quot;, // &quot;id&quot;: 40, // &quot;children&quot;: [ // { // &quot;id&quot;: 41, // &quot;name&quot;: &quot;医院列表&quot;, // &quot;children&quot;:[], // }, // { // &quot;id&quot;: 42, // &quot;name&quot;: &quot;工作室管理&quot;, // &quot;children&quot;:[], // }, // ] // }, // { // &quot;name&quot;: &quot;产品管理&quot;, // &quot;id&quot;: 50, // &quot;children&quot;: [ // { // &quot;id&quot;: 55, // &quot;name&quot;: &quot;产品服务&quot;, // &quot;children&quot;:[] // // }, // ] // }, // { // &quot;name&quot;: &quot;订单管理&quot;, // &quot;id&quot;: 60, // &quot;children&quot;: [ // { // &quot;id&quot;: 61, // &quot;name&quot;: &quot;订单管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 62, // &quot;name&quot;: &quot;劳务协议&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;公司管理&quot;, // &quot;id&quot;: 70, // &quot;children&quot;: [ // { // &quot;id&quot;: 71, // &quot;name&quot;: &quot;公司账户&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 72, // &quot;name&quot;: &quot;医生工作室&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 73, // &quot;name&quot;: &quot;备案审核&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;运营配置&quot;, // &quot;id&quot;: 80, // &quot;children&quot;: [ // { // &quot;id&quot;: 81, // &quot;name&quot;: &quot;术后管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 82, // &quot;name&quot;: &quot;患教中心&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 83, // &quot;name&quot;: &quot;意见反馈&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;name&quot;: &quot;知识库&quot;, // &quot;id&quot;: 90, // &quot;children&quot;: [ // { // &quot;id&quot;: 91, // &quot;name&quot;: &quot;药品库&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 92, // &quot;name&quot;: &quot;问卷库&quot;, // &quot;children&quot;:[ // { // &quot;id&quot;: 94, // &quot;name&quot;: &quot;分类管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 95, // &quot;name&quot;: &quot;问卷管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 96, // &quot;name&quot;: &quot;题目管理&quot;, // &quot;children&quot;:[] // }, // ] // }, // { // &quot;id&quot;: 93, // &quot;name&quot;: &quot;话术问题管理&quot;, // &quot;children&quot;:[ // { // &quot;id&quot;: 97, // &quot;name&quot;: &quot;问题管理&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 98, // &quot;name&quot;: &quot;问题分类&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 99, // &quot;name&quot;: &quot;未知问题&quot;, // &quot;children&quot;:[] // }, // { // &quot;id&quot;: 100, // &quot;name&quot;: &quot;话术管理&quot;, // &quot;children&quot;:[] // }, // ] // }, // ] // }, // // ] // }, realMenu:{} } }, created() { this.showRow(this.menu.children) console.log(this.menu) }, mounted() { }, methods: { // 加入showRow属性,用于递归组件 showRow (list) { list.forEach(item =&gt; { item.showRow = this.hasThreeChild(item.children) if (item.children &amp;&amp; item.children.length !== 0) { this.showRow(item.children); } }) }, hasThreeChild (list) { return list.some(item =&gt; item.children.length !== 0) }, //选中第一层数据变化 chooseFirstLevel(val){ console.log(val,'父组件里的变化') console.log(this.menu,'=========父组件里的值============') } }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; subTable.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195 &lt;template&gt; &lt;div class=&quot;permission-subTable&quot;&gt; &lt;div v-if=&quot;!menu.showRow&quot; class=&quot;content-item&quot;&gt; &lt;div class=&quot;cell&quot;&gt; &lt;el-checkbox v-model=&quot;menu.checked&quot; class=&quot;hasEllipsis&quot; :indeterminate=&quot;menu.indeterminate&quot; @change=&quot;(checked) =&gt; handleCheck(checked, menu)&quot;&gt; {{ menu.name }} &lt;/el-checkbox&gt; &lt;/div&gt; &lt;div class=&quot;last-content&quot;&gt; &lt;template v-if=&quot;menu.children &amp;&amp; menu.children.length&quot;&gt; &lt;div v-for=&quot;(child,index) in menu.children&quot; :key=&quot;child.id&quot; class=&quot;last-child-item&quot;&gt; &lt;el-checkbox v-model=&quot;child.checked&quot; @change=&quot;(checked) =&gt; handleCheck(checked, child)&quot;&gt; {{ child.name }} &lt;/el-checkbox&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-else class=&quot;table&quot;&gt; &lt;div :class=&quot;{title:menu.isRoot,secondTitle:!menu.isRoot}&quot;&gt; &lt;div&gt; &lt;el-checkbox v-model=&quot;menu.checked&quot; class=&quot;hasEllipsis&quot; :indeterminate=&quot;menu.indeterminate&quot; @change=&quot;(checked) =&gt; checkChild(checked, menu)&quot;&gt; {{ menu.name }} &lt;/el-checkbox&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;SubTable v-for=&quot;item in menu.children&quot; :key=&quot;item.id&quot; :menu=&quot;item&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'SubTable', props: { menu: { type: Object, default: () =&gt; ({}), }, }, data () { return { }; }, created() { }, watch: { 'menu.children': { handler (data) { console.log(data,'======我监听到了======') if (data) { if (!data.length) return; const checkedAll = !data.some(item =&gt; !item.checked); const menu = this.menu; this.$set(menu, 'checked', checkedAll); const isIndeterminate = data.filter(item =&gt; (item.indeterminate)); if (isIndeterminate.length) { this.$set(menu, 'indeterminate', true); } else { const checkChild = data.filter(item =&gt; (item.checked)); const indeterminate = checkChild.length &lt; data.length &amp;&amp; checkChild.length &gt; 0; this.$set(menu, 'indeterminate', indeterminate); } } }, deep: true, immediate: true, }, }, mounted () { }, methods: { handleCheck (checked, item) { this.checkChild(checked, item); }, checkChild (checked, data) { if (data.children &amp;&amp; data.children.length) { data.children.forEach(item =&gt; { // data.checked = checked; 这里和else一定要用this.$set不然节点会失去响应式,改了很久 this.$set(data, 'checked', checked); this.checkChild(checked, item); }); } else { this.$set(data, 'checked', checked); } this.$forceUpdate() }, }};&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.table { display: flex; overflow: auto;}/deep/.title { width: 156px; display: flex; align-items: center; text-align: center; justify-content: center; border-bottom: 0.5px solid #D8D8D8; background-color: #FAFAFA; .el-checkbox{ color: #000000; .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner{ background-color:#0C88BE; border-color:#0C88BE; } .el-checkbox__input.is-checked+.el-checkbox__label{ color: #000000; } }}/deep/.secondTitle{ width: 156px; display: flex; align-items: center; text-align: center; justify-content: center; border-left: 0.5px solid #D8D8D8; border-bottom: 0.5px solid #D8D8D8; .el-checkbox{ color: #000000; .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner{ background-color:#0C88BE; border-color:#0C88BE; } .el-checkbox__input.is-checked+.el-checkbox__label{ color: #000000; } }}.content { flex: 1;}.item-content { display: flex;}.cell { width: 156px; border-bottom: 0.5px solid #D8D8D8; border-left: 0.5px solid #D8D8D8; border-right: 0.5px solid #D8D8D8; display: flex; align-items: center; justify-content: center; height: 54px;}.last-content { flex: 1; border-bottom: 0.5px solid #D8D8D8; overflow: auto; padding: 16px 14px; justify-content: flex-start; text-align: left; display: flex; border-left: none;}.last-child-item { //flex: 40%; margin-right: 34px;}.content-item { display: flex;}/deep/.permission-subTable{ .el-checkbox{ color: #000000; .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner{ background-color:#0C88BE; border-color:#0C88BE; } .el-checkbox__input.is-checked+.el-checkbox__label{ color: #000000; } }}&lt;/style&gt;&lt;style lang=&quot;less&quot;&gt;.permission-subTable { font-size: 12px; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #000000;}&lt;/style&gt; 重要的逻辑是在watch里面,监听的是每个节点下面的children,做的逻辑是判断下面的的所有节点是否全部选中和部分选中,全部选照片那个这设置当前节点的checked为true,全部未选中设置checked属性为false,选中节点数量在0-children.length之间则设置indeterminate为true。 最终效果","link":"/2023/02/28/vue-element%E5%AE%9E%E7%8E%B0%E6%A8%AA%E5%90%91%E6%A0%91%E7%8A%B6%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6/"},{"title":"vue3 ts 项目中因为路由加载方式不同导致的热更新失效及解决办法","text":"问题:发现控制台一直输出的是热更新失效 1[vite] page reload src/pages/Login/index.vue (circular imports) 此时路由的写法是这样的 router.ts 1234567891011121314151617181920212223242526272829303132333435363738394041import { createRouter, createWebHashHistory } from 'vue-router';import { RouteRecordRaw } from 'vue-router';const routes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Index', redirect: '/login', }, { path: '/login', name: 'Login', meta: { title: '登录', }, component: () =&gt; import('@/pages/Login/index.vue'), }, { path: '/workbench', name: 'Workbench', meta: { title: '首页', }, component: () =&gt; import('../pages/Workbench/index.vue'), }, { path: '/intern', name: 'Intern', meta: { title: '实习生', }, component: () =&gt; import('@/pages/Intern/index.vue'), },];const router = createRouter({ history: createWebHashHistory(), routes: routes,});export default router; 入口文件是这样的 main.ts 12345678910111213141516171819202122232425import { createApp, type Directive } from 'vue';import App from './App.vue';import bus from './lib/bus';import router from './router';import routes from './router/route';import { setupStore } from '@/store/store';import './styles/index.css';import './styles/tailwind.css';const app = createApp(App);// 自定义指令import * as directives from '@/directives';Object.keys(directives).forEach(key =&gt; { app.directive(key, (directives as { [key: string]: Directive })[key]);});// routes.forEach(route =&gt; {// router.addRoute(route);// });setupStore(app);app.use(router);app.config.globalProperties.$bus = bus;app.mount('#app'); 经过问题排查发现是排除发现是循环引用导致的热更新失效 在接口文件xxxStore.ts中引入了router，router中引用了组件，在接口文件xxxStore.ts，导致了 循环引用 解决办法: router目录下新建route.ts 1234567891011121314151617181920212223242526272829303132333435import { RouteRecordRaw } from 'vue-router';const routes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Index', redirect: '/login', }, { path: '/login', name: 'Login', meta: { title: '登录', }, component: () =&gt; import('@/pages/Login/index.vue'), }, { path: '/workbench', name: 'Workbench', meta: { title: '首页', }, component: () =&gt; import('../pages/Workbench/index.vue'), }, { path: '/intern', name: 'Intern', meta: { title: '实习生', }, component: () =&gt; import('@/pages/Intern/index.vue'), },];export default routes; index.ts 123456789import { createRouter, createWebHashHistory } from 'vue-router';const router = createRouter({ history: createWebHashHistory(), routes: [],});export default router; main.ts 1234567891011121314151617181920212223242526import { createApp, type Directive } from 'vue';import App from './App.vue';import bus from './lib/bus';import router from './router';import routes from './router/route';import { setupStore } from '@/store/store';import './styles/index.css';import './styles/tailwind.css';const app = createApp(App);// 自定义指令import * as directives from '@/directives';Object.keys(directives).forEach(key =&gt; { app.directive(key, (directives as { [key: string]: Directive })[key]);});routes.forEach(route =&gt; { router.addRoute(route);});setupStore(app);app.use(router);app.config.globalProperties.$bus = bus;app.mount('#app'); 重新启动项目可以看到现在已经生效了,解决 114:31:58 [vite] hmr update /src/pages/Login/index.vue, /src/styles/tailwind.css","link":"/2024/03/14/vue3-ts-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A0%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88/"},{"title":"什么是闭包-从词法作用域角度分析","text":"在 学习这部分的知识之前我们一定要对变量作用域,let，const（现代方式），var（过去留下来的方式）。这三种声明变量的方式有所了解才行。 在很多地方我们会看到这么一句话：外部函数返回一个持有外部函数变量的内部函数，这种情况就会产生闭包，像下面这种： 12345678910111213function makeCounter() { let count = 0; return function() { return count++; };}let counter = makeCounter();alert( counter() ); // 0alert( counter() ); // 1alert( counter() ); // 2 我们在对词法环境有所了解后，就会对闭包这个东西有更深层次的理解。可以继续往下看一下- 代码块如果我们在代码块{...}内声明了一个变量,那么这个变量只在该代码块内生效。看下面的例子。 123456789{ // 使用在代码块外不可见的局部变量做一些工作 let message = &quot;Hello World&quot;; // 只在此代码块内可见 alert(message); // Hello World}alert(message); // 报错,访问不到message,Error: message is not defined 我们可以用{...}和let一起使用来隔离代码，每段代码执行自己的任务，拥有并使用自己的变量，像下面这样 1234567891011{ // 显示 message let message = &quot;Hello&quot;; alert(message);}{ // 显示另一个 message let message = &quot;World&quot;; alert(message);} 注意在没有相应的代码块的情况下let声明的变量重复声明会报错！！！ 1234567// 显示 messagelet message = &quot;Hello&quot;;alert(message);// 显示另一个 messagelet message = &quot;Goodbye&quot;; // Error: variable already declaredalert(message); 对于 if，for 和 while 等，在 {…} 中声明的变量也仅在内部可见： 123456for (let i = 0; i &lt; 3; i++) { // 变量 i 仅在这个 for 循环的内部可见 alert(i); // 0，然后是 1，然后是 2}alert(i); // Error, no such variable 词法环境1.变量在js 中，每个运行的函数，代码块{...}以及整个脚本，都有一个都有一个被称为 词法环境（Lexical Environment） 的内部（隐藏）的关联对象。 词法环境对象由两部分组成： 1.环境记录（Environment Record） —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。 2.对外部词法环境的引用，与外部代码相关联。 我们可以在代码块中声明很多的变量，这些变量就是环境记录这个特殊的内部关联对象的属性，我们获取修改这些变量就意味着我们在获取或者修改词法环境中的属性。看下面这段简单的代码代码这个图片，出自（https://zh.javascript.info/） 在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 null。很容易理解句号。 再看下面这段代码，随着代码开始并继续运行，词法环境发生了变化。 1.当脚本开始运行，词法环境预先填充了所有声明的变量。 最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 let 声明前，不能引用它。几乎就像变量不存在一样。 换句话说在这个代码块里面js引擎扫了一边，知道你有哪些变量了，但是js引擎要按照流程办事，这个变量必须用let 给他安个名字，我才能对它进行操作 2.然后 let phrase 定义出现了。它尚未被赋值，因此它的值为 undefined。从这一刻起，我们就可以使用变量了。 3.phrase 被赋予了一个值。 4.phrase 的值被修改。 总结一下 变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。 操作变量实际上是操作该对象的属性。 2.函数声明一个函数其实也是一个值，就像变量一样。 但是不同的是 函数声明的初始化会被立即完成。 可以这样理解 js 引擎先预先扫描一个代码块，里面有变量有属性，在代码运行的阶段，我要使用它，变量必须要用let去初始化，但是函数不需要了，js引擎已经在第一次扫描的时候，函数就初始化完成了看下面的图 这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 let say = function(name)...。 3.内部和外部的词法环境在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。 例如，对于 **say(“John”)**，它看起来像这样（当前执行位置在箭头标记的那一行上）： 在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）： 内部词法环境与 say 的当前执行相对应。它具有一个单独的属性：name，函数的参数。我们调用的是 say(“John”)，所以 name 的值为 “John”。外部词法环境是全局词法环境。它具有 phrase 变量和函数本身。 这样看在函数say(&quot;John&quot;)没调用之前只有一个全局的词法环境 环境记录中保存着两个属性 phrase：hello和 say：function，外部的引用为null，没有地方引用当前这个词法环境。 现在say(&quot;John&quot;)开始调用，新建了一个词法环境（内部），内部词法环境记录中有一个属性单独的属性：name，函数的参数。我们调用的是 say(&quot;John&quot;)，所以 name 的值为 “John”，这个时候这段代码alert(`${pharse}`)的执行他在自己的词法环境中找不到变量pharse，所以引用了外部，在这里内部词法环境就有了对外部的引用了，看一下这个搜索过程 总结一下： 当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。 4.返回函数让我们现在再用词法环境来探索一下闭包这个例子 12345678910111213function makeCounter() { let count = 0; return function() { return count++; };}let counter = makeCounter();alert( counter() ); // 0alert( counter() ); // 1alert( counter() ); // 2 上面函数调用的例子让我们现在可以知道，在每次 makeCounter() 调用的开始，都会创建一个新的词法环境对象，以存储该 makeCounter 运行时的变量。c 在这里有点不一样的地方，在执行 makeCounter() 的过程中创建了一个仅占一行的嵌套函数：return count++。我们尚未运行它，仅创建了它。在这里我们创建了一个函数。 这里有个十分重要的概念：所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。 这个概念非常重要，在知道这个概念之后，我们大概可以解释一下闭包的情况了， counter.[[Environment]] 有对 {count: 0} 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。[[Environment]] 引用在函数创建时被设置并永久保存。 新的counter函数在诞生的时候就有了对{count: 0}词法环境的引用。 稍后，当调用 counter() 时，会为该调用创建一个新的词法环境，在执行counter++的时候本身是没有counter这个变量的，但是她诞生的时候她的[[Environment]]有对外部词法环境{count: 0}的引用，向上查找就找到了count变量执行了count++ 看，现在，当 counter() 中的代码查找 count 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 makeCounter() 的词法环境，并且在哪里找到就在哪里修改。在变量所在的词法环境中更新变量。 继续执行 如果我们调用 counter() 多次，count 变量将在同一位置增加到 2，3 等。 总结外部函数返回一个持有外部函数变量的内部函数，返回一个内部函数 即内部函数在诞生的时候都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用—–持有外部函数的变量。内部函数诞生后在调用时，会沿着词法环境对外部的引用去查找变量如果在外部词法环境中找到了该变量，那么就在那个地方进行修改，这样就产生了闭包。","link":"/2022/08/29/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E4%BB%8E%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90/"},{"title":"全方位理解React类式组件新旧生命周期","text":"只有在react类式组件中才会有生命周期的概念,因为 class 组件会创建对应的实例，而函数组件不会(函数式组件是用useEffect来体现生命周期的)。组件实例从被创建到被销毁的过程称为组件的生命周期。我们每一次状态的更改都会执行render()阶段和commit阶段,在新版废弃了一些钩子,又新增了一些钩子,我们从旧版到新版来看每一个钩子,然后分析页面渲染时执行的顺序。 一、旧版生命周期 constructor 该方法只会执行一次，调用该方法会返回一个组件实例。在这个阶段我们可以对组件this.state进行赋值,也可以直接获取到props,在其他地方我们不能直接赋值,只能通过this.setState进行状态修改 componentWillMount（UNSAFE） 这个钩子我们用的比较少,是在render渲染之前调用,在这个钩子里修改state是不会触发重新渲染页面,因为此时页面还未挂在到Dom上我们一般不会在这里初始化state,一般是在constructor中初始化 state,在componentDidMount发起异步请求 render（） render 函数是纯函数，也就是对于相同的 state 和 props，它总是返回相同的渲染结果。如果 shouldComponentUpdate(后面会提到) 生命周期钩子返回 false，则 render 方法不会执行。 componentDidMount 在组件挂载之后执行，也只会执行一次,在浏览器更新视图之前调用,在 componentDidMount钩子中调用this.setState,会触发额外的渲染，会再一次调用 render 函数，但是浏览器中视图的更新只会执行一次。我们一般会在这个钩子里发起请求,添加订阅等 componentWillReceiveProps()（UNSAFE） 在组件嵌套,传入props时,组件在接收到新的props的时候调用,第一次调用不算,不会更新,可以接收props参数,是父组件传过来最新的props shouldComponentUpdate() 在修改状态后会调用该生命周期,该生命周期的必须有返回值,默认是true,如果改成false则在状态更新后,不会调用后续的componentWillUpdate(),render(),componentDidUpdate(), componentWillUpdate()（UNSAFE） 在组件即将更新之前调用，如果 shouldComponentUpdate阀门 函数返回 false，则不会调用 componentWillUpdate 方法。这个生命周期钩子和 componentWillMount 类似，调用的时机是相同的，只不过 componentWillMount 在组件首次渲染时执行，而 componentWillUpdate 在组件后续更新时执行。这两个生命周期函数都不经常使用。 componentDidUpdate() 在组件更新后立即调用，首次渲染不会调用该方法。和 componentDidMount 一致，只是 componentDidMount 在首次渲染时调用，而 componentDidUpdate 在后续的组件更新时调用。可以在这个生命周期中直接调用 this.setState，componentDidUpdate 接收三个参数，分别是 prevProps、prevState、snapshot，即：前一个状态的 props，前一个状态的 state、getSnapshotBeforeUpdate 的返回值。如果组件实现了 getSnapshotBeforeUpdate 生命周期函数，则 getSnapshotBeforeUpdate 的返回值将作为 componentDidUpdate 的第三个参数。使用场景：在这个生命周期方法中，可以对 DOM 进行操作或者进行网络请求。 componentWillUnmount() 这个生命周期函数会在组件卸载以及销毁之前调用。使用场景： 通常用来执行组件的清理操作，例如：清除 timer、取消网络请求、清除订阅等。 在新版中,这三个钩子被废弃1.componentWillMount2.componentWillReceiveProps3.componentWillUpdate他们很容易被程序员滥用和误用 二、新版生命周期 static getDerivedStateFromProps() 它会在调用 render 方法之前被调用，不管是在初始挂载时还是在后续组件更新时都会被调用。它是一个静态方法，接收 props 和 state 两个参数。它的调用时机和 componentWillMount、componentWillUpdate、componentWillReceiveProps 一样都是在 render 方法被调用之前，它可以作为 componentWillMount、componentWillUpdate 和 componentWillReceiveProps 的替代方案。它可以返回一个对象，用来更新 state，就像它的名字一样，从 props 中获取衍生的 state。如果不需要更新 state 则可以返回 null。如果子组件的更新依赖于父组件的props,那么我们可以在这个生命周期中做处理,在封装组件时可以用到 static getSnapshotBeforeUpdate() 此生命周期函数在最近一次渲染提交至 DOM 树之前执行，此时 DOM 树还未改变，我们可以在这里获取 DOM 改变前的信息，例如：更新前 DOM 的滚动位置。它接收两个参数，分别是：prevProps、prevState，上一个状态的 props 和上一个状态的 state。它的返回值将会传递给 componentDidUpdate 生命周期钩子的第三个参数。使用场景： 需要获取更新前 DOM 的信息时。比如state状态修改之前滚动条的位置。 三、旧版生命周期执行顺序 初始化阶段 1.constructor()2.componentWillMount()3.render()4.componentDidMount() 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1.shouldComponentUpdate()2.componentWillUpdate()3.render()4.componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1.componentWillUnmount() 四、新版生命周期执行顺序 初始化阶段: 由ReactDOM.render()触发—初次渲染 1.constructor() 2.getDerivedStateFromProps 3.render() 4.componentDidMount() 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1.getDerivedStateFromProps 2.shouldComponentUpdate() 3.render() 4.getSnapshotBeforeUpdate 5.componentDidMount() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1.componentWillUnmount() 五、父子组件嵌套生命周期执行顺序 初始化阶段:父子组件第一次进行渲染加载时： 1.Parent 组件： constructor()2.Parent 组件： getDerivedStateFromProps()3.Parent 组件： render()4.Child 组件： constructor()5.Child 组件： getDerivedStateFromProps()6.Child 组件： render()7.Child 组件： componentDidMount()8.Parent 组件： componentDidMount() 子组件修改自身状态 state 1.Child 组件： getDerivedStateFromProps()2.Child 组件： shouldComponentUpdate()3.Child 组件： render()4.Child 组件： getSnapshotBeforeUpdate()5.Child 组件： componentDidUpdate() 修改父组件中传入子组件的 props state 1.Parent 组件： getDerivedStateFromProps()2.Parent 组件： shouldComponentUpdate()3.Parent 组件： render()4.Child 组件： getDerivedStateFromProps()5.Child 组件： shouldComponentUpdate()6.Child 组件： render()7.Child 组件： getSnapshotBeforeUpdate()8.Parent 组件： getSnapshotBeforeUpdate()9.Child 组件： componentDidUpdate()10.Parent 组件： componentDidUpdate() 卸载子组件 1.Parent 组件： getDerivedStateFromProps()2.Parent 组件： shouldComponentUpdate()3.Parent 组件： render()4.Parent 组件： getSnapshotBeforeUpdate()5.Child 组件： componentWillUnmount()6.Parent 组件： componentDidUpdate() 重新挂载子组件 1.Parent 组件： getDerivedStateFromProps()2.Parent 组件： shouldComponentUpdate()3.Parent 组件： render()4.Child 组件： constructor()5.Child 组件： getDerivedStateFromProps()6.Child 组件： render()7.Parent 组件： getSnapshotBeforeUpdate()8.Child 组件： componentDidMount()9.Parent 组件： componentDidUpdate()","link":"/2022/05/25/%E5%85%A8%E6%96%B9%E4%BD%8D%E7%90%86%E8%A7%A3React%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"利用MessageChannel深拷贝","text":"平时做对象深拷贝我们一般回想到用JSON,像这种 12345let obj = { a:1, b:2 } let _obj = JSON.parse(JSON.stringify(obj)) 但是这种会有问题,遇到循环引用对象就会解析错误 123456let obj = { a:1, b:2 } obj.c=obj let _obj = JSON.parse(JSON.stringify(obj)) 我们可以用MessageChannel()来实现深拷贝,我们先实例化MessageChannel构造函数会得到port1,port2,两个端点,一个用来发送信息一个用来接收信息,通过打印发现我们已经实现了深拷贝 12345678910let obj={ a:1, b:2 } const {port1,port2} = new MessageChannel() port1.postMessage(obj) port2.onmessage=(msg)=&gt;{ console.log(msg.data) console.log(msg.data==obj)//fasle } 循环引用的数据也是可以的,没什么问题 1234567891011let obj={ a:1, b:2 } const {port1,port2} = new MessageChannel() obj.c=obj port1.postMessage(obj) port2.onmessage=(msg)=&gt;{ console.log(msg.data) console.log(msg.data==obj)//fasle } 那么我们可以封装一个函数 123456789function deepClone(obj) { return new Promise((resolve)=&gt;{ const {port1,port2} = new MessageChannel() port1.postMessage(obj) port2.onmessage=(msg)=&gt;{ resolve(msg.data) } }) }","link":"/2022/12/27/%E5%88%A9%E7%94%A8MessageChannel%E6%B7%B1%E6%8B%B7/"},{"title":"在Vue3中使用quill富文本编辑器","text":"首先安装 1npm install @vueup/vue-quill@latest --save main.js 123456789101112131415161718import { createApp } from 'vue'import App from './App.vue'import { QuillEditor } from '@vueup/vue-quill'import '@vueup/vue-quill/dist/vue-quill.snow.css';import '@vueup/vue-quill/dist/vue-quill.bubble.css'import 'element-plus/dist/index.css'import ElementPlus from 'element-plus'import router from './router'import store from './store'const app = createApp(App)app.use(store)app.use(router)app.use(ElementPlus)app.component('QuillEditor', QuillEditor)app.mount('#app') Myeditor.vue简单封装一下， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;div&gt; &lt;!-- 注意区别，content 和 contentType --&gt; &lt;QuillEditor ref=&quot;quillEditor&quot; v-model:content=&quot;content&quot; contentType=&quot;html&quot; :options=&quot;editorOption&quot; @blur=&quot;onEditorBlur($event)&quot; @focus=&quot;onEditorFocus($event)&quot; @editorChange=&quot;onEditorChange($event)&quot; @ready=&quot;onEditorReady($event)&quot; /&gt; &lt;button v-on:click=&quot;insertImg&quot;&gt;插入一张图片&lt;/button&gt; &lt;button v-on:click=&quot;insertText&quot;&gt;插入文字&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import { ref,toRaw,defineEmits,defineExpose } from 'vue';// import {Quill} from &quot;@vueup/vue-quill&quot;;//富文本初始化配置// eslint-disable-next-line no-unused-varslet myQuillconst quillEditor = ref(null)let content = ref(&quot;&quot;);//定义content//获取ref实例//富文本面板配置const editorOption= { modules: { toolbar: false, // 这里将工具栏隐藏 }, placeholder: '请输入内容...'}//富文本准备完成const onEditorReady =(quill)=&gt;{ myQuill = quill}//给父元素传值const emit = defineEmits(['getText','getHtml'])const onEditorChange = ()=&gt;{ const html = toRaw(quillEditor.value).getHTML() const myText = toRaw(quillEditor.value).getText() const quill = toRaw(quillEditor.value).getQuill() emit('getText',myText) emit('getHtml',html) console.log(content.value,'-----content----') // console.log(myText,'-----html----') console.log(quill,'-------quillEditor----------')}const onEditorFocus = (e)=&gt;{ console.log(e,'--------onEditorFocus--------')}const onEditorBlur = (e)=&gt;{ console.log(e,'--------onEditorBlur--------')}const insertImg = ()=&gt;{ const quill = toRaw(quillEditor.value).getQuill() quill.insertEmbed(length, 'image', &quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;) quill.setSelection(length + 1) // quill.insertEmbed(quill.selection.savedRange.index,&quot;MsgEmoji&quot;,{src: &quot;https://www.w3school.com.cn/i/eg_tulip.jpg&quot;, code: &quot;0&quot; },Quill.sources.USER);}const insertText = (value)=&gt;{ const quill = toRaw(quillEditor.value).getQuill() //插入指定表情转移文字 quill.insertEmbed(quill.selection.savedRange.index, 'text', value) quill.setSelection(quill.selection.savedRange.index+value.length)}//将插入表情的方法暴露给父组件defineExpose({ insertText })&lt;/script&gt;&lt;style&gt;.ql-editor{ height: 300px;}&lt;/style&gt;","link":"/2023/09/07/%E5%9C%A8Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"深入理解js继承","text":"在理解继承之前,懂得什么是原型链是非常重要的,必须熟练掌握,__prote__,prototype,constructor这几个属性,并且清楚他们之间的关系。 1.原型链继承先看一个例子 123456789101112131415161718function Parent() { this.name='父亲' } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //儿子身上并没有定义任何属性和方法,现在儿子也想当爸爸,访问到Parent上的属性和方法 function Child() { } //我们让child实例的原型等于 Parent实例 Child.prototype = new Parent() let child = new Child() let parent = new Parent() //这样孩子就能做爸爸了 console.log(child.name)//父亲 child.Say()//我是你爸爸 child实例化对象—&gt;Child.prototype(也是Parent的实例对象)—-&gt;Parent.prototype 实例化出来的child 可以访问到他构造函数Child.prototype,这时,我们的Child.prototype是构造函数Parent的实例对象时Parent new出来的,那么Child.prototype就可以通过原型访问到Parent.prototype,这就是原型链继承 注意:原型链继承在访问引用类型数据上可能会出现问题,我们来看下面的例子 1234567891011121314151617181920function Parent() { this.name=['父亲','打篮球'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //儿子身上并没有定义任何属性和方法,现在儿子也想当爸爸,访问到Parent上的属性和方法 function Child() { } //我们让child实例的原型等于 Parent实例 Child.prototype = new Parent() let child1 = new Child() let child2 = new Child() //改变name值 child1.name.push('哈哈哈') console.log(child1.name)//['父亲', '打篮球', '哈哈哈'] console.log(child2.name)//['父亲', '打篮球', '哈哈哈'] // 两个实例的的name值相互影响了(引用类型数据) 两个实例的的name值相互影响了(引用类型数据) 这是因为由于基本类型和引用类型数据的保存方式不同引起的,引用类型保存的都是指针,child1child2指针不同但是指向同一地址,现在把地址里的内容改了,所以导致访问的值都变了 这里我们都是是通过Parent的实例对象进行继承的所以都指向了同一个地址 我们可以用构造函数继承解决这个问题 2.构造函数继承1234567891011121314151617181920212223242526function Parent() { this.name='父亲' this.hobby=['唱','跳','rap'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //利用call改变this指向,将Parent的this.指向Child function Child() { Parent.call(this) } let child1 = new Child() let child2 = new Child() //改变name 基本数据类型的值没有影响 child1.name='儿子' console.log(child1.name)//儿子 console.log(child2.name)//父亲 //改变hobby 引用类型数据的值没有影响 child1.hobby.push('篮球') console.log(child1.hobby)//['唱','跳','rap','篮球'] console.log(child2.hobby)//['唱','跳','rap'] 我们在Child函数中利用call借用Parent的this,改变Child的this,就可以访问到Parent 身上的属性, 注意:构造函数继承不能让child访问到Parent原型身上的方法的,这是他的缺陷 3.组合继承(伪经典继承)123456789101112131415161718192021222324252627function Parent() { this.name='父亲' this.hobby=['唱','跳','rap'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //利用call改变this指向,将Parent的this.指向Child function Child() { //执行了一次Parent() Parent.call(this) } //执行了一次Parent() Child.prototype = new Parent() let child1 = new Child() let child2 = new Child() //改变name 基本数据类型的值没有影响 child1.name='儿子' console.log(child1.name)//儿子 console.log(child2.name)//父亲 //改变hobby 引用类型数据的值没有影响 child1.hobby.push('篮球') console.log(child1.hobby)//['唱','跳','rap','篮球'] console.log(child2.hobby)//['唱','跳','rap'] 这种继承方式相当于将前面两种方式结合了一下,同时用原型链继承和改变this指向,但是这种方式执行了调用了两次Parent(),所以不好 4.寄生组合继承(经典继承)123456789101112131415161718192021222324252627282930function Parent() { this.name='父亲' this.hobby=['唱','跳','rap'] } Parent.prototype.Say=function (){ console.log('我是你爸爸') } //利用call改变this指向,将Parent的this.指向Child function Child() { //执行了一次Parent() Parent.call(this) } //执行了一次Parent() // Child.prototype = new Parent() //寄生组合继承的核心,让Child原型继承到Parent的原型 //Object.create(Parent.prototype)会返回一个对象,根据传入的参数觉得 Child.prototype = Object.create(Parent.prototype) let child1 = new Child() let child2 = new Child() //改变name 基本数据类型的值没有影响 child1.name='儿子' console.log(child1.name)//儿子 console.log(child2.name)//父亲 //改变hobby 引用类型数据的值没有影响 child1.hobby.push('篮球') console.log(child1.hobby)//['唱','跳','rap','篮球'] console.log(child2.hobby)//['唱','跳','rap'] 寄生组合继承的核心就是让Child原型继承到Parent的原型,这里用Object.create(Parent.prototype)返回Parent的原型对象,这样就解决了调用两次的问题","link":"/2022/01/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%BB%A7%E6%89%BF/"}],"tags":[{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"uniapp","slug":"uniapp","link":"/tags/uniapp/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"react","slug":"react","link":"/tags/react/"}],"categories":[{"name":"dart学习","slug":"dart学习","link":"/categories/dart%E5%AD%A6%E4%B9%A0/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"uniapp","slug":"uniapp","link":"/categories/uniapp/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"vue3","slug":"vue3","link":"/categories/vue3/"},{"name":"react","slug":"react","link":"/categories/react/"}],"pages":[{"title":"","text":"Title -关于我 2020年普通本科毕业,一个前端菜鸟,兴趣使然,努力学习技术中... 学习工作的同时,热爱生活,热爱自己,热爱家人 -技术栈 vue: 对vue 可能是最熟悉的了,从工作开始就一直是用的vue进行的开发,h5公众号,小程序,web端,uniapp,从最开始的vue2 vue2.7 到现在的vue3,可能用的越来越多,感觉vue也是越来越好用了,面对大而杂的项目来说,也是非常的 nice,pinia和hooks写法在大型项目中表现个人感觉也是越来越优异,越来越舒服 react: 对react的深度可能没有像vue那么深,上一般项目是没有问题的,MVVM模型的设计思想:数据驱动视图加 上对vue的熟练度,react 掌握还是很快的,react对jsx语法的完美支持,让react使用起来更加灵活,所以很多人对react也是越写越爱爱不释手 Flutter: 为什么还会Flutter,为什么会选择flutter原因有两个,1.之前做过简单的跨端开发, 是用的uniapp,做出来的效果很一般,就是不丝滑,能用,再一个编译起来问题比较多很抓狂 ,这东西还是做小程序比较nice。2.Flutter的语言dart和ts比较相似,整体的学习成本要低一些,比较好上手,同时社区也比较活跃,再一个工作这么久深知自己在移动端部分的经验相对薄弱。 Three.js: 对这个的掌握程度只能说入门,能说熟练或者精通的人我都觉得是大牛,这东西到后面需要对计算机图形学有一个极深的理解才行,着色器语言,渲染管线原理,个人理解:完全掌握这些不亚于掌握大前端内容,深度甚至更高!。 -关博客 记录工作中的遇到的一些问题 一些学习笔记 可能有一些其他内容 2022.10.05","link":"/about/index.html"}]}